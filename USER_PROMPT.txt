USER_PROMPT={refactor the contents of the following three files taken from my rk3588 arm64 debian 11 linux operating system in order to holistically adapt those to the following new resolutions/ratio:

```largest_monitor
HDMI-1

new_mode '912x456_60.00' instead of '800x600_60.00'
```

~~~smallest_monitor
DP-1

new_mode '684x427_60.00' instead of '640x480_60.00'
~~~

Here it is the contents of the three news files that needs refactoration:
:::
"""
<root>
<## data-filename="xml_code-block xml" data-code="">
    rk3588_dual/config</source>
    
        output HDMI-1
        crtc 0
        mode 800x600_60.00
        pos 0x0
        primary
        rate 59.86
        x-prop-colorspace Default
        x-prop-non_desktop 0
        output DP-1
        crtc 1
        mode 640x480_60.00
        pos 800x0
        rate 59.38
        x-prop-non_desktop 0
    
</section>
<## data-filename="xml_code-block xml" data-code="">
    rk3588_dual/preswitch</source>
    
        #!/bin/sh
        # autorandr preswitch hook: define and add custom modelines idempotently
        set -eu
        xrandr --newmode "800x600_60.00" 38.25  800 832 912 1024  600 603 607 624 -hsync +vsync 2>/dev/null || true
        xrandr --newmode "640x480_60.00" 23.75  640 664 720 800  480 483 487 500 -hsync +vsync 2>/dev/null || true
        xrandr --addmode "HDMI-1" "800x600_60.00" 2>/dev/null || true
        xrandr --addmode "DP-1" "640x480_60.00" 2>/dev/null || true
    
</section>
<## data-filename="xml_code-block xml" data-code="">
    rk3588_dual/setup</source>
    
        DP-1 --CONNECTED-BUT-EDID-UNAVAILABLE--DP-1
        HDMI-1 --CONNECTED-BUT-EDID-UNAVAILABLE--HDMI-1
    
</section>
</root>
"""
:::

In order to properly accomplish that, the AI ASSISTANT could leverage the following mixed raw contents of some bash scripts that i've found enclosed within the `home` directory of my system but I do not remember their functionality, but I think it is related to setting up 'xrandr' and dual monitors resolutions:

'''raw_mixed_bash_scripts
:::
@@@

```bash

#!/usr/bin/env pwsh
<#
Pwsh Monitor Setup — Integrated, Optimized Build (RB CVT + rate-aware + autorandr + DPI + diagnostics)

Interactive + non-interactive multi-monitor configurator for X11 (Linux)

TARGET: Debian/Ubuntu/Derivatives, Fedora/RHEL/CentOS, openSUSE, Arch-based (pwsh, xrandr)
WM/TERM agnostic (ratpoison/Alacritty etc.)

KEY CAPABILITIES
- Interactive discovery of output order and selection of full (resolution × refresh) candidates parsed from xrandr.
- Pre-seed custom CVT 60 Hz modelines; Reduced Blanking ON by default (opt out with -NoReducedBlanking). Only seeds WxH missing on each output.
- Robust apply: try "--mode <token>", then fallback to "--mode <WxH[i]> --rate <Hz>" when a rate is available.
- Geometry verification with retry; prefers `xrandr --listactivemonitors`, falls back to `--query`.
- Tk red-border overlay confirms the active monitor region.
- Saves layout to JSON and re-applies non-interactively (autostart-ready). Backward compatible with legacy string schema.
- Machine-parsable single-line JSON summaries; optionally include dpi, autorandrSaved, diagDir.
- Optional autorandr integration (save/apply/enable systemd) with sanitized profile names.
- Optional DPI compute/set (primary or average) using xrandr --verbose physical mm.
- Optional diagnostics bundle: xrandr --verbose, EDID decode, ddcutil detect logs.
- Hardened dep install with distro-aware package maps; strict errors; explicit exit codes.

USAGE (examples)
  pwsh -File ./pwsh_monitor_setup.ps1                       # Interactive
  sudo pwsh -File ./pwsh_monitor_setup.ps1 -AutoInstall     # Install deps (root)
  pwsh -File ./pwsh_monitor_setup.ps1 -ApplySavedLayout     # Apply saved
  pwsh -File ./pwsh_monitor_setup.ps1 -SetDPI -DPIMethod avg
  pwsh -File ./pwsh_monitor_setup.ps1 -AutorandrProfileName "office_ultrawide"
  pwsh -File ./pwsh_monitor_setup.ps1 -ApplyAutorandrProfile "office_ultrawide"
  sudo pwsh -File ./pwsh_monitor_setup.ps1 -EnableAutorandr
  pwsh -File ./pwsh_monitor_setup.ps1 -CollectDisplayInfo
  pwsh -File ./pwsh_monitor_setup.ps1 -Help

OPTIONS
  -DebugMode                Verbose logging.
  -AutoInstall              Install dependencies via detected package manager.
  -NoInstall               Do not install; fail fast if missing deps.
  -ApplySavedLayout        Apply saved JSON and exit.
  -ApplyAutorandrProfile   Apply autorandr profile (sanitized) and exit.
  -AutorandrProfileName    Save interactive result as autorandr profile (sanitized).
  -EnableAutorandr         Enable autorandr services (user and system units when root).
  -OverlaySeconds <int>    Seconds to keep red overlay visible (default: 5).
  -SetDPI                  Compute and set DPI via xrandr using mm from --verbose.
  -DPIMethod <primary|avg> DPI calculation method (default: primary).
  -CollectDisplayInfo      Collect xrandr/EDID/ddcutil diagnostics into ~/monitor-info-<ts>.
  -NoReducedBlanking       Use standard CVT timings (disable RB) when seeding modelines.
  -TargetUser <string>     Login user for ownership when run as root (default: SUDO_USER/USER/linaro).
  -ScriptInstallPath       Path to place self-copy used by autostart (default: $HOME/pwsh_monitor_setup.ps1).
  -ConfigPath              Override config JSON (default: $HOME/.config/pwsh-monitor-layout.json).
  -Help                    Show help and exit 0.

EXIT CODES
  0  Success
  1  General error / user abort / final apply failed
  2  Missing dependency / install failure
 20  Headless / no X11 session
 21  No connected monitors
 22  Invalid/empty configuration for -ApplySavedLayout
 23  Config file not found for -ApplySavedLayout
 24  JSON parse error for -ConfigPath
 25  Permission/ownership error during autostart/config
 26  Autorandr operation failed or invalid profile name

MACHINE-PARSABLE SUMMARY (examples)
  {"ok":true,"mode":"interactive","primary":"HDMI-1","order":["HDMI-1","DP-1"],"chosen":{"HDMI-1":"1920x1080@60","DP-1":"2560x1440@74.97"},"configFile":"/home/user/.config/pwsh-monitor-layout.json","autorandrSaved":"office_ultrawide","dpi":96}
#>

[CmdletBinding(PositionalBinding=$false)]
param(
    [switch] $DebugMode,
    [switch] $AutoInstall,
    [switch] $NoInstall,
    [switch] $ApplySavedLayout,
    [string] $ApplyAutorandrProfile,
    [string] $AutorandrProfileName,
    [switch] $EnableAutorandr,
    [switch] $SetDPI,
    [ValidateSet('primary','avg')] [string] $DPIMethod = 'primary',
    [switch] $CollectDisplayInfo,
    [switch] $NoReducedBlanking,
    [switch] $Help,
    [int]    $OverlaySeconds = 5,
    [string] $TargetUser = ($env:SUDO_USER ?? $env:USER ?? 'linaro'),
    [string] $ScriptInstallPath = "$HOME/pwsh_monitor_setup.ps1",
    [string] $ConfigPath,
    [Parameter(ValueFromRemainingArguments=$true)] [string[]] $ExtraArgs
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
if ($DebugMode) { $VerbosePreference = 'Continue' }
if ($args.Count -gt 0) { Write-Error ("Unknown arguments: " + ($args -join ' ')); exit 1 }

function Stop-TranscriptSafe { try { Stop-Transcript | Out-Null } catch {} }

# Transcript
$tsFile = "/tmp/pwsh_monitor_setup-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"
try { Start-Transcript -Path $tsFile -Force | Out-Null } catch {
    $tsFile = Join-Path $HOME "pwsh_monitor_setup-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"
    try { Start-Transcript -Path $tsFile -Force | Out-Null } catch {}
}
Write-Verbose "Transcript: $tsFile"

function Show-Help {
    $path = $PSCommandPath; if (-not $path) { $path = $MyInvocation.MyCommand.Path }
    $content = Get-Content -Raw -Path $path
    $helpBlock = [regex]::Match($content, '(?s)<#\s*(.*?)\s*#>').Groups[1].Value
    if ([string]::IsNullOrWhiteSpace($helpBlock)) {
        Write-Output "Usage: pwsh -File $path [-AutoInstall|-NoInstall] [-ApplySavedLayout] [-ConfigPath <file>] [-OverlaySeconds <int>] [-DebugMode] [-Help]"
    } else {
        Write-Output $helpBlock.Trim()
    }
}

function Test-Cmd([string]$Name) { $null -ne (Get-Command -Name $Name -ErrorAction SilentlyContinue) }

function Test-IsRoot {
    try { ((& id '-u' 2>$null) -eq 0) } catch { try { ((& whoami) -eq 'root') } catch { ($env:USER -eq 'root') } }
}

function Detect-PackageManager {
    if (Test-Cmd 'apt-get') { return 'apt' }
    if (Test-Cmd 'dnf')     { return 'dnf' }
    if (Test-Cmd 'zypper')  { return 'zypper' }
    if (Test-Cmd 'pacman')  { return 'pacman' }
    return $null
}

function Install-Dep([string]$pkg) {
    $pm = Detect-PackageManager
    if (-not $pm) { throw 'No supported package manager found.' }
    if (-not (Test-IsRoot)) { throw 'Auto-install requires root.' }
    switch ($pm) {
        'apt'    { & apt-get update -y; & apt-get install -y $pkg }
        'dnf'    { & dnf install -y $pkg }
        'zypper' { & zypper -n install $pkg }
        'pacman' { & pacman -Sy --noconfirm $pkg }
    }
}

function Ensure-DepMapped([string]$cmd, [hashtable]$pkgMap, [string]$friendly) {
    if (Test-Cmd $cmd) { return }
    if ($NoInstall) { throw "Missing dependency '$friendly' and -NoInstall was specified." }
    if (-not $AutoInstall) { throw "Missing dependency '$friendly'. Rerun with -AutoInstall or install it manually." }
    $pm = Detect-PackageManager
    if (-not $pm) { throw 'No supported package manager found.' }
    if (-not $pkgMap.ContainsKey($pm)) { throw "Unsupported package manager for '$friendly'." }
    Install-Dep $pkgMap[$pm]
    if (-not (Test-Cmd $cmd)) { throw "Dependency '$friendly' not available after install." }
}

function Ensure-DepOptional([string]$cmd, [hashtable]$pkgMap) {
    if (Test-Cmd $cmd) { return $true }
    if ($NoInstall -or -not $AutoInstall) { return $false }
    $pm = Detect-PackageManager
    if (-not $pm) { return $false }
    $pkg = $pkgMap[$pm]
    if (-not $pkg) { return $false }
    try { Install-Dep $pkg } catch { return (Test-Cmd $cmd) }
    return (Test-Cmd $cmd)
}

function Test-PythonTk {
@'
import sys
try:
    import tkinter as t
    root = t.Tk()
    root.withdraw()
    print("OK")
except Exception as e:
    print("ERR", e)
    sys.exit(1)
'@ | Set-Content -Path ($tmp = [IO.Path]::GetTempFileName() + '.py') -Encoding UTF8
    try {
        $p = Start-Process -FilePath 'python3' -ArgumentList @($tmp) -PassThru -NoNewWindow -Wait
        return ($p.ExitCode -eq 0)
    } finally { try { Remove-Item $tmp -Force -ErrorAction SilentlyContinue } catch {} }
}

function Assert-XSessionOrExit {
    if (-not $env:DISPLAY) { $env:DISPLAY = ':0' }
    for ($i=0; $i -lt 6; $i++) {
        try { & xrandr --current | Out-Null; return } catch { Start-Sleep -Milliseconds 300 }
    }
    Write-Error 'No X11 display/xrandr available (headless or X not running).'
    Stop-TranscriptSafe; exit 20
}

try {
    Ensure-DepMapped 'xrandr'  @{ apt='xrandr'; dnf='xrandr'; zypper='xrandr'; pacman='xorg-xrandr' } 'xrandr'
    Ensure-DepMapped 'python3' @{ apt='python3'; dnf='python3'; zypper='python3'; pacman='python' }  'python3'
    # Optional helpers — best-effort
    if (-not (Test-Cmd 'cvt'))         { try { Ensure-DepOptional 'cvt'         @{ apt='x11-xserver-utils'; dnf='xorg-x11-server-utils'; zypper='xorg-x11'; pacman='xorg-xrandr' } } catch {} }
    if (-not (Test-Cmd 'edid-decode')) { try { Ensure-DepOptional 'edid-decode' @{ apt='edid-decode'; dnf='edid-decode'; zypper='edid-decode'; pacman='edid-decode' } } catch {} }
    if (-not (Test-Cmd 'ddcutil'))     { try { Ensure-DepOptional 'ddcutil'     @{ apt='ddcutil'; dnf='ddcutil'; zypper='ddcutil'; pacman='ddcutil' } } catch {} }
} catch {
    Write-Error $_.Exception.Message
    Stop-TranscriptSafe; exit 2
}

Assert-XSessionOrExit

if (-not (Test-PythonTk)) {
    try {
        $pm = Detect-PackageManager
        switch ($pm) {
            'apt'    { Install-Dep 'python3-tk' }
            'dnf'    { Install-Dep 'python3-tkinter' }
            'zypper' { Install-Dep 'python3-tk' }
            'pacman' { Install-Dep 'tk' }
            default  { throw 'Unsupported package manager for tkinter.' }
        }
    } catch {
        Write-Error "Unable to install/verify tkinter: $($_.Exception.Message)"
        Stop-TranscriptSafe; exit 2
    }
    if (-not (Test-PythonTk)) {
        Write-Error 'python3-tk/tkinter not available after installation.'
        Stop-TranscriptSafe; exit 2
    }
}

$root = Test-IsRoot
$homeTarget = if ($root) { "/home/$TargetUser" } else { $HOME }
if (-not $env:DISPLAY) { $env:DISPLAY = ':0' }
if ($root) {
    $xaUser = "/home/$TargetUser/.Xauthority"
    if (Test-Path $xaUser) { $env:XAUTHORITY = $xaUser }
    elseif (Test-Path '/root/.Xauthority') { $env:XAUTHORITY = '/root/.Xauthority' }
} elseif (-not $env:XAUTHORITY) {
    $env:XAUTHORITY = Join-Path $HOME '.Xauthority'
}

if (-not $ConfigPath -or [string]::IsNullOrWhiteSpace($ConfigPath)) {
    $ConfigPath = Join-Path (Join-Path $homeTarget '.config') 'pwsh-monitor-layout.json'
}

# Sanitize autorandr names
function Sanitize-ProfileName([string]$name) { if ($null -eq $name) { return $null }; $s = ($name -replace '[^a-zA-Z0-9._-]', '_').Trim(); if ($s.Length -gt 80) { $s = $s.Substring(0,80) }; if ([string]::IsNullOrWhiteSpace($s)) { return $null }; return $s }
$AutorandrProfileNameSan  = if ($PSBoundParameters.ContainsKey('AutorandrProfileName'))  { Sanitize-ProfileName $AutorandrProfileName } else { $null }
$ApplyAutorandrProfileSan = if ($PSBoundParameters.ContainsKey('ApplyAutorandrProfile')) { Sanitize-ProfileName $ApplyAutorandrProfile } else { $null }

if ($Help) { Show-Help; Stop-TranscriptSafe; exit 0 }

# ---------------- Geometry + parsing ----------------
function Get-XrandrLines { (& xrandr --query | Out-String) -split "`n" }

function Get-ConnectedOutputs { Get-XrandrLines | ForEach-Object { if ($_ -match '^\s*(\S+)\s+connected') { $Matches[1] } } }

function Get-CurrentGeometry([string]$Output) {
    try {
        $lm = (& xrandr --listactivemonitors 2>$null | Out-String) -split "`n"
        foreach ($ln in $lm) {
            if ($ln -match '\s\b' + [Regex]::Escape($Output) + '$') {
                if ($ln -match '(\d+)/(?:\d+)x(\d+)/(?:\d+)\+(\d+)\+(\d+)') {
                    return [pscustomobject]@{ W=[int]$Matches[1]; H=[int]$Matches[2]; X=[int]$Matches[3]; Y=[int]$Matches[4] }
                }
            }
        }
    } catch {}
    $pattern = '^' + [Regex]::Escape($Output) + '\b.*?(\d{3,5}x\d{3,5})\+(\d+)\+(\d+)'
    $ln2 = Get-XrandrLines | Where-Object { $_ -match $pattern } | Select-Object -First 1
    if ($ln2 -and ($ln2 -match $pattern)) {
        $wh = $Matches[1]; $x = [int]$Matches[2]; $y = [int]$Matches[3]
        $m2 = [regex]::Match($wh, '^(\d{3,5})x(\d{3,5})$')
        if ($m2.Success) { return [pscustomobject]@{ W=[int]$m2.Groups[1].Value; H=[int]$m2.Groups[2].Value; X=$x; Y=$y } }
    return $null
}

function Invoke-Xrandr([string[]]$XRArgs) {
    if ($DebugMode) { Write-Verbose ("xrandr " + ($XRArgs -join ' ')) }
    $p = Start-Process -FilePath 'xrandr' -ArgumentList $XRArgs -PassThru -NoNewWindow -Wait
    if ($DebugMode) { Write-Verbose ("=> exit " + $p.ExitCode) }
    $p.ExitCode
}

function Get-OutputModeCandidates([string]$Output) {
    $lines = Get-XrandrLines
    $in = $false
    $cands = New-Object 'System.Collections.Generic.List[object]'
    foreach ($ln in $lines) {
        if (-not $in) {
            if ($ln -match "^\s*$([Regex]::Escape($Output))\s+connected") { $in = $true; continue }
        } else {
            if ($ln -match '^\S+\s+(connected|disconnected)') { break }
            if ($ln -match '^\s+((\d{3,5}x\d{3,5})(i)?\S*)\s+(.+)$') {
                $token = $Matches[1]
                $res   = $Matches[2]
                $rest  = $Matches[4]
                $w = [int]($res -split 'x')[0]
                $h = [int]($res -split 'x')[1]
                $cands.Add([pscustomobject]@{ Output=$Output; ModeToken=$token; W=$w; H=$h; Rate=$null; Label="$token@default"; Prefer=$false; Current=$false }) | Out-Null
                $mAll = [regex]::Matches($rest, '(\d+(?:\.\d+)?)([*+]{0,2})')
                foreach ($m in $mAll) {
                    $hz = $m.Groups[1].Value
                    if ([string]::IsNullOrWhiteSpace($hz)) { continue }
                    $flags = $m.Groups[2].Value
                    $prefer = $false; $current = $false
                    if ($flags -match '\+') { $prefer = $true }
                    if ($flags -match '\*') { $current = $true }
                    $cands.Add([pscustomobject]@{ Output=$Output; ModeToken=$token; W=$w; H=$h; Rate=[double]$hz; Label="$token@$hz"; Prefer=$prefer; Current=$current }) | Out-Null
                }
            }
        }
    }
    if ($cands.Count -eq 0) { throw "No modes parsed for $Output" }
    $seen = @{}
    $uniq = New-Object 'System.Collections.Generic.List[object]'
    foreach ($c in $cands) { if (-not $seen.ContainsKey($c.Label)) { $seen[$c.Label] = $true; $uniq.Add($c) | Out-Null } }
    $sorted = $uniq | Sort-Object -Property @{Expression={ $_.W * $_.H }; Descending=$true}, @{Expression={ if ($_.Prefer) {1} else {0} }; Descending=$true}, @{Expression={ if ($_.Rate -ne $null) { [double]$_.Rate } else { -1 } }; Descending=$true}, @{Expression={$_.Label}; Descending=$false}
    return ,$sorted
}

# --------------- CVT modelines (RB enabled by default) ---------------
function New-CvtModeline([int]$W,[int]$H,[double]$R,[switch]$ReducedBlanking=$true) {
    if (-not (Test-Cmd 'cvt')) { throw 'cvt not available to generate modeline.' }
    $args = @($W, $H, ('{0:0.##}' -f $R))
    if ($ReducedBlanking) { $args += '-r' }
    $out = (& cvt @args 2>$null) -split "`n"
    $ln = ($out | Where-Object { $_ -match '^Modeline\s+"' } | Select-Object -First 1)
    if (-not $ln) { throw "cvt failed for ${W}x${H}@${R}" }
    $m = [regex]::Match($ln, '^Modeline\s+"([^"]+)"\s+(.+)$')
    if (-not $m.Success) { throw 'Unexpected cvt output format.' }
    [pscustomobject]@{ Name=$m.Groups[1].Value; Params=$m.Groups[2].Value }
}

function Add-ModeToOutput([string]$Output,[string]$Name,[string]$Params) {
    $paramsArr = @(); if ($Params) { $paramsArr = $Params -split '\s+' }
    $ec1 = Invoke-Xrandr (@('--newmode', $Name) + $paramsArr)
    if ($ec1 -ne 0) { Write-Warning "xrandr --newmode failed for '$Name' (maybe exists)." }
    $ec2 = Invoke-Xrandr @('--addmode', $Output, $Name)
    if ($ec2 -ne 0) { Write-Warning "xrandr --addmode $Output '$Name' failed." }
    return ($ec1 -eq 0 -or $ec2 -eq 0)
}

$COMMON_RESOLUTIONS = @('640x480','800x600','1024x768','1152x864','1280x720','1280x768','1280x800','1280x960','1280x1024','1360x768','1366x768','1400x1050','1440x900','1536x864','1600x900','1600x1200','1680x1050','1920x1080','1920x1200','2048x1080','2048x1152','2560x1080','2560x1440','2560x1600','3440x1440','3840x1080','3840x1600','3840x2160','4096x2160','5120x1440','5120x2160','5120x2880','7680x4320')

function Seed-CommonCvtModes([string]$Output,[double]$Hz=60.0,[switch]$ReducedBlanking=$true) {
    try { $cands = Get-OutputModeCandidates $Output } catch { $cands = @() }
    $have = @{}
    foreach ($c in $cands) { $have["$($c.W)x$($c.H)"] = $true }
    foreach ($res in $COMMON_RESOLUTIONS) {
        if ($have.ContainsKey($res)) { continue }
        $w = [int]($res -split 'x')[0]
        $h = [int]($res -split 'x')[1]
        try {
            $mdl = New-CvtModeline -W $w -H $h -R $Hz -ReducedBlanking:$ReducedBlanking
            if (Add-ModeToOutput -Output $Output -Name $mdl.Name -Params $mdl.Params) { Write-Verbose "Seeded $($mdl.Name) to $Output" }
        } catch { Write-Verbose "Seed skip ${res}@${Hz}: $($_.Exception.Message)" }
    }
}

# --------------- Apply & verify ---------------
function Apply-LayoutCandidates([System.Collections.Specialized.OrderedDictionary]$Map) {
    $x = 0
    foreach ($o in $Map.Keys) {
        $cand = $Map[$o]
        if (-not $cand) { continue }
        $tok  = [string]$cand.ModeToken
        $rate = $cand.Rate
        $args1 = @('--output', $o, '--mode', $tok, '--pos', ("{0}x0" -f $x), '--rotate', 'normal')
        $ok = (Invoke-Xrandr $args1) -eq 0
        if (-not $ok -and $rate -ne $null) {
            $hzStr = ("{0:0.##}" -f [double]$rate)
            $args2 = @('--output', $o, '--mode', $tok, '--rate', $hzStr, '--pos', ("{0}x0" -f $x), '--rotate', 'normal')
            $ok = (Invoke-Xrandr $args2) -eq 0
        }
        if (-not $ok) { Write-Warning ("xrandr failed for {0} token {1} rate {2}" -f $o, $tok, ($rate ?? 'default')); return $false }
        Start-Sleep -Milliseconds 120
        $x += ([int]$cand.W)
    }
    Start-Sleep -Milliseconds 180
    return $true
}

function Verify-OutputGeometry([string]$Output, [int]$WantW, [int]$WantH) {
    for ($i=0; $i -lt 5; $i++) {
        $cur = Get-CurrentGeometry $Output
        if ($cur) {
            $ok = ($cur.W -eq $WantW -and $cur.H -eq $WantH)
            if ($DebugMode) { Write-Verbose ("Verify[{0}] try={1} current={2}x{3} vs want={4}x{5} => {6}" -f $Output, $i+1, $cur.W, $cur.H, $WantW, $WantH, $ok) }
            if ($ok) { return $true }
        }
        Start-Sleep -Milliseconds 120
    }
    return $false
}

function Show-OverlayTk([int]$W,[int]$H,[int]$X,[int]$Y,[int]$Seconds) {
$py = @'
import sys, tkinter as t
w, h, x, y, sec = map(int, sys.argv[1:6])
root = t.Tk()
root.overrideredirect(1)
root.attributes("-topmost", True)
root.geometry(f"{w}x{h}+{x}+{y}")
t.Frame(root, width=w, height=h, highlightbackground="red", highlightthickness=8).pack()
root.after(sec*1000, root.destroy)
root.mainloop()
'@
    $tmp = [IO.Path]::GetTempFileName() + '.py'
    [IO.File]::WriteAllText($tmp, $py)
    $p = Start-Process -FilePath 'python3' -ArgumentList @($tmp, $W, $H, $X, $Y, $Seconds) -PassThru -NoNewWindow
    $timeout = [Math]::Max($Seconds + 3, 8)
    $exited = $true
    try { Wait-Process -Id $p.Id -Timeout $timeout } catch { $exited = $false }
    if (-not $exited) { try { Stop-Process -Id $p.Id -Force -ErrorAction SilentlyContinue } catch {}; Write-Warning 'Overlay timeout; killed.' }
    try { Remove-Item $tmp -Force -ErrorAction SilentlyContinue } catch {}
}

# --------------- Autorandr ---------------
function Ensure-Autorandr { if (-not (Test-Cmd 'autorandr')) { Ensure-DepMapped 'autorandr' @{ apt='autorandr'; dnf='autorandr'; zypper='autorandr'; pacman='autorandr' } 'autorandr' } }

function Autorandr-Apply([string]$Profile) {
    $clean = Sanitize-ProfileName $Profile
    if (-not $clean) { throw 'Invalid autorandr profile name.' }
    Ensure-Autorandr
    $p = Start-Process -FilePath 'autorandr' -ArgumentList @('--change', $clean) -PassThru -NoNewWindow -Wait
    if ($p.ExitCode -ne 0) { throw "autorandr --change $clean exited $($p.ExitCode)" }
}

function Autorandr-Save([string]$Profile) {
    $clean = Sanitize-ProfileName $Profile
    if (-not $clean) { throw 'Invalid autorandr profile name.' }
    Ensure-Autorandr
    $p = Start-Process -FilePath 'autorandr' -ArgumentList @('--save', $clean) -PassThru -NoNewWindow -Wait
    if ($p.ExitCode -ne 0) { throw "autorandr --save $clean exited $($p.ExitCode)" }
    return $clean
}

function Autorandr-EnableServices {
    try { & systemctl --user enable --now autorandr.service 2>$null | Out-Null } catch {}
    try { & systemctl --user enable --now autorandr-resume.service 2>$null | Out-Null } catch {}
    if (Test-IsRoot) {
        try { & systemctl enable --now autorandr.service 2>$null | Out-Null } catch {}
        try { & systemctl enable --now autorandr-resume.service 2>$null | Out-Null } catch {}
    }
}

# --------------- DPI helpers ---------------
function Get-XrandrVerbose { (& xrandr --verbose | Out-String) -split "`n" }
function Get-PrimaryOutputName { (Get-XrandrLines | Where-Object { $_ -match '^\s*(\S+)\s+connected\s+primary' } | ForEach-Object { $Matches[1] } | Select-Object -First 1) }
function Get-ConnectedOutputsVerbose { $outs = @(); $lines = Get-XrandrLines; foreach ($ln in $lines) { if ($ln -match '^\s*(\S+)\s+connected') { $outs += $Matches[1] } }; $outs }
function Get-OutputMm([string]$Output) {
    $lines = Get-XrandrVerbose
    $start = -1
    for ($i=0; $i -lt $lines.Count; $i++) { if ($lines[$i] -match "^\s*$([regex]::Escape($Output))\s+connected") { $start = $i; break } }
    if ($start -lt 0) { return $null }
    for ($j=$start; $j -lt [Math]::Min($start+6, $lines.Count); $j++) { if ($lines[$j] -match '(\d+)mm\s+x\s+(\d+)mm') { return [pscustomobject]@{Wmm=[int]$Matches[1]; Hmm=[int]$Matches[2]} }
    return $null
}
function Compute-DPI([string]$Method) {
    $outs = Get-ConnectedOutputsVerbose
    if (-not $outs -or $outs.Count -eq 0) { throw 'No connected outputs for DPI.' }
    $pairs = @()
    foreach ($o in $outs) {
        $geo = Get-CurrentGeometry $o
        $mm  = Get-OutputMm $o
        if ($geo -and $mm -and $mm.Wmm -gt 0 -and $mm.Hmm -gt 0) { $pairs += [pscustomobject]@{O=$o; W=$geo.W; H=$geo.H; Wmm=$mm.Wmm; Hmm=$mm.Hmm} }
    }
    if ($pairs.Count -eq 0) { throw 'No complete geometry/mm data for DPI.' }
    if ($Method -eq 'primary') {
        $p = Get-PrimaryOutputName; if (-not $p) { $p = $pairs[0].O }
        $t = $pairs | Where-Object { $_.O -eq $p } | Select-Object -First 1; if (-not $t) { $t = $pairs[0] }
        $dpiH = ($t.W) / ($t.Wmm / 25.4); $dpiV = ($t.H) / ($t.Hmm / 25.4)
        [Math]::Round((($dpiH + $dpiV)/2),0)
    } else {
        $dpiList = @(); foreach ($t in $pairs) { $dpiH = ($t.W) / ($t.Wmm / 25.4); $dpiV = ($t.H) / ($t.Hmm / 25.4); $dpiList += (($dpiH + $dpiV)/2) }
        [Math]::Round(($dpiList | Measure-Object -Average).Average,0)
    }
}
function Set-DPI([string]$Method) { $dpi = Compute-DPI $Method; $ec = Invoke-Xrandr @('--dpi', [string]$dpi); if ($ec -ne 0) { throw "xrandr --dpi $dpi failed." }; $dpi }

# --------------- Diagnostics ---------------
function Collect-Display-Diagnostics([string]$OutDir) {
    try {
        if (-not (Test-Path $OutDir)) { New-Item -ItemType Directory -Path $OutDir -Force | Out-Null }
        (Get-XrandrVerbose) | Set-Content -Path (Join-Path $OutDir 'xrandr_verbose.log') -Encoding UTF8
        if (Test-Cmd 'edid-decode') {
            Get-ChildItem -Path '/sys/class/drm' -Recurse -Filter edid -ErrorAction SilentlyContinue | ForEach-Object {
                $p = $_.FullName
                try { $bytes = [IO.File]::ReadAllBytes($p); $tmp = [IO.Path]::GetTempFileName(); [IO.File]::WriteAllBytes($tmp, $bytes); & edid-decode $tmp > (Join-Path $OutDir ("edid-" + ($_.Directory.Name) + ".txt")) 2>$null; Remove-Item $tmp -Force -ErrorAction SilentlyContinue } catch {}
            }
        }
        if (Test-Cmd 'ddcutil') { try { & ddcutil detect --verbose > (Join-Path $OutDir 'ddcutil_detect.log') 2>$null } catch {} }
    } catch { Write-Warning "Diagnostics collection issue: $($_.Exception.Message)" }
}

# --------------- Early command paths ---------------
if ($ApplySavedLayout) {
    if (-not (Test-Path $ConfigPath)) { Write-Warning "Config not found: $ConfigPath"; Stop-TranscriptSafe; exit 23 }
    try { $raw = Get-Content -Raw -Path $ConfigPath; $obj = $raw | ConvertFrom-Json } catch { Write-Error "Failed to parse config JSON: $($_.Exception.Message)"; Stop-TranscriptSafe; exit 24 }
    if (-not $obj) { Write-Error 'Empty/invalid configuration object.'; Stop-TranscriptSafe; exit 22 }

    $orderedChosen = [System.Collections.Specialized.OrderedDictionary]::new()
    foreach ($p in $obj.PSObject.Properties) {
        $val = $p.Value
        if ($val -is [string]) {
            $w = [int](($val -replace 'i$','') -split 'x')[0]
            $h = [int](($val -replace 'i$','') -split 'x')[1]
            $orderedChosen[$p.Name] = [pscustomobject]@{ Output=$p.Name; ModeToken=$val; W=$w; H=$h; Rate=$null; Label="$val@default"; Prefer=$false; Current=$false }
        } else {
            $mode = [string]$val.mode; $rate = $null; if ($val.PSObject.Properties.Name -contains 'rate' -and $val.rate -ne $null) { $rate = [double]$val.rate }
            $w = [int](($mode -replace 'i$','') -split 'x')[0]; $h = [int](($mode -replace 'i$','') -split 'x')[1]
            $orderedChosen[$p.Name] = [pscustomobject]@{ Output=$p.Name; ModeToken=$mode; W=$w; H=$h; Rate=$rate; Label=$(if ($rate -ne $null) { "$mode@$rate" } else { "$mode@default" }); Prefer=$false; Current=$false }
        }
    }
    if ($orderedChosen.Count -eq 0) { Write-Error 'No entries in configuration.'; Stop-TranscriptSafe; exit 22 }
    if (-not (Apply-LayoutCandidates $orderedChosen)) { Write-Warning 'Applying saved layout reported errors.'; Stop-TranscriptSafe; exit 1 }

    $primary = $null; $maxA = -1
    foreach ($o in $orderedChosen.Keys) { $a  = [int]$orderedChosen[$o].W * [int]$orderedChosen[$o].H; if ($a -gt $maxA) { $primary = $o; $maxA = $a } }
    if ($primary) { $null = Invoke-Xrandr @('--output', $primary, '--primary') }

    $dpiApplied = $null
    if ($SetDPI) { try { $dpiApplied = Set-DPI $DPIMethod } catch { Write-Warning $_.Exception.Message } }

    $diagDir = $null
    if ($CollectDisplayInfo) { $diagDir = Join-Path $homeTarget ("monitor-info-" + (Get-Date -Format 'yyyyMMdd-HHmmss')); Collect-Display-Diagnostics $diagDir; Write-Host "[INFO] Diagnostics saved at $diagDir" -ForegroundColor DarkCyan }

    $chosenLabels = @{}; foreach ($k in $orderedChosen.Keys) { $chosenLabels[$k] = [string]$orderedChosen[$k].Label }
    $summary = [pscustomobject]@{ ok=$true; mode='apply-saved'; primary=$primary; order=@($orderedChosen.Keys); chosen=$chosenLabels; configFile=$ConfigPath; dpi=$dpiApplied; diagDir=$diagDir } | ConvertTo-Json -Compress
    Write-Output $summary
    Stop-TranscriptSafe; exit 0
}

if ($SetDPI -and -not $PSBoundParameters.ContainsKey('AutorandrProfileName') -and -not $PSBoundParameters.ContainsKey('ApplyAutorandrProfile')) {
    try { $dpiVal = Set-DPI $DPIMethod; [pscustomobject]@{ ok=$true; mode='dpi-only'; dpi=$dpiVal } | ConvertTo-Json -Compress | Write-Output } catch { Write-Error $_.Exception.Message; Stop-TranscriptSafe; exit 1 }
    Stop-TranscriptSafe; exit 0
}

# --------------- Interactive flow ---------------
$outs = Get-ConnectedOutputs
if (-not $outs -or $outs.Count -eq 0) { Write-Error 'No connected monitors detected.'; Stop-TranscriptSafe; exit 21 }

foreach ($o in $outs) { try { Seed-CommonCvtModes -Output $o -Hz 60.0 -ReducedBlanking:(!$NoReducedBlanking) } catch { Write-Verbose "Seed-CommonCvtModes failed for $o: $($_.Exception.Message)" } }

$orderedOuts = New-Object 'System.Collections.Generic.List[string]'
if ($outs.Count -gt 1) {
    $remaining = New-Object 'System.Collections.Generic.List[string]'; $remaining.AddRange([string[]]$outs)
    Write-Host "Multiple monitors detected: $($remaining -join ', ')" -ForegroundColor Cyan
    while ($remaining.Count -gt 0) {
        if ($orderedOuts.Count -eq 0) { Write-Host "Which monitor should be on the far left?" } else { Write-Host "Which monitor should be to the right of $($orderedOuts[-1])?" }
        for ($i=0; $i -lt $remaining.Count; $i++) { Write-Host "  [$($i+1)] $($remaining[$i])" }
        $ans = Read-Host "Enter number (1-$($remaining.Count))"
        if (($ans -match '^\d+$') -and ([int]$ans -ge 1) -and ([int]$ans -le $remaining.Count)) { $choiceIndex = [int]$ans - 1; $orderedOuts.Add($remaining[$choiceIndex]) | Out-Null; $remaining.RemoveAt($choiceIndex) } else { Write-Warning "Invalid selection." }
    }
} else { $orderedOuts.Add($outs[0]) | Out-Null }
Write-Host "Final monitor order (left-to-right): $($orderedOuts -join ' -> ')" -ForegroundColor Green

$All = @{}
foreach ($o in $orderedOuts) {
    try { $All[$o] = Get-OutputModeCandidates $o; if ($DebugMode) { Write-Verbose ("Candidates[{0}] (#{1})" -f $o, $All[$o].Count) } } catch { Write-Warning "Failed to parse modes for $($o): $($_.Exception.Message)"; $All[$o] = @() }
}

$Chosen = [System.Collections.Specialized.OrderedDictionary]::new(); foreach ($o in $orderedOuts) { $Chosen[$o] = $null }

foreach ($current in $orderedOuts) {
    Write-Host ("======== Select mode for {0} ========" -f $current) -ForegroundColor Cyan
    $cands = @($All[$current])
    if (-not $cands -or $cands.Count -eq 0) { Write-Warning "No candidates for $current; skipping."; continue }
    for ($i = 0; $i -lt $cands.Count; $i++) { $tag = @(); if ($cands[$i].Prefer) { $tag += 'preferred' }; if ($cands[$i].Current) { $tag += 'current' }; $tagStr = if ($tag.Count -gt 0) { " [" + ($tag -join ',') + "]" } else { "" }; Write-Host ("  [{0}] {1}  ({2}x{3}){4}" -f ($i+1), $cands[$i].Label, $cands[$i].W, $cands[$i].H, $tagStr) }
    Write-Host "Type an index to PREVIEW that mode, then confirm; 'l' to re-list; 'q' to abort." -ForegroundColor Yellow

    $selected = $false
    while (-not $selected) {
        $ans = Read-Host "Enter index (1-$($cands.Count)) / l / q"
        if ($ans -match '^(?i)q$') { Write-Warning 'User aborted.'; Stop-TranscriptSafe; exit 1 }
        if ($ans -match '^(?i)l$') { for ($i = 0; $i -lt $cands.Count; $i++) { $tag = @(); if ($cands[$i].Prefer) { $tag += 'preferred' }; if ($cands[$i].Current) { $tag += 'current' }; $tagStr = if ($tag.Count -gt 0) { " [" + ($tag -join ',') + "]" } else { "" }; Write-Host ("  [{0}] {1}  ({2}x{3}){4}" -f ($i+1), $cands[$i].Label, $cands[$i].W, $cands[$i].H, $tagStr) }; continue }
        if ($ans -notmatch '^\d+$') { Write-Warning "Please enter a valid index."; continue }
        $idx = [int]$ans; if ($idx -lt 1 -or $idx -gt $cands.Count) { Write-Warning "Out of range."; continue }
        $cand = $cands[$idx-1]
        $proposal = [System.Collections.Specialized.OrderedDictionary]::new()
        foreach ($o in $orderedOuts) { if ($o -eq $current) { $proposal[$o] = $cand } else { if ($Chosen[$o]) { $proposal[$o] = $Chosen[$o] } else { $proposal[$o] = $All[$o][0] } } }
        if (-not (Apply-LayoutCandidates $proposal)) { Write-Warning "xrandr apply failed for $($cand.Label)"; continue }
        if (-not (Verify-OutputGeometry $current $cand.W $cand.H)) { Write-Warning "Geometry mismatch after apply."; continue }
        $xoff = 0; foreach ($o in $orderedOuts) { if ($o -eq $current) { break }; $prev = $proposal[$o]; $xoff += [int]$prev.W }
        Show-OverlayTk -W $cand.W -H $cand.H -X $xoff -Y 0 -Seconds $OverlaySeconds
        $yn = Read-Host ("Use {0} for {1}? [y/n/q]" -f $cand.Label, $current)
        if     ($yn -match '^(?i)y$') { $Chosen[$current] = $cand; $selected = $true }
        elseif ($yn -match '^(?i)q$') { Write-Warning 'User aborted.'; Stop-TranscriptSafe; exit 1 }
        else { Write-Host "Pick another index." -ForegroundColor Yellow }
    }
}

Write-Host "Final configuration selected. Applying..." -ForegroundColor Cyan
if (-not (Apply-LayoutCandidates $Chosen)) { Write-Warning 'Final layout application reported errors.'; Stop-TranscriptSafe; exit 1 }

$primary = $null; $maxA = -1
foreach ($o in $orderedOuts) { $sel = $Chosen[$o]; if ($sel -eq $null) { continue }; $a  = [int]$sel.W * [int]$sel.H; if ($a -gt $maxA) { $primary = $o; $maxA = $a } }
if ($primary) { $null = Invoke-Xrandr @('--output', $primary, '--primary') }

# Save config + autostart
try {
    $configDir = Split-Path -Parent $ConfigPath
    if (-not (Test-Path $configDir)) { if ($root) { & sudo -u $TargetUser mkdir -p -- $configDir } else { New-Item -ItemType Directory -Path $configDir -Force | Out-Null } }

    $persist = [ordered]@{}
    foreach ($k in $Chosen.Keys) { $v = $Chosen[$k]; if ($v -ne $null) { $persist[$k] = [ordered]@{ mode = [string]$v.ModeToken; rate = $(if ($v.Rate -ne $null) { [double]$v.Rate } else { $null }) } } }
    ($persist | ConvertTo-Json) | Set-Content -Path $ConfigPath -Encoding UTF8
    if ($root) { & chown "${TargetUser}:${TargetUser}" $ConfigPath }
    Write-Host "[INFO] Configuration saved to $ConfigPath" -ForegroundColor DarkCyan

    $autoDir = Join-Path $homeTarget '.config/autostart'
    if (-not (Test-Path $autoDir)) { if ($root) { & sudo -u $TargetUser mkdir -p -- $autoDir } else { New-Item -ItemType Directory -Path $autoDir -Force | Out-Null } }
    if (-not (Test-Path $ScriptInstallPath)) { $src = $PSCommandPath; if (-not $src) { $src = $MyInvocation.MyCommand.Path }; Copy-Item -Path $src -Destination $ScriptInstallPath -Force; if ($root) { & chown "${TargetUser}:${TargetUser}" $ScriptInstallPath }; & chmod +x $ScriptInstallPath }
    $desktopFile = Join-Path $autoDir 'pwsh_monitor_setup.desktop'
    $execLine = "pwsh -File $ScriptInstallPath -ApplySavedLayout -ConfigPath `"$ConfigPath`""
@"
[Desktop Entry]
Type=Application
Exec=$execLine
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Name=PwshAutoMonitor
Comment=Autoconfigure monitors layout (pwsh)
"@ | Set-Content -Path $desktopFile -Encoding UTF8 -NoNewline
    if ($root) { & chown "${TargetUser}:${TargetUser}" $desktopFile }
    & chmod 0644 $desktopFile
    Write-Host ("[INFO] Autostart installed at {0} for user {1}" -f $desktopFile, $TargetUser) -ForegroundColor DarkCyan
} catch { Write-Warning ("Autostart/config setup issue: {0}" -f $_.Exception.Message) }

if ($EnableAutorandr) { try { Autorandr-EnableServices; Write-Host '[INFO] Attempted to enable autorandr services.' -ForegroundColor DarkCyan } catch { Write-Warning "autorandr service enable: $($_.Exception.Message)" } }

$autorandrSaved = $null
if ($PSBoundParameters.ContainsKey('AutorandrProfileName') -and $AutorandrProfileNameSan) {
    try { $autorandrSaved = Autorandr-Save -Profile $AutorandrProfileNameSan; Write-Host ("[INFO] Saved autorandr profile: {0}" -f $autorandrSaved) -ForegroundColor DarkCyan } catch { Write-Warning "autorandr save failed: $($_.Exception.Message)" }
}

if ($PSBoundParameters.ContainsKey('ApplyAutorandrProfile') -and $ApplyAutorandrProfileSan) {
    try { Autorandr-Apply -Profile $ApplyAutorandrProfileSan; [pscustomobject]@{ ok=$true; mode='autorandr-apply'; profile=$ApplyAutorandrProfileSan } | ConvertTo-Json -Compress | Write-Output; Stop-TranscriptSafe; exit 0 } catch { Write-Error "Autorandr apply failed: $($_.Exception.Message)"; Stop-TranscriptSafe; exit 26 }
}

$dpiSet = $null
if ($SetDPI) { try { $dpiSet = Set-DPI $DPIMethod } catch { Write-Warning "DPI set failed: $($_.Exception.Message)" } }

$diagDir2 = $null
if ($CollectDisplayInfo) { $diagDir2 = Join-Path $homeTarget ("monitor-info-" + (Get-Date -Format 'yyyyMMdd-HHmmss')); Collect-Display-Diagnostics $diagDir2; Write-Host "[INFO] Diagnostics saved at $diagDir2" -ForegroundColor DarkCyan }

$chosenLabels = @{}; foreach ($k in $Chosen.Keys) { if ($Chosen[$k] -ne $null) { $chosenLabels[$k] = [string]$Chosen[$k].Label } }
$summary2 = [pscustomobject]@{ ok=$true; mode='interactive'; primary=$primary; order=@($orderedOuts); chosen=$chosenLabels; configFile=$ConfigPath; autorandrSaved=$autorandrSaved; dpi=$dpiSet; diagDir=$diagDir2 } | ConvertTo-Json -Compress
Write-Output $summary2

Stop-TranscriptSafe
exit 0
```

</integrated_code>

<documentation>
Scope and rationale:
- Added refresh-aware parsing and application to resolve cases where identical WxH require explicit Hz selection.
- Introduced CVT seeding with Reduced Blanking default to expand candidate space for panels that do not advertise desired modes.
- Prefer listactivemonitors for geometry to avoid parsing brittleness; kept robust fallback.
- Extended persistence to {mode,rate} while reading legacy strings unchanged; summaries emit label strings for easy machine read.
- Added autorandr integration for profile-based switching; profile names sanitized to prevent shell arg injection; failures isolated (exit 26).
- Added DPI computation/setting using physical mm; optional and reported back in summary.
- Added diagnostics collection to aid support and reproducibility.
- Hardened dependency installation with distro-aware packages; optional tools are best-effort only.
- Security improvements: PositionalBinding=$false; unknown-arg rejection; sanitized profile names; strict quoting in .desktop Exec; least-privilege chown only when root; transcripts go to /tmp with fallback to $HOME.

Performance:

* Rate-aware application eliminates repeated failed xrandr calls; verification with retry reduces flakiness.
* Seeding only missing WxH avoids redundant modes; single pass per output.
* OrderedDictionary preserves monitor order deterministically.

Testing checklist:

* Help prints sections and exit codes.
* ApplySavedLayout: missing file → 23; malformed JSON → 24; empty object → 22; success emits required keys.
* Legacy config string path loads and applies.
* Interactive path emits chosen, order, primary; overlay invoked.
* Autorandr: invalid name → 26; sanitized names accept dots/underscores/hyphens only.
* DPI-only path outputs {ok,mode='dpi-only',dpi}.
* Headless: unset/bad DISPLAY → 20.

Backward compatibility:

* Existing JSON mapping continues to work; new writes use {mode,rate} objects.
* Exit codes preserved; autostart file name standardized but prior file is still honored if ScriptInstallPath already exists.

  </documentation>

```

~~~bash
#!/bin/bash
set -euo pipefail

# ============================================================================
# RK3588 (ARM64) • Debian 11 (Bullseye)
# Dual‑monitor automation: xrandr + autorandr, with robust 640x480 fallback
#
# Target layout from logs:
#   - HDMI-1  → 800x600 @ 60 Hz  (primary)
#   - DP-1    → 640x480 @ 60 Hz  (to the right of HDMI-1)
#
# What this script does (idempotent where feasible):
#   1) Verifies we are inside an X session (DISPLAY set) and outputs are connected.
#   2) Ensures packages: x11-xserver-utils (xrandr), autorandr. (bc optional)
#   3) Defines modelines for HDMI-1 (800x600_60.00 CVT) and DP-1 (640x480 CVT & VGA).
#   4) Adds modes to outputs; applies layout. If CVT 640x480 fails, tries classic VGA 25.175 MHz.
#   5) Creates/updates an autorandr profile with a static **preswitch** hook that always redefines
#      the modelines before profile application.
#   6) Installs a user systemd unit to apply autorandr at login; optionally adds a ratpoison line
#      and/or XDG autostart desktop file.
#   7) Offers (with explicit confirmation) to write a persistent Xorg snippet under /etc/X11.
#
# Run: save as ~/rk3588_dual_display_setup.sh, then: bash ~/rk3588_dual_display_setup.sh
# ============================================================================

# ---- Configurable knobs (override via env) -------------------------------
OUT1="${OUT1:-HDMI-1}"
OUT2="${OUT2:-DP-1}"

# 800x600 CVT for HDMI-1 (from logs)
MODE1_NAME="${MODE1_NAME:-800x600_60.00}"
MODE1_LINE="${MODE1_LINE:-38.25  800 832 912 1024  600 603 607 624 -hsync +vsync}"

# 640x480 CVT and VGA fallbacks for DP-1 (DP→VGA bridges may prefer VGA timing)
MODE2_CVT_NAME="${MODE2_CVT_NAME:-640x480_60.00}"
MODE2_CVT_LINE="${MODE2_CVT_LINE:-23.75  640 664 720 800  480 483 487 500 -hsync +vsync}"
MODE2_VGA_NAME="${MODE2_VGA_NAME:-640x480_60_std}"
MODE2_VGA_LINE="${MODE2_VGA_LINE:-25.175 640 656 752 800 480 490 492 525 -hsync -vsync}"

# Autorandr profile name we manage
AR_PROFILE="${AR_PROFILE:-rk3588_dual}"  # stored under ~/.config/autorandr/$AR_PROFILE

# Optional autostart helpers
ENABLE_SYSTEMD_USER="${ENABLE_SYSTEMD_USER:-1}"
ENABLE_RATPOISON_RC="${ENABLE_RATPOISON_RC:-1}"
ENABLE_XDG_AUTOSTART="${ENABLE_XDG_AUTOSTART:-0}"

# ----------------------------------------------------------------------------
# Helpers
log()  { printf '[INFO ] %s\n' "$*"; }
warn() { printf '[WARN ] %s\n' "$*" >&2; }
err()  { printf '[ERROR] %s\n' "$*" >&2; }

run() {
  # Wrapper that surfaces failures clearly
  if ! "$@"; then err "Command failed: $*"; return 1; fi
}

require_cmd() {
  local c="$1"; local hint="${2:-}";
  command -v "$c" >/dev/null 2>&1 || { err "Missing command '$c'${hint:+ (install: $hint)}"; exit 127; }
}

apt_update_once() {
  if [ ! -f "$HOME/.cache/.rk3588_dual_apt_updated" ]; then
    mkdir -p "$HOME/.cache" || { err "Cannot create cache dir"; exit 1; }
    log "sudo apt update …"
    if ! sudo apt update; then err "'apt update' failed"; exit 1; fi
    : >"$HOME/.cache/.rk3588_dual_apt_updated"
  fi
}

ensure_pkg() {
  local pkg="$1";
  if dpkg -s "$pkg" >/dev/null 2>&1; then
    log "Package '$pkg' already installed."
  else
    apt_update_once
    log "Installing '$pkg' …"
    if ! sudo apt install -y "$pkg"; then err "Failed to install '$pkg'"; exit 1; fi
  fi
}

# Extract active WxH for an output
active_wh() {
  local out="$1"; xrandr --query | awk -v o="$out" '$1==o && $2=="connected" { if (match($0,/[0-9]+x[0-9]+\+/,m)) {s=substr($0,RSTART,RLENGTH); sub(/\+.*/,"",s); print s} }'
}

output_connected() { xrandr | grep -q "^${1}[[:space:]]\+connected"; }

mode_defined() { xrandr --query | awk '{print $1}' | grep -Fxq "$1"; }

add_mode_to_output() {
  local out="$1" name="$2";
  # If mode already listed under output, skip
  if xrandr --query | awk -v o="$out" '$1==o {on=1;next} on&&NF==0{on=0} on{print $1}' | sed 's/^\s*//' | grep -Fxq "$name"; then
    return 0
  fi
  xrandr --addmode "$out" "$name" 2>/dev/null || true
}

# ----------------------------------------------------------------------------
# Preconditions
require_cmd xrandr x11-xserver-utils
require_cmd awk
require_cmd sed
require_cmd grep

if [[ -z "${DISPLAY:-}" ]]; then err "DISPLAY is not set; run inside an X session."; exit 1; fi

# Packages
ensure_pkg x11-xserver-utils
ensure_pkg autorandr
# bc is optional; install but do not fail the whole script if it errors
if ! dpkg -s bc >/dev/null 2>&1; then
  if ! (apt_update_once && sudo apt install -y bc); then warn "'bc' install failed; continuing without it."; fi
fi

# Sanity: outputs connected
if ! output_connected "$OUT1"; then err "$OUT1 not reported as connected by xrandr"; exit 1; fi
if ! output_connected "$OUT2"; then err "$OUT2 not reported as connected by xrandr"; exit 1; fi

# ----------------------------------------------------------------------------
# Define modelines (idempotent)
if ! mode_defined "$MODE1_NAME"; then
  log "Defining $MODE1_NAME"
  run xrandr --newmode "$MODE1_NAME" $MODE1_LINE || true
fi
if ! mode_defined "$MODE2_CVT_NAME"; then
  log "Defining $MODE2_CVT_NAME (CVT)"
  run xrandr --newmode "$MODE2_CVT_NAME" $MODE2_CVT_LINE || true
fi
if ! mode_defined "$MODE2_VGA_NAME"; then
  log "Defining $MODE2_VGA_NAME (VGA)"
  run xrandr --newmode "$MODE2_VGA_NAME" $MODE2_VGA_LINE || true
fi

# Attach modes to outputs
add_mode_to_output "$OUT1" "$MODE1_NAME"
add_mode_to_output "$OUT2" "$MODE2_CVT_NAME"
add_mode_to_output "$OUT2" "$MODE2_VGA_NAME"

# Try CVT layout, then fallback to VGA timing if needed
apply_layout() {
  local right_name="$1"; log "Applying layout: $OUT1=$MODE1_NAME (primary), $OUT2=${right_name} (right)"
  xrandr \
    --output "$OUT1" --mode "$MODE1_NAME" --primary \
    --output "$OUT2" --mode "$right_name" --right-of "$OUT1"
}

if ! apply_layout "$MODE2_CVT_NAME"; then
  warn "CVT 640x480 failed; trying classic VGA 25.175 MHz timing."
  if ! apply_layout "$MODE2_VGA_NAME"; then
    err "Failed to apply layout even with VGA fallback."
    exit 1
  fi
fi

# Verify only WxH (rate label may differ)
wh1=$(active_wh "$OUT1"); wh2=$(active_wh "$OUT2")
if [[ "$wh1" != "800x600" ]]; then err "$OUT1 geometry is '$wh1' (expected 800x600)"; exit 1; fi
if [[ "$wh2" != "640x480" ]]; then err "$OUT2 geometry is '$wh2' (expected 640x480)"; exit 1; fi
log "Layout OK: $OUT1=$wh1 primary, $OUT2=$wh2 right-of $OUT1"

# ----------------------------------------------------------------------------
# Autorandr profile + preswitch hook (static content)
AR_DIR="$HOME/.config/autorandr/$AR_PROFILE"
PRESH="$AR_DIR/preswitch"

# Save/refresh profile directory
if [ -d "$AR_DIR" ] && [ -n "$(ls -A "$AR_DIR" 2>/dev/null || true)" ]; then
  ts=$(date +%Y%m%d-%H%M%S)
  warn "Profile '$AR_PROFILE' exists. Backing up to ${AR_DIR}.bak.${ts}"
  run mv "$AR_DIR" "${AR_DIR}.bak.${ts}"
fi
run mkdir -p "$AR_DIR"

# Preswitch: define both modelines and add them to outputs every apply
cat >"$PRESH" <<'SH'
#!/bin/sh
set -eu
# Ensure modelines exist (ignore errors if already present)
xrandr --newmode "800x600_60.00" 38.25  800 832 912 1024  600 603 607 624 -hsync +vsync 2>/dev/null || true
xrandr --newmode "640x480_60.00" 23.75  640 664 720 800  480 483 487 500 -hsync +vsync 2>/dev/null || true
xrandr --newmode "640x480_60_std" 25.175 640 656 752 800 480 490 492 525 -hsync -vsync 2>/dev/null || true
# Attach to outputs
xrandr --addmode HDMI-1 "800x600_60.00" 2>/dev/null || true
xrandr --addmode DP-1   "640x480_60.00" 2>/dev/null || true
xrandr --addmode DP-1   "640x480_60_std" 2>/dev/null || true
SH
run chmod +x "$PRESH"

# Save current layout as profile
log "Saving autorandr profile '$AR_PROFILE'"
if ! autorandr --save "$AR_PROFILE" --force; then err "autorandr --save failed"; exit 1; fi

# Test loading once
log "Testing autorandr apply"
if ! autorandr --load "$AR_PROFILE"; then err "autorandr --load failed"; exit 1; fi

# ----------------------------------------------------------------------------
# Autostart methods
# 1) systemd --user unit
if [[ "$ENABLE_SYSTEMD_USER" == "1" ]]; then
  USR_SD_DIR="$HOME/.config/systemd/user"; USR_SD_UNIT="$USR_SD_DIR/autorandr-login.service"
  run mkdir -p "$USR_SD_DIR"
  cat >"$USR_SD_UNIT" <<'UNIT'
[Unit]
Description=Apply autorandr profile at login (user session)
After=graphical-session.target
Wants=graphical-session.target

[Service]
Type=oneshot
ExecStart=/usr/bin/autorandr --change --default default --match-edid

[Install]
WantedBy=default.target
UNIT
  run systemctl --user daemon-reload
  if ! systemctl --user enable --now autorandr-login.service; then
    warn "systemd --user enable failed; falling back to Ratpoison/XDG if enabled."
  fi
fi

# 2) Ratpoison startup line (appended once)
if [[ "$ENABLE_RATPOISON_RC" == "1" ]]; then
  RP_RC="$HOME/.ratpoisonrc"
  line="exec sh -lc 'sleep 2; autorandr --change --default default --match-edid >/dev/null 2>&1 &'"
  if [ ! -f "$RP_RC" ] || ! grep -Fqx "$line" "$RP_RC"; then
    [ -f "$RP_RC" ] && cp -a "$RP_RC" "${RP_RC}.bak-$(date +%Y%m%d-%H%M%S)"
    printf '%s\n' "$line" >>"$RP_RC" || { err "Failed to append to $RP_RC"; exit 1; }
    log "Ratpoison startup line added to $RP_RC"
  else
    log "Ratpoison startup already configured"
  fi
fi

# 3) XDG autostart desktop (optional)
if [[ "$ENABLE_XDG_AUTOSTART" == "1" ]]; then
  ADIR="$HOME/.config/autostart"; AFILE="$ADIR/autorandr-login.desktop"
  run mkdir -p "$ADIR"
  cat >"$AFILE" <<'DESK'
[Desktop Entry]
Type=Application
Name=autorandr (login)
Exec=autorandr --change --default default --match-edid
X-GNOME-Autostart-enabled=true
NoDisplay=true
DESK
fi

# ----------------------------------------------------------------------------
# Optional persistent Xorg snippet (explicit confirmation)
read -r -p "OPTIONAL: Write /etc/X11/xorg.conf.d/10-monitor.conf with these modelines? (yes/NO): " confirm
if [[ "${confirm:-}" == "yes" ]]; then
  XDIR="/etc/X11/xorg.conf.d"; XFILE="$XDIR/10-monitor.conf"
  log "Writing $XFILE (backup if exists)"
  run sudo mkdir -p "$XDIR"
  if sudo test -f "$XFILE"; then sudo cp -a "$XFILE" "${XFILE}.bak-$(date +%Y%m%d-%H%M%S)" || true; fi
  sudo bash -c "cat > '$XFILE'" <<'XORG'
Section "Monitor"
    Identifier "DP-1"
    Modeline "640x480_60.00"  23.75  640 664 720 800  480 483 487 500 -hsync +vsync
    Modeline "640x480_60_std" 25.175 640 656 752 800  480 490 492 525 -hsync -vsync
    Option   "PreferredMode" "640x480_60.00"
EndSection

Section "Monitor"
    Identifier "HDMI-1"
    Modeline "800x600_60.00"  38.25  800 832 912 1024  600 603 607 624 -hsync +vsync
    Option   "PreferredMode" "800x600_60.00"
EndSection
XORG
  log "Xorg config written. Reboot or restart X to take effect."
else
  log "Skipped persistent Xorg config."
fi

log "All done. You can now log out/in (or reboot). Autorandr should apply the layout automatically."
exit 0
~~~

"""bash
#!/bin/bash
# Xrandr dual-monitor setup (expanded, refactored)
# HDMI-1 → 800x600@60 (primary)
# DP-1   → 640x480@60 (right of HDMI-1)
# Modelines and outputs are fixed based on provided logs. No placeholders.

set -Eeuo pipefail

# --------------------------
# Utilities / Logging
# --------------------------
log()  { printf '[INFO ] %s\n' "$*"; }
warn() { printf '[WARN ] %s\n' "$*" >&2; }
err()  { printf '[ERROR] %s\n' "$*" >&2; }

# If DRY_RUN=1 is set in the environment, print commands instead of executing them.
: "${DRY_RUN:=0}"
run() {
  if [[ "$DRY_RUN" == "1" ]]; then
    printf '[DRYRUN] %s\n' "$*"
    return 0
  fi
  eval "$@"
}

# --------------------------
# Pre-flight checks
# --------------------------
if ! command -v xrandr >/dev/null 2>&1; then
  err 'xrandr not found'
  exit 127
fi

# --------------------------
# Fixed configuration from logs
# --------------------------
OUTPUT_1_NAME="HDMI-1"
MODE_1_NAME="800x600_60.00"
MODELINE_1_PARAMS="38.25  800 832 912 1024  600 603 607 624 -hsync +vsync"

OUTPUT_2_NAME="DP-1"
MODE_2_NAME="640x480_60.00"
MODELINE_2_PARAMS="23.75  640 664 720 800  480 483 487 500 -hsync +vsync"

# --------------------------
# Helpers for xrandr state
# --------------------------
connected() {
  xrandr | grep -q "^$1\s*connected"
}

mode_defined() {
  local name="$1"
  # A mode is "defined" if it appears anywhere in xrandr --query output
  xrandr --query | awk '{print $1}' | grep -Fxq "$name"
}

output_has_mode() {
  local out="$1" name="$2"
  # Extract the block for this output and list the mode names, then search for ours.
  xrandr --query | awk -v o="$out" '
    $1==o {on=1; next}
    on && NF==0 {on=0}
    on && $1!~/^\t/ && $2=="connected" {on=0}
    on {print $1}
  ' | sed 's/^[[:space:]]*//' | grep -Fxq "$name" 2>/dev/null
}

active_geom() {
  # Prints WxH for given output if connected; empty otherwise
  local out="$1"
  xrandr --query | awk -v o="$out" '$1==o && $2=="connected" {
    match($0, /[0-9]+x[0-9]+\+[0-9]+\+[0-9]+/);
    if (RSTART) { s=substr($0,RSTART,RLENGTH); sub(/\+.*/, "", s); print s; }
  }'
}

# --------------------------
# Capture pre-state for reversible changes
# --------------------------
PRESTATE_CMD=()
for out in "$OUTPUT_1_NAME" "$OUTPUT_2_NAME"; do
  if connected "$out"; then
    # Best-effort revert uses preferred mode and auto placement for each output.
    PRESTATE_CMD+=(--output "$out" --auto)
  fi
done

revert() {
  if ((${#PRESTATE_CMD[@]})); then
    warn "Reverting to auto configuration"
    run xrandr "${PRESTATE_CMD[@]}" || warn "Revert failed"
  fi
}

trap 'err "Failure occurred"; revert' ERR

# --------------------------
# Ensure modes exist and are assigned to outputs
# --------------------------
ensure_mode_defined() {
  local name="$1"; shift
  if mode_defined "$name"; then
    log "Mode present: $name"
  else
    log "Defining mode: $name"
    run xrandr --newmode "$name" "$@"
  fi
}

ensure_output_has_mode() {
  local out="$1" name="$2"
  if output_has_mode "$out" "$name"; then
    log "Output $out already has mode $name"
  else
    log "Adding mode $name to $out"
    run xrandr --addmode "$out" "$name"
  fi
}

# Validate outputs are connected before modifying
for out in "$OUTPUT_1_NAME" "$OUTPUT_2_NAME"; do
  if ! connected "$out"; then
    err "Output not connected: $out"
    exit 2
  fi
done

# Define modes idempotently
ensure_mode_defined "$MODE_1_NAME" $MODELINE_1_PARAMS
ensure_mode_defined "$MODE_2_NAME" $MODELINE_2_PARAMS

# Assign modes to each output
ensure_output_has_mode "$OUTPUT_1_NAME" "$MODE_1_NAME"
ensure_output_has_mode "$OUTPUT_2_NAME" "$MODE_2_NAME"

# --------------------------
# Apply requested layout
# --------------------------
LAYOUT_CMD=(
  --output "$OUTPUT_1_NAME" --mode "$MODE_1_NAME" --primary
  --output "$OUTPUT_2_NAME" --mode "$MODE_2_NAME" --right-of "$OUTPUT_1_NAME"
)

log "Applying layout"
run xrandr "${LAYOUT_CMD[@]}"

# --------------------------
# Post-apply verification
# --------------------------
geom1=$(active_geom "$OUTPUT_1_NAME")
geom2=$(active_geom "$OUTPUT_2_NAME")

if [[ "$geom1" != "800x600" ]]; then
  err "Post-check failed: $OUTPUT_1_NAME geometry is '$geom1' (expected 800x600)"
  revert; exit 3
fi
if [[ "$geom2" != "640x480" ]]; then
  err "Post-check failed: $OUTPUT_2_NAME geometry is '$geom2' (expected 640x480)"
  revert; exit 4
fi

log "Configuration successful: $OUTPUT_1_NAME=$geom1 (primary), $OUTPUT_2_NAME=$geom2 (right)"
exit 0

"""

```bash
#!/usr/bin/env bash
#
# debian_display_setup.sh
# A comprehensive script to guide through display setup and management on Debian Bullseye,
# integrating the logic of five specialized scripts.
#
# IMPORTANT USAGE NOTES:
# - Options marked (MUST RUN SCRIPT WITH SUDO) require you to invoke this entire script
#   using 'sudo bash debian_display_setup.sh'.
# - Options marked (RUN IN X SESSION) must be run as your normal user from a terminal
#   emulator within your active graphical desktop session.
# - Options marked (NEEDS ROOT FOR FULL DETAILS) will provide more comprehensive information
#   if the script is run with 'sudo', but may offer limited functionality otherwise.
#

set -euo pipefail

# --- Global Variables ---
MONITOR_INFO_OUTDIR=""
CUSTOM_XRANDR_SCRIPT_PATH="${HOME}/my_custom_display_config.sh" # User's editable script
CONFIG_DIR="${HOME}/Desktop/01-document/dotfiles/debian_display_master"
PREP_DONE_FLAG="${CONFIG_DIR}/system_prep_done.flag"

# --- Utility Functions ---
ensure_config_dir() {
    mkdir -p "$CONFIG_DIR"
    if [[ $EUID -eq 0 && -n "$SUDO_USER" ]]; then
        # If root created it due to sudo, chown to original user
        chown -R "$SUDO_USER:$(id -gn "$SUDO_USER")" "$CONFIG_DIR" 2>/dev/null || true
    fi
}

# --- Stage 1: System Preparation (from bash5.sh) ---
run_system_preparation() {
    echo
    echo "--- Stage 1: One-Time System Preparation ---"
    echo "This step installs necessary packages and configures autorandr services."

    if [[ $EUID -ne 0 ]]; then
        echo "ERROR: This step MUST be run with root privileges."
        echo "Please exit and re-run the entire script using: sudo bash $0"
        return 1
    fi

    if [[ -f "$PREP_DONE_FLAG" ]]; then
        read -rp "System preparation appears to have been run before (marker at $PREP_DONE_FLAG). Run again? (y/N): " confirm_rerun
        if [[ ! "$confirm_rerun" =~ ^[Yy]$ ]]; then
            echo "Skipping system preparation."
            # Ensure services are at least attempted to be started if they exist and prep was done
            if systemctl list-unit-files | grep -q autorandr.service && ! systemctl is-active --quiet autorandr.service; then
                echo "Attempting to start autorandr.service..."
                systemctl start autorandr.service || echo "Warning: Failed to start autorandr.service."
            fi
            if systemctl list-unit-files | grep -q autorandr-resume.service && ! systemctl is-active --quiet autorandr-resume.service; then
                 echo "Attempting to start autorandr-resume.service..."
                systemctl start autorandr-resume.service || echo "Warning: Failed to start autorandr-resume.service."
            fi
            return 0
        fi
    fi

    echo ">>> Starting one-time system preparation for display management..."

    echo ">>> Updating package lists (apt update)..."
    if ! apt update; then
        echo "ERROR: 'apt update' failed. Please check your internet connection and package sources."
        return 1
    fi

    echo ">>> Installing autorandr and python3-pip..."
    if ! apt install -y autorandr python3-pip; then
        echo "ERROR: Failed to install autorandr or python3-pip."
        return 1
    fi

    echo ">>> Installing tools for display information gathering and configuration..."
    echo "    (read-edid ddcutil hwinfo inxi lshw x11-xserver-utils edid-decode bc)"
    if ! apt install -y read-edid ddcutil hwinfo inxi lshw x11-xserver-utils edid-decode bc; then
        echo "ERROR: Failed to install one or more display utility packages."
        return 1
    fi

    echo ">>> System Updates Recommendation..."
    echo "    It's highly recommended to keep your system updated."
    echo "    You can do this by running: sudo apt update && sudo apt full-upgrade -y"

    echo ">>> GPU Memory Configuration (Conditional - Primarily for Raspberry Pi or similar SBCs)..."
    echo "    If using a Raspberry Pi, check/adjust GPU memory in /boot/config.txt if needed (e.g., gpu_mem=256)."

    echo ">>> Enabling and starting autorandr systemd services..."
    if systemctl list-unit-files | grep -q autorandr.service; then
        if systemctl enable --now autorandr.service; then
            echo "    autorandr.service has been enabled and started."
        else
            echo "    WARNING: Failed to enable/start autorandr.service."
        fi
        if systemctl list-unit-files | grep -q autorandr-resume.service; then
            if systemctl enable --now autorandr-resume.service; then
                echo "    autorandr-resume.service has been enabled and started."
            else
                echo "    WARNING: Failed to enable/start autorandr-resume.service."
            fi
        fi
    else
        echo "    WARNING: autorandr.service not found. This is unexpected for the Debian Bullseye package."
        echo "    Automatic hotplug detection via systemd might not function as described."
    fi

    ensure_config_dir # Ensure ~/Desktop/01-document/dotfiles/debian_display_master exists
    date > "$PREP_DONE_FLAG" # Create/update the flag file
    echo "    System preparation completion marker set in $PREP_DONE_FLAG"
    echo ">>> One-time system preparation script finished."
    echo "    Please REBOOT if you made changes like GPU memory configuration or if prompted by package installations."
    echo "    Next, proceed to 'Collect Monitor Information'."
    return 0
}

# --- Stage 2: Collect Monitor Information (from bash2.sh) ---
run_monitor_info_collection() {
    echo
    echo "--- Stage 2: Collect Monitor Information ---"
    echo "This step gathers detailed information about your connected monitors."
    echo "Full details (e.g., from ddcutil, get-edid) require running this script with 'sudo'."

    # --- Helper functions from bash2.sh, scoped locally ---
    _mi_check_privileges_for_tool() {
        local tool_name="$1"
        if [[ $EUID -ne 0 ]]; then
            echo "INFO: '$tool_name' provides more details or requires root. Running with limited privileges or skipping."
            return 1 # False (not root)
        fi
        return 0 # True (is root)
    }

    _mi_install_tools_explicit_check() {
      local missing_pkgs=""
      for pkg in read-edid ddcutil hwinfo inxi lshw x11-xserver-utils edid-decode bc; do
        if ! dpkg -s "$pkg" &> /dev/null; then
          missing_pkgs="$missing_pkgs $pkg"
        fi
      done
      if [[ -n "$missing_pkgs" ]]; then
        echo "WARNING: Some required packages are missing:$missing_pkgs" >&2
        echo "    Please run 'Stage 1: System Preparation' or 'sudo apt install$missing_pkgs'" >&2
        return 1
      fi
      return 0
    }

    local CURRENT_OUTDIR # Local to this function call
    _mi_setup_outdir() {
      local REAL_USER_EFFECTIVE NON_ROOT_HOME OUTDIR_BASE
      # Determine the non-root user if sudo was used
      if [[ $EUID -eq 0 && -n "$SUDO_USER" && "$SUDO_USER" != "root" ]]; then
          REAL_USER_EFFECTIVE="$SUDO_USER"
      else
          REAL_USER_EFFECTIVE=$(whoami) # Current effective user
      fi

      NON_ROOT_HOME=$(getent passwd "$REAL_USER_EFFECTIVE" | cut -d: -f6)

      if [[ -n "$NON_ROOT_HOME" && -d "$NON_ROOT_HOME" ]]; then
        OUTDIR_BASE="$NON_ROOT_HOME"
      else # Fallback if home not found or current user is root without SUDO_USER context
        OUTDIR_BASE="/tmp"
        echo "Warning: Could not determine a standard user home directory. Using $OUTDIR_BASE."
      fi
      
      CURRENT_OUTDIR="${OUTDIR_BASE}/monitor-info-$(date +%Y%m%d-%H%M%S)"
      if mkdir -p "$CURRENT_OUTDIR"; then
          echo "    Monitor information output directory: $CURRENT_OUTDIR"
          MONITOR_INFO_OUTDIR="$CURRENT_OUTDIR" # Assign to global
          # Ensure the original user can access it if created by root in their home
          if [[ $EUID -eq 0 && -n "$SUDO_USER" && "$OUTDIR_BASE" == "$(getent passwd "$SUDO_USER" | cut -d: -f6)" ]]; then
            chown -R "$SUDO_USER:$(id -gn "$SUDO_USER")" "$CURRENT_OUTDIR" || echo "    Warning: Could not chown $CURRENT_OUTDIR to $SUDO_USER"
          fi
          # Create summary.txt initially so tee -a works correctly
          touch "$MONITOR_INFO_OUTDIR/summary.txt"
          if [[ $EUID -eq 0 && -n "$SUDO_USER" ]]; then
              chown "$SUDO_USER:$(id -gn "$SUDO_USER")" "$MONITOR_INFO_OUTDIR/summary.txt" 2>/dev/null || true
          fi
      else
          echo "ERROR: Could not create output directory $CURRENT_OUTDIR. Please check permissions."
          MONITOR_INFO_OUTDIR=""
          return 1
      fi
      return 0
    }

    _mi_log_cmd() {
      local logfile="$1"; shift
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then echo "ERROR (log_cmd): MONITOR_INFO_OUTDIR not set."; return 1; fi
      {
        echo "===== $(date '+%F %T') : $* ====="
        "$@" 2>&1 || echo "(ERROR: '$*' failed with exit code $?)"
        echo
      } >>"$MONITOR_INFO_OUTDIR/$logfile"
    }

    local -a DRM_ALL DRM_EDID XRANDR_ALL XRANDR_CONNECTED # Local to this function call
    _mi_detect_connectors() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      DRM_ALL=() DRM_EDID=() XRANDR_ALL=() XRANDR_CONNECTED=()

      # Regex for connector names like HDMI-A-1, DP-1, eDP-1, DVI-D-1, LVDS-0 etc.
      # Matches: Prefix(letters) - Suffix(letters/numbers) - Number OR Prefix(letters) - Number
      local connector_regex='^[a-zA-Z]+(-[a-zA-Z0-9]+)*-[0-9]+$'

      for card_path in /sys/class/drm/card*; do
        if [[ -d "$card_path" ]]; then
            for path_in_card in "$card_path"/*; do
                local name
                name=$(basename "$path_in_card")
                if [[ -d "$path_in_card" && "$name" =~ $connector_regex ]]; then
                    DRM_ALL+=("$name")
                    if [[ -r "$path_in_card/edid" && -s "$path_in_card/edid" ]]; then
                        DRM_EDID+=("$name")
                    fi
                fi
            done
        fi
      done

      if command -v xrandr &> /dev/null && xhost >/dev/null 2>&1; then
        while IFS= read -r line; do
          local out
          out=$(awk '/ connected/{print $1} / disconnected/{print $1}' <<<"$line")
          [[ -n "$out" ]] && XRANDR_ALL+=("$out")
          [[ $line == *" connected"* ]] && XRANDR_CONNECTED+=("$out")
        done < <(xrandr 2>/dev/null)
      else
        echo "NOTE: xrandr queries skipped (X server not accessible or xrandr not found)." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
      fi

      {
        echo "All DRM connectors found: ${DRM_ALL[*]:-none}"
        echo "DRM connectors with readable EDID: ${DRM_EDID[*]:-none}"
        echo "xrandr outputs (if X session active): ${XRANDR_ALL[*]:-none}"
        echo "Connected outputs via xrandr (if X session active): ${XRANDR_CONNECTED[*]:-none}"
      } | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
    }

    _mi_collect_sysfs_edid() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      if ! command -v parse-edid &> /dev/null && ! command -v edid-decode &> /dev/null; then
        echo "Skipping sysfs EDID parsing: neither parse-edid nor edid-decode found." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
        return
      fi
      local parser_cmd
      parser_cmd=$(command -v edid-decode || command -v parse-edid)

      for CON_BASENAME in "${DRM_EDID[@]}"; do
        local edid_path=""
        for card_path in /sys/class/drm/card*; do # Find the card parent
            if [[ -e "$card_path/$CON_BASENAME/edid" ]]; then
                edid_path="$card_path/$CON_BASENAME/edid"
                break
            fi
        done
        if [[ -n "$edid_path" && -r "$edid_path" ]]; then
            _mi_log_cmd "edid_sysfs_${CON_BASENAME}.log" "$parser_cmd" <"$edid_path"
        else
            echo "Could not read sysfs EDID for $CON_BASENAME (path: $edid_path or not found)" | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
        fi
      done
    }

    _mi_collect_getedid() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      if ! _mi_check_privileges_for_tool "get-edid"; then return; fi
      if ! command -v get-edid &> /dev/null; then
        echo "Skipping get-edid: command not found." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
        return
      fi
      if ! command -v parse-edid &> /dev/null && ! command -v edid-decode &> /dev/null; then
        echo "Skipping get-edid parsing: no EDID parser found." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
        return
      fi
      local parser_cmd
      parser_cmd=$(command -v edid-decode || command -v parse-edid)

      if ! lsmod | grep -q "i2c_dev"; then
        echo "INFO: i2c_dev module not loaded. get-edid might fail. Consider 'sudo modprobe i2c_dev'." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
      fi
      _mi_log_cmd "edid_getedid.log" bash -c "get-edid 2>/dev/null | $parser_cmd"
    }

    _mi_collect_ddc() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      if ! _mi_check_privileges_for_tool "ddcutil"; then return; fi
      if ! command -v ddcutil &> /dev/null; then
        echo "Skipping ddcutil: command not found." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
        return
      fi
      if ! lsmod | grep -q "i2c_dev"; then
        echo "INFO: i2c_dev module not loaded. ddcutil might fail. Consider 'sudo modprobe i2c_dev'." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
      fi
      _mi_log_cmd "ddcutil_detect.log" ddcutil detect --verbose
    }

    _mi_collect_general_info() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      if command -v xrandr &> /dev/null && xhost >/dev/null 2>&1; then
        _mi_log_cmd "xrandr_verbose.log" xrandr --verbose
      fi
      
      # hwinfo, inxi, lshw can provide more with root
      local sudo_prefix=""
      if [[ $EUID -ne 0 ]]; then
          echo "INFO: hwinfo, inxi, lshw provide more details with root privileges."
          # Not prompting for sudo here, rely on script being run with sudo if full details desired.
      else
          sudo_prefix="" # Already root
      fi

      command -v hwinfo &> /dev/null && _mi_log_cmd "hwinfo_monitor.log" ${sudo_prefix} hwinfo --monitor --verbose
      command -v inxi &> /dev/null && _mi_log_cmd "inxi_Gxx.log" ${sudo_prefix} inxi -Gxx --display
      command -v lshw &> /dev/null && _mi_log_cmd "lshw_display.log" ${sudo_prefix} lshw -C display -sanitize
    }

    _mi_collect_udev() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      for CON_BASENAME in "${DRM_ALL[@]}"; do
        local sys_path=""
        for card_path in /sys/class/drm/card*; do
            if [[ -d "$card_path/$CON_BASENAME" ]]; then
                sys_path="$card_path/$CON_BASENAME"
                break
            fi
        done
        if [[ -n "$sys_path" && -e "$sys_path" ]]; then
            _mi_log_cmd "udevadm_${CON_BASENAME}.log" udevadm info --query=all --path="$(readlink -f "$sys_path")"
        fi
      done
    }

    _mi_generate_cvt_interactive() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      if ! command -v cvt &> /dev/null; then
        echo "Skipping CVT modeline generation: cvt command not found (part of x11-xserver-utils)." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
        return
      fi
      
      local W H R
      echo
      read -rp "Enter 'width height refresh' (e.g. 1920 1080 60) to generate a CVT modeline, or ENTER to skip: " W H R
      if [[ -z "$W" || -z "$H" || -z "$R" ]]; then
        echo "Skipping CVT modeline generation by user request."
        return
      fi

      if ! [[ "$W" =~ ^[0-9]+$ && "$H" =~ ^[0-9]+$ && "$R" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
          echo "Invalid input for width, height, or refresh. Please use numbers." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
          return
      fi

      local MODELINE_FULL MODELINE_PARAMS NAME
      MODELINE_FULL=$(cvt "$W" "$H" "$R" 2>/dev/null | grep Modeline)

      if [[ -n "$MODELINE_FULL" ]]; then
        # Extract the part after "Modeline "
        MODELINE_PARAMS_WITH_NAME=$(echo "$MODELINE_FULL" | sed 's/Modeline //')
        # Extract just the name (e.g., "1920x1080_60.00")
        NAME=$(echo "$MODELINE_PARAMS_WITH_NAME" | awk '{print $1}' | tr -d '"')
        # Extract parameters after the name
        MODELINE_PARAMS=$(echo "$MODELINE_PARAMS_WITH_NAME" | sed 's/^"[^"]*" //')

        echo "Generated Modeline: $MODELINE_FULL" | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
        echo "  Mode Name for xrandr: $NAME" | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
        echo "  Parameters for xrandr --newmode: $MODELINE_PARAMS" | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
        echo "This modeline string can be used in your custom Xrandr script (Stage 3)."

        # Optional immediate test if in X session
        if command -v xrandr &> /dev/null && xhost >/dev/null 2>&1; then
            local TARGET
            if [[ ${#XRANDR_CONNECTED[@]} -gt 0 ]]; then TARGET=${XRANDR_CONNECTED[0]}; fi
            
            if [[ -n "$TARGET" ]]; then
                read -rp "Attempt to temporarily apply this new mode '$NAME' to '$TARGET' for testing? (y/N): " APPLY_CVT
                if [[ "$APPLY_CVT" =~ ^[Yy]$ ]]; then
                  echo "Applying: xrandr --newmode \"$NAME\" $MODELINE_PARAMS" | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
                  if xrandr --newmode "$NAME" $MODELINE_PARAMS; then
                    echo "Applying: xrandr --addmode \"$TARGET\" \"$NAME\"" | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
                    if xrandr --addmode "$TARGET" "$NAME"; then
                      echo "Mode '$NAME' added to '$TARGET'. To activate it now (temporarily): xrandr --output \"$TARGET\" --mode \"$NAME\"" | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
                    else echo "ERROR: xrandr --addmode failed." | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"; fi
                  else echo "ERROR: xrandr --newmode failed (mode might already exist or be invalid)." | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"; fi
                fi
            fi
        else
            echo "    (X session not active or xrandr not found for immediate mode application test)."
        fi
      else
        echo "ERROR: Failed to generate modeline with cvt $W $H $R." | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
      fi
    }

    # --- Main execution for monitor info collection ---
    if ! _mi_install_tools_explicit_check; then
        echo "Monitor info collection cannot proceed due to missing tools."
        return 1
    fi
    if ! _mi_setup_outdir; then # Sets MONITOR_INFO_OUTDIR
        return 1 # Error message already printed by _mi_setup_outdir
    fi
    
    echo "    Collecting information. This may take a few moments..."
    _mi_detect_connectors
    _mi_collect_sysfs_edid
    _mi_collect_getedid
    _mi_collect_ddc
    _mi_collect_general_info
    _mi_collect_udev
    _mi_generate_cvt_interactive

    echo
    echo "    Monitor information collection Done."
    echo "    Review logs and summary.txt in: $MONITOR_INFO_OUTDIR"
    echo "    Key information for the next steps (connector names, modelines) can be found there."
    return 0
}

# --- Stage 3: Create/Edit Custom Xrandr Configuration Script (from bash4.sh template) ---
edit_xrandr_template_config() {
    echo
    echo "--- Stage 3: Create/Edit Custom Xrandr Configuration Script ---"
    echo "This step will help you create a custom script to configure your displays."
    echo "It uses a template based on 'bash4.sh' (a reference script)."
    echo "Your custom script will be saved at: $CUSTOM_XRANDR_SCRIPT_PATH"

    if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then
        echo "Warning: Monitor information doesn't seem to have been collected in this session."
        echo "    You may need to run 'Collect Monitor Information' first to get necessary details."
        read -rp "Proceed to create/edit template anyway? (y/N): " proceed_warn
        if [[ ! "$proceed_warn" =~ ^[Yy]$ ]]; then
            return
        fi
    else
        echo "    Refer to the information collected in: $MONITOR_INFO_OUTDIR"
    fi

    if [[ ! -f "$CUSTOM_XRANDR_SCRIPT_PATH" ]]; then
        echo "    Creating template script at $CUSTOM_XRANDR_SCRIPT_PATH..."
        # Heredoc for bash4.sh content, adapted
        cat > "$CUSTOM_XRANDR_SCRIPT_PATH" << 'EOF_XRANDR_CONFIG_TEMPLATE'
#!/bin/bash

# Custom Xrandr Configuration Script
# EDIT THIS FILE with your specific monitor outputs, modelines, and layout.
# Use information from the 'monitor-info' collection step (Stage 2 of the master script).
#
# This script is intended to be run from an active X Window System session as your normal user.
# These settings will only apply to the current X session.
#
# After testing, you can use these commands to create an autorandr profile.

# Check if xrandr command is available
if ! command -v xrandr &> /dev/null; then
    echo "Error: xrandr command not found. Please ensure it is installed and in your PATH."
    exit 1
fi

# Check if bc command is available (for DPI calculations)
BC_AVAILABLE=false
if command -v bc &> /dev/null; then
    BC_AVAILABLE=true
else
    echo "Warning: bc command not found. DPI calculation will be skipped if enabled."
fi

echo "Applying custom temporary xrandr settings..."
echo "Verify your display identifiers (e.g., HDMI-1, DP-1) by running 'xrandr' in a terminal if unsure."

# --- USER CONFIGURATION SECTION ---
# TODO: Replace these with your actual values based on 'monitor-info' output and desired setup.

# Example for Display 1 (e.g., your primary laptop screen or main desktop monitor)
OUTPUT_1_NAME="eDP-1"      # e.g., DP-1, eDP-1, LVDS-1. Check 'xrandr' or monitor-info logs.
MODE_1_NAME="1920x1080" # e.g., 1920x1080_60.00 or just 1920x1080 if a standard mode.
                        # Get from monitor-info or 'xrandr' output for connected monitors.
# If using a custom CVT modeline:
# MODELINE_1_PARAMS="173.00  1920 2048 2248 2576  1080 1083 1088 1120 -hsync +vsync" # Paste parameters after mode name
MODELINE_1_PARAMS="" # Leave empty if using a standard, already known mode.

# Physical dimensions & DPI for OUTPUT_1 (Optional)
OUTPUT_1_PHYS_WIDTH_MM=344  # Physical width in mm (e.g., 344 for a 15.6" 16:9 display)
OUTPUT_1_PHYS_HEIGHT_MM=193 # Physical height in mm (e.g., 193 for a 15.6" 16:9 display)
OUTPUT_1_MODE_WIDTH_PX=1920 # Pixel width for MODE_1_NAME (e.g., 1920)
OUTPUT_1_MODE_HEIGHT_PX=1080 # Pixel height for MODE_1_NAME (e.g., 1080)
OUTPUT_1_CALCULATE_DPI=false # Set to true to attempt DPI calculation for this.

# Example for Display 2 (e.g., an external HDMI monitor) - uncomment and configure if you have one
# OUTPUT_2_NAME="HDMI-1"
# MODE_2_NAME="1920x1080"
# MODELINE_2_PARAMS=""
# OUTPUT_2_PHYS_WIDTH_MM=527
# OUTPUT_2_PHYS_HEIGHT_MM=296
# OUTPUT_2_MODE_WIDTH_PX=1920
# OUTPUT_2_MODE_HEIGHT_PX=1080
# OUTPUT_2_CALCULATE_DPI=false

# --- Layout Command ---
# TODO: Customize this xrandr command thoroughly! This defines how your monitors are arranged.
#       Refer to 'man xrandr' for options like --pos, --left-of, --right-of, --above, --below, --primary, --rotate.
# Example 1: Single monitor (Output 1 is primary)
# XRANDR_CMD_ARGS=(--output "$OUTPUT_1_NAME" --mode "$MODE_1_NAME" --primary --auto)

# Example 2: Dual monitor - Output 2 (HDMI) right of Output 1 (eDP), Output 1 is primary
# Ensure OUTPUT_2_NAME and MODE_2_NAME are set above if using this.
# XRANDR_CMD_ARGS=(
#    --output "$OUTPUT_1_NAME" --mode "$MODE_1_NAME" --primary
#    --output "$OUTPUT_2_NAME" --mode "$MODE_2_NAME" --right-of "$OUTPUT_1_NAME" --auto
# )

# Example 3: Mirroring Output 1 to Output 2
# XRANDR_CMD_ARGS=(
#    --output "$OUTPUT_1_NAME" --mode "$MODE_1_NAME" --primary
#    --output "$OUTPUT_2_NAME" --mode "$MODE_1_NAME" --same-as "$OUTPUT_1_NAME"
# )

# Default placeholder: Output 1, auto mode, primary. MUST BE EDITED FOR YOUR SETUP.
XRANDR_CMD_ARGS=(--output "$OUTPUT_1_NAME" --auto --primary)

# --- END OF USER CONFIGURATION SECTION ---


# --- Script Logic (Generally no need to edit below this line) ---

# Define New Modes (if modelines are provided)
echo ""
if [[ -n "$OUTPUT_1_NAME" && -n "$MODE_1_NAME" && -n "$MODELINE_1_PARAMS" ]]; then
    echo "Defining new mode for $OUTPUT_1_NAME: $MODE_1_NAME"
    xrandr --newmode "$MODE_1_NAME" $MODELINE_1_PARAMS
    if [ $? -ne 0 ]; then
        echo "Warning: Could not define mode $MODE_1_NAME. It might already exist or modeline is invalid."
    fi
fi

if [[ -n "${OUTPUT_2_NAME:-}" && -n "${MODE_2_NAME:-}" && -n "${MODELINE_2_PARAMS:-}" ]]; then
    echo "Defining new mode for $OUTPUT_2_NAME: $MODE_2_NAME"
    xrandr --newmode "$MODE_2_NAME" $MODELINE_2_PARAMS
    if [ $? -ne 0 ]; then
        echo "Warning: Could not define mode $MODE_2_NAME. It might already exist or modeline is invalid."
    fi
fi

# Check current connection status of configured displays
echo ""
echo "Checking configured display connection status..."
IS_OUTPUT_1_CONNECTED=false
if [[ -n "$OUTPUT_1_NAME" ]] && xrandr | grep -q "^${OUTPUT_1_NAME}\s*connected"; then
    IS_OUTPUT_1_CONNECTED=true
    echo "- $OUTPUT_1_NAME is detected as connected."
else
    if [[ -n "$OUTPUT_1_NAME" ]]; then echo "- $OUTPUT_1_NAME is NOT configured or detected as disconnected."; fi
fi

IS_OUTPUT_2_CONNECTED=false
if [[ -n "${OUTPUT_2_NAME:-}" ]] && xrandr | grep -q "^${OUTPUT_2_NAME}\s*connected"; then
    IS_OUTPUT_2_CONNECTED=true
    echo "- $OUTPUT_2_NAME is detected as connected."
else
    if [[ -n "${OUTPUT_2_NAME:-}" ]]; then echo "- $OUTPUT_2_NAME is NOT configured or detected as disconnected."; fi
fi

# Add modes to outputs (if defined and modelines were used)
if [[ -n "$OUTPUT_1_NAME" && -n "$MODE_1_NAME" && -n "$MODELINE_1_PARAMS" && "$IS_OUTPUT_1_CONNECTED" == "true" ]]; then
    echo "Adding mode $MODE_1_NAME to $OUTPUT_1_NAME"
    xrandr --addmode "$OUTPUT_1_NAME" "$MODE_1_NAME"
    if [ $? -ne 0 ]; then echo "Warning: Could not add mode $MODE_1_NAME to $OUTPUT_1_NAME."; fi
fi
if [[ -n "${OUTPUT_2_NAME:-}" && -n "${MODE_2_NAME:-}" && -n "${MODELINE_2_PARAMS:-}" && "$IS_OUTPUT_2_CONNECTED" == "true" ]]; then
    echo "Adding mode $MODE_2_NAME to $OUTPUT_2_NAME"
    xrandr --addmode "$OUTPUT_2_NAME" "$MODE_2_NAME"
    if [ $? -ne 0 ]; then echo "Warning: Could not add mode $MODE_2_NAME to $OUTPUT_2_NAME."; fi
fi

# Apply Main Layout Command
echo ""
echo "Attempting to apply layout: xrandr ${XRANDR_CMD_ARGS[*]}"
if xrandr "${XRANDR_CMD_ARGS[@]}"; then
    echo "Successfully applied layout."
else
    echo "ERROR: Failed to apply layout command: xrandr ${XRANDR_CMD_ARGS[*]}"
    echo "Please check your XRANDR_CMD_ARGS, output names, and modes."
    exit 1
fi

# DPI Calculation
TARGET_DPI_OUTPUT_NAME=""
TARGET_DPI_MODE_WIDTH_PX=0
TARGET_DPI_MODE_HEIGHT_PX=0
TARGET_DPI_PHYS_WIDTH_MM=0
TARGET_DPI_PHYS_HEIGHT_MM=0

if [[ "$OUTPUT_1_CALCULATE_DPI" == "true" && "$IS_OUTPUT_1_CONNECTED" == "true" ]]; then
    TARGET_DPI_OUTPUT_NAME="$OUTPUT_1_NAME"
    TARGET_DPI_MODE_WIDTH_PX=$OUTPUT_1_MODE_WIDTH_PX
    TARGET_DPI_MODE_HEIGHT_PX=$OUTPUT_1_MODE_HEIGHT_PX
    TARGET_DPI_PHYS_WIDTH_MM=$OUTPUT_1_PHYS_WIDTH_MM
    TARGET_DPI_PHYS_HEIGHT_MM=$OUTPUT_1_PHYS_HEIGHT_MM
elif [[ "${OUTPUT_2_CALCULATE_DPI:-false}" == "true" && "$IS_OUTPUT_2_CONNECTED" == "true" ]]; then
    TARGET_DPI_OUTPUT_NAME="$OUTPUT_2_NAME"
    TARGET_DPI_MODE_WIDTH_PX=$OUTPUT_2_MODE_WIDTH_PX
    TARGET_DPI_MODE_HEIGHT_PX=$OUTPUT_2_MODE_HEIGHT_PX
    TARGET_DPI_PHYS_WIDTH_MM=$OUTPUT_2_PHYS_WIDTH_MM
    TARGET_DPI_PHYS_HEIGHT_MM=$OUTPUT_2_PHYS_HEIGHT_MM
fi

if [[ -n "$TARGET_DPI_OUTPUT_NAME" && "$BC_AVAILABLE" == "true" ]]; then
    echo ""
    echo "Attempting DPI calculation for $TARGET_DPI_OUTPUT_NAME."
    if [ "$TARGET_DPI_PHYS_WIDTH_MM" -gt 0 ] && [ "$TARGET_DPI_PHYS_HEIGHT_MM" -gt 0 ] && \
       [ "$TARGET_DPI_MODE_WIDTH_PX" -gt 0 ] && [ "$TARGET_DPI_MODE_HEIGHT_PX" -gt 0 ]; then
        
        DPI_H_CALC=$(bc -l <<< "scale=2; $TARGET_DPI_MODE_WIDTH_PX / ($TARGET_DPI_PHYS_WIDTH_MM / 25.4)")
        DPI_V_CALC=$(bc -l <<< "scale=2; $TARGET_DPI_MODE_HEIGHT_PX / ($TARGET_DPI_PHYS_HEIGHT_MM / 25.4)")

        if [[ "$DPI_H_CALC" =~ ^[0-9]+([.][0-9]+)?$ && "$DPI_V_CALC" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
            AVG_DPI=$(printf "%.0f" "$(bc -l <<< "($DPI_H_CALC + $DPI_V_CALC) / 2")")
            echo "Calculated average DPI for $TARGET_DPI_OUTPUT_NAME: $AVG_DPI (H: $DPI_H_CALC, V: $DPI_V_CALC)"
            echo "Attempting to set screen DPI to $AVG_DPI..."
            if xrandr --dpi "$AVG_DPI"; then
                echo "Screen DPI successfully set to $AVG_DPI. This may improve font rendering."
            else
                echo "Warning: Could not set screen DPI to $AVG_DPI. Your X server or driver might not support this, or the value might be out of range."
            fi
        else
            echo "Warning: DPI calculation failed or produced non-numeric results (H: $DPI_H_CALC, V: $DPI_V_CALC). Skipping DPI setting."
        fi
    else
        echo "Warning: Physical dimensions or mode resolution for $TARGET_DPI_OUTPUT_NAME are zero or invalid. Cannot calculate DPI."
    fi
elif [[ -n "$TARGET_DPI_OUTPUT_NAME" && "$BC_AVAILABLE" == "false" ]]; then
    echo "DPI calculation for $TARGET_DPI_OUTPUT_NAME skipped: 'bc' command not available."
fi

echo ""
echo "Custom temporary xrandr settings applied (or attempted)."
echo "Current screen configuration (relevant connected displays):"
xrandr | grep " connected" || echo "(xrandr found no connected displays or xrandr command failed)"

echo ""
echo "If this configuration is correct, you can save it as an autorandr profile (Stage 5 of master script)."
echo "If you encounter issues, please check:"
echo "1. Your display output names and modes in the USER CONFIGURATION SECTION are correct."
echo "2. Your displays are properly connected and powered on."
echo "3. The modelines (if used) are compatible with your hardware."
echo "4. Review any error messages above from xrandr."
echo "5. If DPI was set, verify with 'xdpyinfo | grep resolution'."

exit 0
EOF_XRANDR_CONFIG_TEMPLATE
        chmod +x "$CUSTOM_XRANDR_SCRIPT_PATH"
    else
        echo "    Existing script found at $CUSTOM_XRANDR_SCRIPT_PATH."
    fi

    echo ""
    echo "    Please EDIT the script '$CUSTOM_XRANDR_SCRIPT_PATH' with your specific display settings."
    echo "    You will need to set:"
    echo "      - OUTPUT_1_NAME, MODE_1_NAME, MODELINE_1_PARAMS (if using custom modeline)"
    echo "      - Physical dimensions (e.g., OUTPUT_1_PHYS_WIDTH_MM) and OUTPUT_1_CALCULATE_DPI if you want DPI calculation."
    echo "      - Configure OUTPUT_2 variables if you have a second display."
    echo "      - Most importantly, customize the XRANDR_CMD_ARGS array with your full layout command."
    echo ""
    if [[ -n "$MONITOR_INFO_OUTDIR" ]]; then
        echo "    Refer to monitor information collected in: $MONITOR_INFO_OUTDIR"
    fi
    
    read -rp "Would you like to open '$CUSTOM_XRANDR_SCRIPT_PATH' with 'nano' now? (y/N): " edit_now
    if [[ "$edit_now" =~ ^[Yy]$ ]]; then
        if command -v nano &> /dev/null; then
            nano "$CUSTOM_XRANDR_SCRIPT_PATH"
        else
            echo "'nano' not found. Please edit the file manually using your preferred editor (e.g., vim, gedit, code)."
        fi
    else
        echo "Please edit '$CUSTOM_XRANDR_SCRIPT_PATH' manually."
    fi
    echo "    After editing, proceed to 'Test Custom Xrandr Configuration'."
}

# --- Stage 4: Test Custom Xrandr Configuration (runs the edited script) ---
test_custom_xrandr_config() {
    echo
    echo "--- Stage 4: Test Custom Xrandr Configuration ---"
    echo "This step executes your custom script to apply display settings temporarily."

    if [[ ! -f "$CUSTOM_XRANDR_SCRIPT_PATH" ]]; then
        echo "Custom configuration script '$CUSTOM_XRANDR_SCRIPT_PATH' not found."
        echo "    Please run 'Stage 3: Create/Edit Custom Xrandr Configuration Script' first."
        return 1
    fi

    if [[ -z "$DISPLAY" ]]; then
        echo "ERROR: No X session detected (DISPLAY variable is not set)."
        echo "    This step MUST be run from within an active X Window System session"
        echo "    (e.g., from a terminal emulator in your desktop environment) as your normal user."
        return 1
    fi
    if ! xhost >/dev/null 2>&1; then # A simple check to see if X server is accessible
        echo "ERROR: Cannot connect to X server. Ensure you are in an active X session."
        return 1
    fi
    if [[ $EUID -eq 0 ]]; then
        echo "WARNING: It's recommended to run this test as your normal desktop user, not as root."
        read -rp "Continue as root anyway? (y/N): " continue_root_test
        if [[ ! "$continue_root_test" =~ ^[Yy]$ ]]; then return 1; fi
    fi


    echo "    You are about to execute the script: $CUSTOM_XRANDR_SCRIPT_PATH"
    echo "    This will attempt to change your current display settings."
    echo "    Ensure you have saved any important work."
    echo "    Know how to recover if the display becomes unusable:"
    echo "      - Switch to a TTY (Ctrl+Alt+F2 through F6)."
    echo "      - Log in, then you can try 'sudo systemctl restart display-manager' or 'sudo reboot'."
    echo "      - Or, from TTY, try 'export DISPLAY=:0; xrandr --auto' (may need to find correct DISPLAY)."
    read -rp "Proceed with testing? (y/N): " confirm_test
    if [[ ! "$confirm_test" =~ ^[Yy]$ ]]; then
        echo "Testing aborted."
        return
    fi

    echo "    Executing '$CUSTOM_XRANDR_SCRIPT_PATH'..."
    if bash "$CUSTOM_XRANDR_SCRIPT_PATH"; then
        echo "    Custom Xrandr script executed successfully."
    else
        echo "    Custom Xrandr script executed with an error (exit code $?)."
    fi

    echo ""
    echo "    Test execution finished."
    echo "    If the display configuration is as expected, you can proceed to save it as an autorandr profile."
    echo "    If not, re-edit '$CUSTOM_XRANDR_SCRIPT_PATH' and test again."
}

# --- Stage 5: Autorandr Profile Management ---
save_autorandr_profile() {
    echo
    echo "--- Stage 5a: Save Current Configuration as Autorandr Profile ---"
    echo "This saves your current Xrandr display configuration as an autorandr profile."

    if [[ -z "$DISPLAY" ]]; then echo "ERROR: No X session detected. Must be run from an active X session."; return 1; fi
    if [[ $EUID -eq 0 ]]; then echo "WARNING: Saving autorandr profiles is typically done as the desktop user."; fi
    if ! command -v autorandr &> /dev/null; then
        echo "ERROR: autorandr command not found. Please run Stage 1 (System Preparation)."
        return 1
    fi

    echo "    Ensure your displays are configured exactly as you want them"
    echo "    (e.g., after a successful test in Stage 4)."
    
    local current_profile
    current_profile=$(autorandr --current 2>/dev/null)
    if [[ -n "$current_profile" ]]; then
        echo "    Current detected autorandr profile: $current_profile"
    else
        echo "    No specific autorandr profile currently detected as active (or multiple match)."
    fi

    read -rp "Enter a name for this new autorandr profile (e.g., 'home_dual_monitor', 'laptop_only'): " profile_name
    if [[ -z "$profile_name" ]]; then
        echo "No profile name entered. Aborting save."
        return
    fi

    # Sanitize profile name (basic: replace spaces and special chars with underscore)
    profile_name=$(echo "$profile_name" | tr -s ' /\\:&?' '_')

    echo "    Saving current configuration as profile: '$profile_name'..."
    if autorandr --save "$profile_name"; then
        echo "    Profile '$profile_name' saved successfully."
        echo "    Autorandr should now automatically apply this profile when this display setup is detected"
        echo "    (assuming autorandr services are running from Stage 1)."
    else
        echo "ERROR: Failed to save autorandr profile '$profile_name'."
    fi
}

view_autorandr_profiles() {
    echo
    echo "--- Stage 5b: View Autorandr Profiles ---"
    if ! command -v autorandr &> /dev/null; then
        echo "ERROR: autorandr command not found. Please run Stage 1 (System Preparation)."
        return 1
    fi
    echo "    Available autorandr profiles:"
    autorandr --list
    local current_profile
    current_profile=$(autorandr --current 2>/dev/null)
     if [[ -n "$current_profile" ]]; then
        echo "    Currently active/detected profile(s): $current_profile"
    fi
}

load_autorandr_profile() {
    echo
    echo "--- Stage 5c: Load Autorandr Profile ---"
    echo "This attempts to load a saved autorandr profile."

    if [[ -z "$DISPLAY" ]]; then echo "ERROR: No X session detected. Must be run from an active X session."; return 1; fi
    if [[ $EUID -eq 0 ]]; then echo "WARNING: Loading autorandr profiles is typically done as the desktop user."; fi
    if ! command -v autorandr &> /dev/null; then
        echo "ERROR: autorandr command not found. Please run Stage 1 (System Preparation)."
        return 1
    fi

    echo "    Available profiles:"
    autorandr --list
    read -rp "Enter the name of the profile to load: " profile_to_load
    if [[ -z "$profile_to_load" ]]; then
        echo "No profile name entered. Aborting."
        return
    fi

    echo "    Attempting to load profile '$profile_to_load'..."
    # Using --change is often preferred as it only applies if the detected setup matches the profile.
    # --load or --force --load will apply it regardless.
    if autorandr --change "$profile_to_load"; then
        echo "    Profile '$profile_to_load' loaded/applied (if it matched current hardware or was forced by --change)."
        echo "    If it didn't change, it might be already active or not match. Try 'autorandr --force --load $profile_to_load'."
    else
        echo "ERROR: Failed to load/apply autorandr profile '$profile_to_load' with --change."
        echo "    Try 'autorandr --load $profile_to_load' or 'autorandr --force --load $profile_to_load'."
    fi
}


# --- Main Menu ---
main_menu() {
    ensure_config_dir # Create ~/Desktop/01-document/dotfiles/debian_display_master if it doesn't exist
    echo
    echo "Debian Bullseye Display Setup & Management Utility"
    echo "=================================================="
    echo "IMPORTANT: Read script header and option notes for SUDO/X Session requirements."
    echo

    PS3="Please choose an option: "
    options=(
        "1. Run ONE-TIME System Preparation (MUST RUN SCRIPT WITH SUDO)"
        "2. Collect Monitor Information (NEEDS ROOT FOR FULL DETAILS)"
        "3. Create/Edit Custom Xrandr Configuration Script (RUN AS USER)"
        "4. Test Custom Xrandr Configuration (RUN IN X SESSION AS USER)"
        "5. Save Current Configuration as Autorandr Profile (RUN IN X SESSION AS USER)"
        "6. View Autorandr Profiles (RUN AS USER)"
        "7. Load Autorandr Profile (RUN IN X SESSION AS USER)"
        "8. Exit"
    )
    COLUMNS=1 # For select formatting
    select optk in "${!options[@]}"; do # Iterate over keys for robust option handling
        local opt_text=${options[$optk]}
        local opt_num=$((optk + 1))

        case $opt_num in
            1) run_system_preparation ;;
            2) run_monitor_info_collection ;;
            3) edit_xrandr_template_config ;;
            4) test_custom_xrandr_config ;;
            5) save_autorandr_profile ;;
            6) view_autorandr_profiles ;;
            7) load_autorandr_profile ;;
            8) echo "Exiting."; exit 0 ;;
            *) echo "Invalid option $REPLY. Please choose a number from 1 to 8.";;
        esac
        # Prompt to continue after each action
        echo
        read -rp "Press Enter to return to the menu..."
        # Re-display menu
        echo
        echo "Debian Bullseye Display Setup & Management Utility"
        echo "=================================================="
        echo "IMPORTANT: Read script header and option notes for SUDO/X Session requirements."
        echo
    done
}

# --- Script Entry Point ---
main_menu

exit 0
```

===
~~~~
---
tags: [scratchpad]
info: aberto.
date: 2025-04-03
type: post
layout: post
published: true
slug: xrandr
title: 'autorandr and bash script to collect and setup monitor data for xrandr'
---

| **Resolution (Width x Height)** | **Aspect Ratio** | **Common Name(s)**  | **Total Pixels** |
|:-------------------------------:|:----------------:|:-------------------:|:----------------:|
| 3840x1080                       | 32:9             | DFHD (Dual Full HD) | 4,147,200        |
| 5120x1440                       | 32:9             | DQHD (Dual QHD)     | 7,372,800        |
| 2560x1080                       | 21:9             | UltraWide FHD       | 2,764,800        |
| 3440x1440                       | 21:9             | UltraWide QHD       | 4,953,600        |
| 3840x1600                       | 21:9             | UWQHD+              | 6,144,000        |
| 5120x2160                       | 21:9             | 5K Ultrawide (UW5K) | 11,059,200       |
| 2048x1080                       | 17:9             | 2K                  | 2,211,840        |
| 4096x2160                       | 17:9             | DCI 4K              | 8,847,360        |
| 1280x800                        | 16:10            | WXGA                | 1,024,000        |
| 1440x900                        | 16:10            | WXGA+               | 1,296,000        |
| 1680x1050                       | 16:10            | WSXGA+              | 1,764,000        |
| 1920x1200                       | 16:10            | WUXGA               | 2,304,000        |
| 2560x1600                       | 16:10            | WQXGA               | 4,096,000        |
| 1280x720                        | 16:9             | HD, 720p            | 921,600          |
| 1360x768                        | 16:9             | HD                  | 1,044,480        |
| 1366x768                        | 16:9             | HD                  | 1,049,088        |
| 1536x864                        | 16:9             | \-                  | 1,327,104        |
| 1600x900                        | 16:9             | HD+                 | 1,440,000        |
| 1920x1080                       | 16:9             | Full HD, FHD, 1080p | 2,073,600        |
| 2048x1152                       | 16:9             | QWXGA               | 2,359,296        |
| 2560x1440                       | 16:9             | QHD, WQHD, 1440p    | 3,686,400        |
| 3840x2160                       | 16:9             | 4K UHD              | 8,294,400        |
| 5120x2880                       | 16:9             | 5K                  | 14,745,600       |
| 7680x4320                       | 16:9             | 8K UHD              | 33,177,600       |
| 1280x1024                       | 5:4              | SXGA                | 1,310,720        |
| 1280x768                        | 5:3              | WXGA                | 983,040          |
| 640x480                         | 4:3              | VGA                 | 307,200          |
| 800x600                         | 4:3              | SVGA                | 480,000          |
| 1024x768                        | 4:3              | XGA                 | 786,432          |
| 1152x864                        | 4:3              | XGA+                | 995,328          |
| 1280x960                        | 4:3              | SXGA-               | 1,228,800        |
| 1400x1050                       | 4:3              | SXGA+               | 1,470,000        |
| 1600x1200                       | 4:3              | UXGA                | 1,920,000        |

### **Why Use autorandr?**

autorandr is a highly effective, Python-based utility specifically designed to automate and simplify the management of multiple display configurations on Linux systems. Its core strength lies in its ability to automatically detect which displays (like projectors, external monitors, or ultrawide screens) are currently connected to your system and then apply a pre-saved configuration ("profile") that matches that specific hardware setup. This eliminates the need to manually execute commands with xrandr (a command-line tool for configuring display settings) every time you connect or disconnect a display.

This automation is particularly beneficial in your scenario as a professor using a Raspberry Pi 4B with openSUSE Tumbleweed. Imagine moving between different lecture halls, each potentially having a projector with a unique native resolution (1024x768, 1280x800, etc.), then returning to your office to connect to an ultrawide monitor (e.g., 3440x1440), and perhaps later connecting to a standard monitor in a departmental meeting room. Without autorandr, each transition would require manual reconfiguration. With autorandr, once you've saved a profile for each setup, the system adapts automatically upon connection. Furthermore, on a modern system like openSUSE Tumbleweed, autorandr integrates seamlessly with the systemd init system. This means it can leverage udev events (the system's way of detecting hardware changes like plugging in a monitor) to trigger the profile switching automatically in the background, offering a truly hands-off experience after the initial setup.

**Key Benefits Elaborated:**

* **Automatic Detection & Application:** autorandr intelligently identifies connected displays, often using their unique EDID information, and compares this against its library of saved profiles to find the best match, applying it instantly.  
* **Ease of Use:** The "save once, use anywhere" philosophy drastically reduces complexity. Instead of remembering complex xrandr commands or navigating display settings repeatedly, you perform the setup once per unique display combination and save it with a memorable name.  
* **Flexibility:** It excels at managing numerous distinct profiles. You can have profiles for single displays, dual displays in different arrangements (extended desktop, mirrored), displays with specific resolutions or refresh rates, covering virtually any common scenario you encounter.  
* **Robustness:** It gracefully handles situations where display EDID information might be missing, corrupt, or ambiguous – common issues with older projectors or certain adapters. Instead of failing outright or requiring manual intervention like raw xrandr might, autorandr can use other detected properties or fall back to a predefined default profile, ensuring you usually get a usable display state.

### **Prerequisites (Raspberry Pi 4B Specific)**

Before diving into autorandr installation, optimizing your Raspberry Pi 4B environment is crucial for smooth display operation, especially given its shared memory architecture:

* **GPU Memory (gpu\_mem):** The Raspberry Pi dynamically allocates system RAM between the CPU and the VideoCore GPU. Insufficient memory allocated to the GPU can lead to various graphical issues, such as visual glitches, screen tearing, an inability to drive displays at their native (especially high) resolutions (like 4K), or even completely blank screens. While the default allocation might be sufficient for basic desktop use, connecting multiple monitors or high-resolution displays often requires more. Check your current allocation and consider increasing it if you face issues. You can adjust this by editing the /boot/efi/extraconfig.txt file (the path might vary slightly depending on the exact Tumbleweed Pi image setup) and adding or modifying a line like gpu\_mem=256 or gpu\_mem=512 (allocating 256MB or 512MB respectively). A reboot is required for this change to be applied by the system.  
* **Firmware & System Updates:** The Raspberry Pi's firmware and the Linux kernel's graphics drivers (like V3D DRM) are continually updated to improve hardware compatibility, fix bugs, and enhance performance. These updates often include improved handling of display detection protocols like EDID. Keeping your openSUSE Tumbleweed system fully updated is the best way to ensure you have the latest fixes and broadest compatibility. Use the standard Tumbleweed update command, sudo zypper dup (which performs a full system upgrade). Regularly running this ensures you benefit from the latest improvements relevant to display handling.

### **Installation on openSUSE Tumbleweed**

You have several avenues to install autorandr on your system:

1. **Check Standard Repositories (Try First):** OpenSUSE Tumbleweed might already include autorandr in its main repositories. You can check its availability and install it if found:  
   \# Check if the package exists  
   zypper info autorandr  
   \# If available, install it  
   sudo zypper refresh  
   sudo zypper install autorandr

2. **Recommended Method (openSUSE Build Service \- OBS):** The autorandr author often maintains a more up-to-date version in a dedicated OBS repository. This is generally the preferred method if the package isn't in the main repos or if you need the latest features/fixes:  
   \# Add the repository  
   sudo zypper addrepo https://download.opensuse.org/repositories/home:phillipberndt/openSUSE\_Tumbleweed/home:phillipberndt.repo  
   \# Refresh repository metadata  
   sudo zypper refresh  
   \# Install autorandr from the new repo  
   sudo zypper install autorandr

3. **Alternative Method (pip):** You can install autorandr using Python's package installer, pip. However, be aware that this method might install it only for the current user, might not integrate as seamlessly with system-wide services like systemd/udev, and might require manual handling of non-Python dependencies. It can also lead to conflicts if system packages also provide parts of the dependencies.  
   \# Ensure pip is installed, then install autorandr  
   sudo zypper install python3-pip  
   sudo pip install autorandr

4. **Alternative Method (From Source):** For developers or those needing the absolute latest code, you can clone the autorandr Git repository and install it manually. This typically requires development tools like gcc and make, and you'll need to manage dependencies yourself. Consult the README file in the repository for specific instructions.  
   \# Example (dependencies might vary)  
   sudo zypper install git make python3-devel  
   git clone https://github.com/phillipberndt/autorandr.git  
   cd autorandr  
   sudo make install

### **Basic Configuration: Creating and Managing Profiles**

The fundamental workflow for using autorandr revolves around capturing the state of your display setup for each unique configuration you use:

1. **Connect:** Physically connect your Raspberry Pi to the specific combination of displays (e.g., a single classroom projector, your dual monitors at the office).  
2. **Configure Manually (Once):** Use your preferred method to arrange the displays exactly how you want them *for this specific setup*. This could be:  
   * **Desktop Environment Tools:** Use the graphical display settings panel provided by your desktop environment (e.g., xfce4-display-settings in Xfce, the 'Displays' panel in GNOME Settings). Here you can typically enable/disable monitors, set resolutions, refresh rates, orientation, and define primary displays and relative positions in an extended desktop.  
   * **Manual xrandr Commands:** For more fine-grained control or scripting, use xrandr directly in the terminal. For example: xrandr \--output HDMI-1 \--mode 1920x1080 \--primary \--output DisplayPort-1 \--mode 2560x1440 \--rotate left \--right-of HDMI-1.  
3. **Save Profile:** Once the displays are configured correctly, save this entire state as an autorandr profile using a descriptive name. Choosing a consistent naming convention can be helpful, e.g., location-displaytype-resolution or setup\_description.  
   \# Example for a specific lecture hall projector  
   autorandr \--save lecturehallB-projector-1280x800

   \# Example for your office ultrawide setup  
   autorandr \--save office-ultrawide-3440x1440

   \# Example for a standard 1080p monitor used for testing  
   autorandr \--save lab-monitor-1080p

   It's a good idea to back up this directory periodically, especially if you have complex or finely-tuned profiles.  
4. **List Profiles:** To review the profiles you have saved:  
   autorandr \--list

### **Applying Configurations**

* **Manual Application:** You can manually trigger autorandr to detect the currently connected displays and apply the best-matching profile from your saved library. This is useful for testing or if automation isn't set up.  
  autorandr \--change

  Behind the scenes, autorandr \--change performs several steps: it detects all connected displays and their properties (like EDID, which is data that allows a display to communicate its capabilities to the graphics card), compares this information against the data stored in each of your saved profiles, calculates a "match score" for each profile based on how well it fits the current hardware, and then automatically executes the xrandr commands stored within the highest-scoring profile (if the score exceeds a certain threshold). If no profile matches well enough, it might load the designated default profile or leave the configuration unchanged, depending on your setup.

### CUSTOM_XRANDR_SCRIPT_PATH="/root/my_custom_display_config.sh"

```bash
#!/bin/bash
# Xrandr dual-monitor setup (expanded, refactored)
# HDMI-1 → 800x600@60 (primary)
# DP-1   → 640x480@60 (right of HDMI-1)
# Modelines and outputs are fixed based on provided logs. No placeholders.

set -Eeuo pipefail

# --------------------------
# Utilities / Logging
# --------------------------
log()  { printf '[INFO ] %s\n' "$*"; }
warn() { printf '[WARN ] %s\n' "$*" >&2; }
err()  { printf '[ERROR] %s\n' "$*" >&2; }

# If DRY_RUN=1 is set in the environment, print commands instead of executing them.
: "${DRY_RUN:=0}"
run() {
  if [[ "$DRY_RUN" == "1" ]]; then
    printf '[DRYRUN] %s\n' "$*"
    return 0
  fi
  eval "$@"
}

# --------------------------
# Pre-flight checks
# --------------------------
if ! command -v xrandr >/dev/null 2>&1; then
  err 'xrandr not found'
  exit 127
fi

# --------------------------
# Fixed configuration from logs
# --------------------------
OUTPUT_1_NAME="HDMI-1"
MODE_1_NAME="800x600_60.00"
MODELINE_1_PARAMS="38.25  800 832 912 1024  600 603 607 624 -hsync +vsync"

OUTPUT_2_NAME="DP-1"
MODE_2_NAME="640x480_60.00"
MODELINE_2_PARAMS="23.75  640 664 720 800  480 483 487 500 -hsync +vsync"

# --------------------------
# Helpers for xrandr state
# --------------------------
connected() {
  xrandr | grep -q "^$1\s*connected"
}

mode_defined() {
  local name="$1"
  # A mode is "defined" if it appears anywhere in xrandr --query output
  xrandr --query | awk '{print $1}' | grep -Fxq "$name"
}

output_has_mode() {
  local out="$1" name="$2"
  # Extract the block for this output and list the mode names, then search for ours.
  xrandr --query | awk -v o="$out" '
    $1==o {on=1; next}
    on && NF==0 {on=0}
    on && $1!~/^\t/ && $2=="connected" {on=0}
    on {print $1}
  ' | sed 's/^[[:space:]]*//' | grep -Fxq "$name" 2>/dev/null
}

active_geom() {
  # Prints WxH for given output if connected; empty otherwise
  local out="$1"
  xrandr --query | awk -v o="$out" '$1==o && $2=="connected" {
    match($0, /[0-9]+x[0-9]+\+[0-9]+\+[0-9]+/);
    if (RSTART) { s=substr($0,RSTART,RLENGTH); sub(/\+.*/, "", s); print s; }
  }'
}

# --------------------------
# Capture pre-state for reversible changes
# --------------------------
PRESTATE_CMD=()
for out in "$OUTPUT_1_NAME" "$OUTPUT_2_NAME"; do
  if connected "$out"; then
    # Best-effort revert uses preferred mode and auto placement for each output.
    PRESTATE_CMD+=(--output "$out" --auto)
  fi
done

revert() {
  if ((${#PRESTATE_CMD[@]})); then
    warn "Reverting to auto configuration"
    run xrandr "${PRESTATE_CMD[@]}" || warn "Revert failed"
  fi
}

trap 'err "Failure occurred"; revert' ERR

# --------------------------
# Ensure modes exist and are assigned to outputs
# --------------------------
ensure_mode_defined() {
  local name="$1"; shift
  if mode_defined "$name"; then
    log "Mode present: $name"
  else
    log "Defining mode: $name"
    run xrandr --newmode "$name" "$@"
  fi
}

ensure_output_has_mode() {
  local out="$1" name="$2"
  if output_has_mode "$out" "$name"; then
    log "Output $out already has mode $name"
  else
    log "Adding mode $name to $out"
    run xrandr --addmode "$out" "$name"
  fi
}

# Validate outputs are connected before modifying
for out in "$OUTPUT_1_NAME" "$OUTPUT_2_NAME"; do
  if ! connected "$out"; then
    err "Output not connected: $out"
    exit 2
  fi
done

# Define modes idempotently
ensure_mode_defined "$MODE_1_NAME" $MODELINE_1_PARAMS
ensure_mode_defined "$MODE_2_NAME" $MODELINE_2_PARAMS

# Assign modes to each output
ensure_output_has_mode "$OUTPUT_1_NAME" "$MODE_1_NAME"
ensure_output_has_mode "$OUTPUT_2_NAME" "$MODE_2_NAME"

# --------------------------
# Apply requested layout
# --------------------------
LAYOUT_CMD=(
  --output "$OUTPUT_1_NAME" --mode "$MODE_1_NAME" --primary
  --output "$OUTPUT_2_NAME" --mode "$MODE_2_NAME" --right-of "$OUTPUT_1_NAME"
)

log "Applying layout"
run xrandr "${LAYOUT_CMD[@]}"

# --------------------------
# Post-apply verification
# --------------------------
geom1=$(active_geom "$OUTPUT_1_NAME")
geom2=$(active_geom "$OUTPUT_2_NAME")

if [[ "$geom1" != "800x600" ]]; then
  err "Post-check failed: $OUTPUT_1_NAME geometry is '$geom1' (expected 800x600)"
  revert; exit 3
fi
if [[ "$geom2" != "640x480" ]]; then
  err "Post-check failed: $OUTPUT_2_NAME geometry is '$geom2' (expected 640x480)"
  revert; exit 4
fi

log "Configuration successful: $OUTPUT_1_NAME=$geom1 (primary), $OUTPUT_2_NAME=$geom2 (right)"
exit 0
```

### **Automation**

{% codeblock bash %}
#!/usr/bin/env bash
#
# debian_display_setup.sh
# A comprehensive script to guide through display setup and management on Debian Bullseye,
# integrating the logic of five specialized scripts.
#
# IMPORTANT USAGE NOTES:
# - Options marked (MUST RUN SCRIPT WITH SUDO) require you to invoke this entire script
#   using 'sudo bash debian_display_setup.sh'.
# - Options marked (RUN IN X SESSION) must be run as your normal user from a terminal
#   emulator within your active graphical desktop session.
# - Options marked (NEEDS ROOT FOR FULL DETAILS) will provide more comprehensive information
#   if the script is run with 'sudo', but may offer limited functionality otherwise.
#

set -euo pipefail

# --- Global Variables ---
MONITOR_INFO_OUTDIR=""
CUSTOM_XRANDR_SCRIPT_PATH="${HOME}/my_custom_display_config.sh" # User's editable script
CONFIG_DIR="${HOME}/Desktop/01-document/dotfiles/debian_display_master"
PREP_DONE_FLAG="${CONFIG_DIR}/system_prep_done.flag"

# --- Utility Functions ---
ensure_config_dir() {
    mkdir -p "$CONFIG_DIR"
    if [[ $EUID -eq 0 && -n "$SUDO_USER" ]]; then
        # If root created it due to sudo, chown to original user
        chown -R "$SUDO_USER:$(id -gn "$SUDO_USER")" "$CONFIG_DIR" 2>/dev/null || true
    fi
}

# --- Stage 1: System Preparation (from bash5.sh) ---
run_system_preparation() {
    echo
    echo "--- Stage 1: One-Time System Preparation ---"
    echo "This step installs necessary packages and configures autorandr services."

    if [[ $EUID -ne 0 ]]; then
        echo "ERROR: This step MUST be run with root privileges."
        echo "Please exit and re-run the entire script using: sudo bash $0"
        return 1
    fi

    if [[ -f "$PREP_DONE_FLAG" ]]; then
        read -rp "System preparation appears to have been run before (marker at $PREP_DONE_FLAG). Run again? (y/N): " confirm_rerun
        if [[ ! "$confirm_rerun" =~ ^[Yy]$ ]]; then
            echo "Skipping system preparation."
            # Ensure services are at least attempted to be started if they exist and prep was done
            if systemctl list-unit-files | grep -q autorandr.service && ! systemctl is-active --quiet autorandr.service; then
                echo "Attempting to start autorandr.service..."
                systemctl start autorandr.service || echo "Warning: Failed to start autorandr.service."
            fi
            if systemctl list-unit-files | grep -q autorandr-resume.service && ! systemctl is-active --quiet autorandr-resume.service; then
                 echo "Attempting to start autorandr-resume.service..."
                systemctl start autorandr-resume.service || echo "Warning: Failed to start autorandr-resume.service."
            fi
            return 0
        fi
    fi

    echo ">>> Starting one-time system preparation for display management..."

    echo ">>> Updating package lists (apt update)..."
    if ! apt update; then
        echo "ERROR: 'apt update' failed. Please check your internet connection and package sources."
        return 1
    fi

    echo ">>> Installing autorandr and python3-pip..."
    if ! apt install -y autorandr python3-pip; then
        echo "ERROR: Failed to install autorandr or python3-pip."
        return 1
    fi

    echo ">>> Installing tools for display information gathering and configuration..."
    echo "    (read-edid ddcutil hwinfo inxi lshw x11-xserver-utils edid-decode bc)"
    if ! apt install -y read-edid ddcutil hwinfo inxi lshw x11-xserver-utils edid-decode bc; then
        echo "ERROR: Failed to install one or more display utility packages."
        return 1
    fi

    echo ">>> System Updates Recommendation..."
    echo "    It's highly recommended to keep your system updated."
    echo "    You can do this by running: sudo apt update && sudo apt full-upgrade -y"

    echo ">>> GPU Memory Configuration (Conditional - Primarily for Raspberry Pi or similar SBCs)..."
    echo "    If using a Raspberry Pi, check/adjust GPU memory in /boot/config.txt if needed (e.g., gpu_mem=256)."

    echo ">>> Enabling and starting autorandr systemd services..."
    if systemctl list-unit-files | grep -q autorandr.service; then
        if systemctl enable --now autorandr.service; then
            echo "    autorandr.service has been enabled and started."
        else
            echo "    WARNING: Failed to enable/start autorandr.service."
        fi
        if systemctl list-unit-files | grep -q autorandr-resume.service; then
            if systemctl enable --now autorandr-resume.service; then
                echo "    autorandr-resume.service has been enabled and started."
            else
                echo "    WARNING: Failed to enable/start autorandr-resume.service."
            fi
        fi
    else
        echo "    WARNING: autorandr.service not found. This is unexpected for the Debian Bullseye package."
        echo "    Automatic hotplug detection via systemd might not function as described."
    fi

    ensure_config_dir # Ensure ~/Desktop/01-document/dotfiles/debian_display_master exists
    date > "$PREP_DONE_FLAG" # Create/update the flag file
    echo "    System preparation completion marker set in $PREP_DONE_FLAG"
    echo ">>> One-time system preparation script finished."
    echo "    Please REBOOT if you made changes like GPU memory configuration or if prompted by package installations."
    echo "    Next, proceed to 'Collect Monitor Information'."
    return 0
}

# --- Stage 2: Collect Monitor Information (from bash2.sh) ---
run_monitor_info_collection() {
    echo
    echo "--- Stage 2: Collect Monitor Information ---"
    echo "This step gathers detailed information about your connected monitors."
    echo "Full details (e.g., from ddcutil, get-edid) require running this script with 'sudo'."

    # --- Helper functions from bash2.sh, scoped locally ---
    _mi_check_privileges_for_tool() {
        local tool_name="$1"
        if [[ $EUID -ne 0 ]]; then
            echo "INFO: '$tool_name' provides more details or requires root. Running with limited privileges or skipping."
            return 1 # False (not root)
        fi
        return 0 # True (is root)
    }

    _mi_install_tools_explicit_check() {
      local missing_pkgs=""
      for pkg in read-edid ddcutil hwinfo inxi lshw x11-xserver-utils edid-decode bc; do
        if ! dpkg -s "$pkg" &> /dev/null; then
          missing_pkgs="$missing_pkgs $pkg"
        fi
      done
      if [[ -n "$missing_pkgs" ]]; then
        echo "WARNING: Some required packages are missing:$missing_pkgs" >&2
        echo "    Please run 'Stage 1: System Preparation' or 'sudo apt install$missing_pkgs'" >&2
        return 1
      fi
      return 0
    }

    local CURRENT_OUTDIR # Local to this function call
    _mi_setup_outdir() {
      local REAL_USER_EFFECTIVE NON_ROOT_HOME OUTDIR_BASE
      # Determine the non-root user if sudo was used
      if [[ $EUID -eq 0 && -n "$SUDO_USER" && "$SUDO_USER" != "root" ]]; then
          REAL_USER_EFFECTIVE="$SUDO_USER"
      else
          REAL_USER_EFFECTIVE=$(whoami) # Current effective user
      fi

      NON_ROOT_HOME=$(getent passwd "$REAL_USER_EFFECTIVE" | cut -d: -f6)

      if [[ -n "$NON_ROOT_HOME" && -d "$NON_ROOT_HOME" ]]; then
        OUTDIR_BASE="$NON_ROOT_HOME"
      else # Fallback if home not found or current user is root without SUDO_USER context
        OUTDIR_BASE="/tmp"
        echo "Warning: Could not determine a standard user home directory. Using $OUTDIR_BASE."
      fi
      
      CURRENT_OUTDIR="${OUTDIR_BASE}/monitor-info-$(date +%Y%m%d-%H%M%S)"
      if mkdir -p "$CURRENT_OUTDIR"; then
          echo "    Monitor information output directory: $CURRENT_OUTDIR"
          MONITOR_INFO_OUTDIR="$CURRENT_OUTDIR" # Assign to global
          # Ensure the original user can access it if created by root in their home
          if [[ $EUID -eq 0 && -n "$SUDO_USER" && "$OUTDIR_BASE" == "$(getent passwd "$SUDO_USER" | cut -d: -f6)" ]]; then
            chown -R "$SUDO_USER:$(id -gn "$SUDO_USER")" "$CURRENT_OUTDIR" || echo "    Warning: Could not chown $CURRENT_OUTDIR to $SUDO_USER"
          fi
          # Create summary.txt initially so tee -a works correctly
          touch "$MONITOR_INFO_OUTDIR/summary.txt"
          if [[ $EUID -eq 0 && -n "$SUDO_USER" ]]; then
              chown "$SUDO_USER:$(id -gn "$SUDO_USER")" "$MONITOR_INFO_OUTDIR/summary.txt" 2>/dev/null || true
          fi
      else
          echo "ERROR: Could not create output directory $CURRENT_OUTDIR. Please check permissions."
          MONITOR_INFO_OUTDIR=""
          return 1
      fi
      return 0
    }

    _mi_log_cmd() {
      local logfile="$1"; shift
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then echo "ERROR (log_cmd): MONITOR_INFO_OUTDIR not set."; return 1; fi
      {
        echo "===== $(date '+%F %T') : $* ====="
        "$@" 2>&1 || echo "(ERROR: '$*' failed with exit code $?)"
        echo
      } >>"$MONITOR_INFO_OUTDIR/$logfile"
    }

    local -a DRM_ALL DRM_EDID XRANDR_ALL XRANDR_CONNECTED # Local to this function call
    _mi_detect_connectors() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      DRM_ALL=() DRM_EDID=() XRANDR_ALL=() XRANDR_CONNECTED=()

      # Regex for connector names like HDMI-A-1, DP-1, eDP-1, DVI-D-1, LVDS-0 etc.
      # Matches: Prefix(letters) - Suffix(letters/numbers) - Number OR Prefix(letters) - Number
      local connector_regex='^[a-zA-Z]+(-[a-zA-Z0-9]+)*-[0-9]+$'

      for card_path in /sys/class/drm/card*; do
        if [[ -d "$card_path" ]]; then
            for path_in_card in "$card_path"/*; do
                local name
                name=$(basename "$path_in_card")
                if [[ -d "$path_in_card" && "$name" =~ $connector_regex ]]; then
                    DRM_ALL+=("$name")
                    if [[ -r "$path_in_card/edid" && -s "$path_in_card/edid" ]]; then
                        DRM_EDID+=("$name")
                    fi
                fi
            done
        fi
      done

      if command -v xrandr &> /dev/null && xhost >/dev/null 2>&1; then
        while IFS= read -r line; do
          local out
          out=$(awk '/ connected/{print $1} / disconnected/{print $1}' <<<"$line")
          [[ -n "$out" ]] && XRANDR_ALL+=("$out")
          [[ $line == *" connected"* ]] && XRANDR_CONNECTED+=("$out")
        done < <(xrandr 2>/dev/null)
      else
        echo "NOTE: xrandr queries skipped (X server not accessible or xrandr not found)." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
      fi

      {
        echo "All DRM connectors found: ${DRM_ALL[*]:-none}"
        echo "DRM connectors with readable EDID: ${DRM_EDID[*]:-none}"
        echo "xrandr outputs (if X session active): ${XRANDR_ALL[*]:-none}"
        echo "Connected outputs via xrandr (if X session active): ${XRANDR_CONNECTED[*]:-none}"
      } | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
    }

    _mi_collect_sysfs_edid() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      if ! command -v parse-edid &> /dev/null && ! command -v edid-decode &> /dev/null; then
        echo "Skipping sysfs EDID parsing: neither parse-edid nor edid-decode found." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
        return
      fi
      local parser_cmd
      parser_cmd=$(command -v edid-decode || command -v parse-edid)

      for CON_BASENAME in "${DRM_EDID[@]}"; do
        local edid_path=""
        for card_path in /sys/class/drm/card*; do # Find the card parent
            if [[ -e "$card_path/$CON_BASENAME/edid" ]]; then
                edid_path="$card_path/$CON_BASENAME/edid"
                break
            fi
        done
        if [[ -n "$edid_path" && -r "$edid_path" ]]; then
            _mi_log_cmd "edid_sysfs_${CON_BASENAME}.log" "$parser_cmd" <"$edid_path"
        else
            echo "Could not read sysfs EDID for $CON_BASENAME (path: $edid_path or not found)" | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
        fi
      done
    }

    _mi_collect_getedid() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      if ! _mi_check_privileges_for_tool "get-edid"; then return; fi
      if ! command -v get-edid &> /dev/null; then
        echo "Skipping get-edid: command not found." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
        return
      fi
      if ! command -v parse-edid &> /dev/null && ! command -v edid-decode &> /dev/null; then
        echo "Skipping get-edid parsing: no EDID parser found." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
        return
      fi
      local parser_cmd
      parser_cmd=$(command -v edid-decode || command -v parse-edid)

      if ! lsmod | grep -q "i2c_dev"; then
        echo "INFO: i2c_dev module not loaded. get-edid might fail. Consider 'sudo modprobe i2c_dev'." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
      fi
      _mi_log_cmd "edid_getedid.log" bash -c "get-edid 2>/dev/null | $parser_cmd"
    }

    _mi_collect_ddc() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      if ! _mi_check_privileges_for_tool "ddcutil"; then return; fi
      if ! command -v ddcutil &> /dev/null; then
        echo "Skipping ddcutil: command not found." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
        return
      fi
      if ! lsmod | grep -q "i2c_dev"; then
        echo "INFO: i2c_dev module not loaded. ddcutil might fail. Consider 'sudo modprobe i2c_dev'." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
      fi
      _mi_log_cmd "ddcutil_detect.log" ddcutil detect --verbose
    }

    _mi_collect_general_info() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      if command -v xrandr &> /dev/null && xhost >/dev/null 2>&1; then
        _mi_log_cmd "xrandr_verbose.log" xrandr --verbose
      fi
      
      # hwinfo, inxi, lshw can provide more with root
      local sudo_prefix=""
      if [[ $EUID -ne 0 ]]; then
          echo "INFO: hwinfo, inxi, lshw provide more details with root privileges."
          # Not prompting for sudo here, rely on script being run with sudo if full details desired.
      else
          sudo_prefix="" # Already root
      fi

      command -v hwinfo &> /dev/null && _mi_log_cmd "hwinfo_monitor.log" ${sudo_prefix} hwinfo --monitor --verbose
      command -v inxi &> /dev/null && _mi_log_cmd "inxi_Gxx.log" ${sudo_prefix} inxi -Gxx --display
      command -v lshw &> /dev/null && _mi_log_cmd "lshw_display.log" ${sudo_prefix} lshw -C display -sanitize
    }

    _mi_collect_udev() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      for CON_BASENAME in "${DRM_ALL[@]}"; do
        local sys_path=""
        for card_path in /sys/class/drm/card*; do
            if [[ -d "$card_path/$CON_BASENAME" ]]; then
                sys_path="$card_path/$CON_BASENAME"
                break
            fi
        done
        if [[ -n "$sys_path" && -e "$sys_path" ]]; then
            _mi_log_cmd "udevadm_${CON_BASENAME}.log" udevadm info --query=all --path="$(readlink -f "$sys_path")"
        fi
      done
    }

    _mi_generate_cvt_interactive() {
      if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then return 1; fi
      if ! command -v cvt &> /dev/null; then
        echo "Skipping CVT modeline generation: cvt command not found (part of x11-xserver-utils)." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
        return
      fi
      
      local W H R
      echo
      read -rp "Enter 'width height refresh' (e.g. 1920 1080 60) to generate a CVT modeline, or ENTER to skip: " W H R
      if [[ -z "$W" || -z "$H" || -z "$R" ]]; then
        echo "Skipping CVT modeline generation by user request."
        return
      fi

      if ! [[ "$W" =~ ^[0-9]+$ && "$H" =~ ^[0-9]+$ && "$R" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
          echo "Invalid input for width, height, or refresh. Please use numbers." | tee -a "$MONITOR_INFO_OUTDIR/summary.txt"
          return
      fi

      local MODELINE_FULL MODELINE_PARAMS NAME
      MODELINE_FULL=$(cvt "$W" "$H" "$R" 2>/dev/null | grep Modeline)

      if [[ -n "$MODELINE_FULL" ]]; then
        # Extract the part after "Modeline "
        MODELINE_PARAMS_WITH_NAME=$(echo "$MODELINE_FULL" | sed 's/Modeline //')
        # Extract just the name (e.g., "1920x1080_60.00")
        NAME=$(echo "$MODELINE_PARAMS_WITH_NAME" | awk '{print $1}' | tr -d '"')
        # Extract parameters after the name
        MODELINE_PARAMS=$(echo "$MODELINE_PARAMS_WITH_NAME" | sed 's/^"[^"]*" //')

        echo "Generated Modeline: $MODELINE_FULL" | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
        echo "  Mode Name for xrandr: $NAME" | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
        echo "  Parameters for xrandr --newmode: $MODELINE_PARAMS" | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
        echo "This modeline string can be used in your custom Xrandr script (Stage 3)."

        # Optional immediate test if in X session
        if command -v xrandr &> /dev/null && xhost >/dev/null 2>&1; then
            local TARGET
            if [[ ${#XRANDR_CONNECTED[@]} -gt 0 ]]; then TARGET=${XRANDR_CONNECTED[0]}; fi
            
            if [[ -n "$TARGET" ]]; then
                read -rp "Attempt to temporarily apply this new mode '$NAME' to '$TARGET' for testing? (y/N): " APPLY_CVT
                if [[ "$APPLY_CVT" =~ ^[Yy]$ ]]; then
                  echo "Applying: xrandr --newmode \"$NAME\" $MODELINE_PARAMS" | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
                  if xrandr --newmode "$NAME" $MODELINE_PARAMS; then
                    echo "Applying: xrandr --addmode \"$TARGET\" \"$NAME\"" | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
                    if xrandr --addmode "$TARGET" "$NAME"; then
                      echo "Mode '$NAME' added to '$TARGET'. To activate it now (temporarily): xrandr --output \"$TARGET\" --mode \"$NAME\"" | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
                    else echo "ERROR: xrandr --addmode failed." | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"; fi
                  else echo "ERROR: xrandr --newmode failed (mode might already exist or be invalid)." | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"; fi
                fi
            fi
        else
            echo "    (X session not active or xrandr not found for immediate mode application test)."
        fi
      else
        echo "ERROR: Failed to generate modeline with cvt $W $H $R." | tee -a "$MONITOR_INFO_OUTDIR/cvt_modeline.log"
      fi
    }

    # --- Main execution for monitor info collection ---
    if ! _mi_install_tools_explicit_check; then
        echo "Monitor info collection cannot proceed due to missing tools."
        return 1
    fi
    if ! _mi_setup_outdir; then # Sets MONITOR_INFO_OUTDIR
        return 1 # Error message already printed by _mi_setup_outdir
    fi
    
    echo "    Collecting information. This may take a few moments..."
    _mi_detect_connectors
    _mi_collect_sysfs_edid
    _mi_collect_getedid
    _mi_collect_ddc
    _mi_collect_general_info
    _mi_collect_udev
    _mi_generate_cvt_interactive

    echo
    echo "    Monitor information collection Done."
    echo "    Review logs and summary.txt in: $MONITOR_INFO_OUTDIR"
    echo "    Key information for the next steps (connector names, modelines) can be found there."
    return 0
}

# --- Stage 3: Create/Edit Custom Xrandr Configuration Script (from bash4.sh template) ---
edit_xrandr_template_config() {
    echo
    echo "--- Stage 3: Create/Edit Custom Xrandr Configuration Script ---"
    echo "This step will help you create a custom script to configure your displays."
    echo "It uses a template based on 'bash4.sh' (a reference script)."
    echo "Your custom script will be saved at: $CUSTOM_XRANDR_SCRIPT_PATH"

    if [[ -z "$MONITOR_INFO_OUTDIR" ]]; then
        echo "Warning: Monitor information doesn't seem to have been collected in this session."
        echo "    You may need to run 'Collect Monitor Information' first to get necessary details."
        read -rp "Proceed to create/edit template anyway? (y/N): " proceed_warn
        if [[ ! "$proceed_warn" =~ ^[Yy]$ ]]; then
            return
        fi
    else
        echo "    Refer to the information collected in: $MONITOR_INFO_OUTDIR"
    fi

    if [[ ! -f "$CUSTOM_XRANDR_SCRIPT_PATH" ]]; then
        echo "    Creating template script at $CUSTOM_XRANDR_SCRIPT_PATH..."
        # Heredoc for bash4.sh content, adapted
        cat > "$CUSTOM_XRANDR_SCRIPT_PATH" << 'EOF_XRANDR_CONFIG_TEMPLATE'
#!/bin/bash

# Custom Xrandr Configuration Script
# EDIT THIS FILE with your specific monitor outputs, modelines, and layout.
# Use information from the 'monitor-info' collection step (Stage 2 of the master script).
#
# This script is intended to be run from an active X Window System session as your normal user.
# These settings will only apply to the current X session.
#
# After testing, you can use these commands to create an autorandr profile.

# Check if xrandr command is available
if ! command -v xrandr &> /dev/null; then
    echo "Error: xrandr command not found. Please ensure it is installed and in your PATH."
    exit 1
fi

# Check if bc command is available (for DPI calculations)
BC_AVAILABLE=false
if command -v bc &> /dev/null; then
    BC_AVAILABLE=true
else
    echo "Warning: bc command not found. DPI calculation will be skipped if enabled."
fi

echo "Applying custom temporary xrandr settings..."
echo "Verify your display identifiers (e.g., HDMI-1, DP-1) by running 'xrandr' in a terminal if unsure."

# --- USER CONFIGURATION SECTION ---
# TODO: Replace these with your actual values based on 'monitor-info' output and desired setup.

# Example for Display 1 (e.g., your primary laptop screen or main desktop monitor)
OUTPUT_1_NAME="eDP-1"      # e.g., DP-1, eDP-1, LVDS-1. Check 'xrandr' or monitor-info logs.
MODE_1_NAME="1920x1080" # e.g., 1920x1080_60.00 or just 1920x1080 if a standard mode.
                        # Get from monitor-info or 'xrandr' output for connected monitors.
# If using a custom CVT modeline:
# MODELINE_1_PARAMS="173.00  1920 2048 2248 2576  1080 1083 1088 1120 -hsync +vsync" # Paste parameters after mode name
MODELINE_1_PARAMS="" # Leave empty if using a standard, already known mode.

# Physical dimensions & DPI for OUTPUT_1 (Optional)
OUTPUT_1_PHYS_WIDTH_MM=344  # Physical width in mm (e.g., 344 for a 15.6" 16:9 display)
OUTPUT_1_PHYS_HEIGHT_MM=193 # Physical height in mm (e.g., 193 for a 15.6" 16:9 display)
OUTPUT_1_MODE_WIDTH_PX=1920 # Pixel width for MODE_1_NAME (e.g., 1920)
OUTPUT_1_MODE_HEIGHT_PX=1080 # Pixel height for MODE_1_NAME (e.g., 1080)
OUTPUT_1_CALCULATE_DPI=false # Set to true to attempt DPI calculation for this.

# Example for Display 2 (e.g., an external HDMI monitor) - uncomment and configure if you have one
# OUTPUT_2_NAME="HDMI-1"
# MODE_2_NAME="1920x1080"
# MODELINE_2_PARAMS=""
# OUTPUT_2_PHYS_WIDTH_MM=527
# OUTPUT_2_PHYS_HEIGHT_MM=296
# OUTPUT_2_MODE_WIDTH_PX=1920
# OUTPUT_2_MODE_HEIGHT_PX=1080
# OUTPUT_2_CALCULATE_DPI=false

# --- Layout Command ---
# TODO: Customize this xrandr command thoroughly! This defines how your monitors are arranged.
#       Refer to 'man xrandr' for options like --pos, --left-of, --right-of, --above, --below, --primary, --rotate.
# Example 1: Single monitor (Output 1 is primary)
# XRANDR_CMD_ARGS=(--output "$OUTPUT_1_NAME" --mode "$MODE_1_NAME" --primary --auto)

# Example 2: Dual monitor - Output 2 (HDMI) right of Output 1 (eDP), Output 1 is primary
# Ensure OUTPUT_2_NAME and MODE_2_NAME are set above if using this.
# XRANDR_CMD_ARGS=(
#    --output "$OUTPUT_1_NAME" --mode "$MODE_1_NAME" --primary
#    --output "$OUTPUT_2_NAME" --mode "$MODE_2_NAME" --right-of "$OUTPUT_1_NAME" --auto
# )

# Example 3: Mirroring Output 1 to Output 2
# XRANDR_CMD_ARGS=(
#    --output "$OUTPUT_1_NAME" --mode "$MODE_1_NAME" --primary
#    --output "$OUTPUT_2_NAME" --mode "$MODE_1_NAME" --same-as "$OUTPUT_1_NAME"
# )

# Default placeholder: Output 1, auto mode, primary. MUST BE EDITED FOR YOUR SETUP.
XRANDR_CMD_ARGS=(--output "$OUTPUT_1_NAME" --auto --primary)

# --- END OF USER CONFIGURATION SECTION ---


# --- Script Logic (Generally no need to edit below this line) ---

# Define New Modes (if modelines are provided)
echo ""
if [[ -n "$OUTPUT_1_NAME" && -n "$MODE_1_NAME" && -n "$MODELINE_1_PARAMS" ]]; then
    echo "Defining new mode for $OUTPUT_1_NAME: $MODE_1_NAME"
    xrandr --newmode "$MODE_1_NAME" $MODELINE_1_PARAMS
    if [ $? -ne 0 ]; then
        echo "Warning: Could not define mode $MODE_1_NAME. It might already exist or modeline is invalid."
    fi
fi

if [[ -n "${OUTPUT_2_NAME:-}" && -n "${MODE_2_NAME:-}" && -n "${MODELINE_2_PARAMS:-}" ]]; then
    echo "Defining new mode for $OUTPUT_2_NAME: $MODE_2_NAME"
    xrandr --newmode "$MODE_2_NAME" $MODELINE_2_PARAMS
    if [ $? -ne 0 ]; then
        echo "Warning: Could not define mode $MODE_2_NAME. It might already exist or modeline is invalid."
    fi
fi

# Check current connection status of configured displays
echo ""
echo "Checking configured display connection status..."
IS_OUTPUT_1_CONNECTED=false
if [[ -n "$OUTPUT_1_NAME" ]] && xrandr | grep -q "^${OUTPUT_1_NAME}\s*connected"; then
    IS_OUTPUT_1_CONNECTED=true
    echo "- $OUTPUT_1_NAME is detected as connected."
else
    if [[ -n "$OUTPUT_1_NAME" ]]; then echo "- $OUTPUT_1_NAME is NOT configured or detected as disconnected."; fi
fi

IS_OUTPUT_2_CONNECTED=false
if [[ -n "${OUTPUT_2_NAME:-}" ]] && xrandr | grep -q "^${OUTPUT_2_NAME}\s*connected"; then
    IS_OUTPUT_2_CONNECTED=true
    echo "- $OUTPUT_2_NAME is detected as connected."
else
    if [[ -n "${OUTPUT_2_NAME:-}" ]]; then echo "- $OUTPUT_2_NAME is NOT configured or detected as disconnected."; fi
fi

# Add modes to outputs (if defined and modelines were used)
if [[ -n "$OUTPUT_1_NAME" && -n "$MODE_1_NAME" && -n "$MODELINE_1_PARAMS" && "$IS_OUTPUT_1_CONNECTED" == "true" ]]; then
    echo "Adding mode $MODE_1_NAME to $OUTPUT_1_NAME"
    xrandr --addmode "$OUTPUT_1_NAME" "$MODE_1_NAME"
    if [ $? -ne 0 ]; then echo "Warning: Could not add mode $MODE_1_NAME to $OUTPUT_1_NAME."; fi
fi
if [[ -n "${OUTPUT_2_NAME:-}" && -n "${MODE_2_NAME:-}" && -n "${MODELINE_2_PARAMS:-}" && "$IS_OUTPUT_2_CONNECTED" == "true" ]]; then
    echo "Adding mode $MODE_2_NAME to $OUTPUT_2_NAME"
    xrandr --addmode "$OUTPUT_2_NAME" "$MODE_2_NAME"
    if [ $? -ne 0 ]; then echo "Warning: Could not add mode $MODE_2_NAME to $OUTPUT_2_NAME."; fi
fi

# Apply Main Layout Command
echo ""
echo "Attempting to apply layout: xrandr ${XRANDR_CMD_ARGS[*]}"
if xrandr "${XRANDR_CMD_ARGS[@]}"; then
    echo "Successfully applied layout."
else
    echo "ERROR: Failed to apply layout command: xrandr ${XRANDR_CMD_ARGS[*]}"
    echo "Please check your XRANDR_CMD_ARGS, output names, and modes."
    exit 1
fi

# DPI Calculation
TARGET_DPI_OUTPUT_NAME=""
TARGET_DPI_MODE_WIDTH_PX=0
TARGET_DPI_MODE_HEIGHT_PX=0
TARGET_DPI_PHYS_WIDTH_MM=0
TARGET_DPI_PHYS_HEIGHT_MM=0

if [[ "$OUTPUT_1_CALCULATE_DPI" == "true" && "$IS_OUTPUT_1_CONNECTED" == "true" ]]; then
    TARGET_DPI_OUTPUT_NAME="$OUTPUT_1_NAME"
    TARGET_DPI_MODE_WIDTH_PX=$OUTPUT_1_MODE_WIDTH_PX
    TARGET_DPI_MODE_HEIGHT_PX=$OUTPUT_1_MODE_HEIGHT_PX
    TARGET_DPI_PHYS_WIDTH_MM=$OUTPUT_1_PHYS_WIDTH_MM
    TARGET_DPI_PHYS_HEIGHT_MM=$OUTPUT_1_PHYS_HEIGHT_MM
elif [[ "${OUTPUT_2_CALCULATE_DPI:-false}" == "true" && "$IS_OUTPUT_2_CONNECTED" == "true" ]]; then
    TARGET_DPI_OUTPUT_NAME="$OUTPUT_2_NAME"
    TARGET_DPI_MODE_WIDTH_PX=$OUTPUT_2_MODE_WIDTH_PX
    TARGET_DPI_MODE_HEIGHT_PX=$OUTPUT_2_MODE_HEIGHT_PX
    TARGET_DPI_PHYS_WIDTH_MM=$OUTPUT_2_PHYS_WIDTH_MM
    TARGET_DPI_PHYS_HEIGHT_MM=$OUTPUT_2_PHYS_HEIGHT_MM
fi

if [[ -n "$TARGET_DPI_OUTPUT_NAME" && "$BC_AVAILABLE" == "true" ]]; then
    echo ""
    echo "Attempting DPI calculation for $TARGET_DPI_OUTPUT_NAME."
    if [ "$TARGET_DPI_PHYS_WIDTH_MM" -gt 0 ] && [ "$TARGET_DPI_PHYS_HEIGHT_MM" -gt 0 ] && \
       [ "$TARGET_DPI_MODE_WIDTH_PX" -gt 0 ] && [ "$TARGET_DPI_MODE_HEIGHT_PX" -gt 0 ]; then
        
        DPI_H_CALC=$(bc -l <<< "scale=2; $TARGET_DPI_MODE_WIDTH_PX / ($TARGET_DPI_PHYS_WIDTH_MM / 25.4)")
        DPI_V_CALC=$(bc -l <<< "scale=2; $TARGET_DPI_MODE_HEIGHT_PX / ($TARGET_DPI_PHYS_HEIGHT_MM / 25.4)")

        if [[ "$DPI_H_CALC" =~ ^[0-9]+([.][0-9]+)?$ && "$DPI_V_CALC" =~ ^[0-9]+([.][0-9]+)?$ ]]; then
            AVG_DPI=$(printf "%.0f" "$(bc -l <<< "($DPI_H_CALC + $DPI_V_CALC) / 2")")
            echo "Calculated average DPI for $TARGET_DPI_OUTPUT_NAME: $AVG_DPI (H: $DPI_H_CALC, V: $DPI_V_CALC)"
            echo "Attempting to set screen DPI to $AVG_DPI..."
            if xrandr --dpi "$AVG_DPI"; then
                echo "Screen DPI successfully set to $AVG_DPI. This may improve font rendering."
            else
                echo "Warning: Could not set screen DPI to $AVG_DPI. Your X server or driver might not support this, or the value might be out of range."
            fi
        else
            echo "Warning: DPI calculation failed or produced non-numeric results (H: $DPI_H_CALC, V: $DPI_V_CALC). Skipping DPI setting."
        fi
    else
        echo "Warning: Physical dimensions or mode resolution for $TARGET_DPI_OUTPUT_NAME are zero or invalid. Cannot calculate DPI."
    fi
elif [[ -n "$TARGET_DPI_OUTPUT_NAME" && "$BC_AVAILABLE" == "false" ]]; then
    echo "DPI calculation for $TARGET_DPI_OUTPUT_NAME skipped: 'bc' command not available."
fi

echo ""
echo "Custom temporary xrandr settings applied (or attempted)."
echo "Current screen configuration (relevant connected displays):"
xrandr | grep " connected" || echo "(xrandr found no connected displays or xrandr command failed)"

echo ""
echo "If this configuration is correct, you can save it as an autorandr profile (Stage 5 of master script)."
echo "If you encounter issues, please check:"
echo "1. Your display output names and modes in the USER CONFIGURATION SECTION are correct."
echo "2. Your displays are properly connected and powered on."
echo "3. The modelines (if used) are compatible with your hardware."
echo "4. Review any error messages above from xrandr."
echo "5. If DPI was set, verify with 'xdpyinfo | grep resolution'."

exit 0
EOF_XRANDR_CONFIG_TEMPLATE
        chmod +x "$CUSTOM_XRANDR_SCRIPT_PATH"
    else
        echo "    Existing script found at $CUSTOM_XRANDR_SCRIPT_PATH."
    fi

    echo ""
    echo "    Please EDIT the script '$CUSTOM_XRANDR_SCRIPT_PATH' with your specific display settings."
    echo "    You will need to set:"
    echo "      - OUTPUT_1_NAME, MODE_1_NAME, MODELINE_1_PARAMS (if using custom modeline)"
    echo "      - Physical dimensions (e.g., OUTPUT_1_PHYS_WIDTH_MM) and OUTPUT_1_CALCULATE_DPI if you want DPI calculation."
    echo "      - Configure OUTPUT_2 variables if you have a second display."
    echo "      - Most importantly, customize the XRANDR_CMD_ARGS array with your full layout command."
    echo ""
    if [[ -n "$MONITOR_INFO_OUTDIR" ]]; then
        echo "    Refer to monitor information collected in: $MONITOR_INFO_OUTDIR"
    fi
    
    read -rp "Would you like to open '$CUSTOM_XRANDR_SCRIPT_PATH' with 'nano' now? (y/N): " edit_now
    if [[ "$edit_now" =~ ^[Yy]$ ]]; then
        if command -v nano &> /dev/null; then
            nano "$CUSTOM_XRANDR_SCRIPT_PATH"
        else
            echo "'nano' not found. Please edit the file manually using your preferred editor (e.g., vim, gedit, code)."
        fi
    else
        echo "Please edit '$CUSTOM_XRANDR_SCRIPT_PATH' manually."
    fi
    echo "    After editing, proceed to 'Test Custom Xrandr Configuration'."
}

# --- Stage 4: Test Custom Xrandr Configuration (runs the edited script) ---
test_custom_xrandr_config() {
    echo
    echo "--- Stage 4: Test Custom Xrandr Configuration ---"
    echo "This step executes your custom script to apply display settings temporarily."

    if [[ ! -f "$CUSTOM_XRANDR_SCRIPT_PATH" ]]; then
        echo "Custom configuration script '$CUSTOM_XRANDR_SCRIPT_PATH' not found."
        echo "    Please run 'Stage 3: Create/Edit Custom Xrandr Configuration Script' first."
        return 1
    fi

    if [[ -z "$DISPLAY" ]]; then
        echo "ERROR: No X session detected (DISPLAY variable is not set)."
        echo "    This step MUST be run from within an active X Window System session"
        echo "    (e.g., from a terminal emulator in your desktop environment) as your normal user."
        return 1
    fi
    if ! xhost >/dev/null 2>&1; then # A simple check to see if X server is accessible
        echo "ERROR: Cannot connect to X server. Ensure you are in an active X session."
        return 1
    fi
    if [[ $EUID -eq 0 ]]; then
        echo "WARNING: It's recommended to run this test as your normal desktop user, not as root."
        read -rp "Continue as root anyway? (y/N): " continue_root_test
        if [[ ! "$continue_root_test" =~ ^[Yy]$ ]]; then return 1; fi
    fi


    echo "    You are about to execute the script: $CUSTOM_XRANDR_SCRIPT_PATH"
    echo "    This will attempt to change your current display settings."
    echo "    Ensure you have saved any important work."
    echo "    Know how to recover if the display becomes unusable:"
    echo "      - Switch to a TTY (Ctrl+Alt+F2 through F6)."
    echo "      - Log in, then you can try 'sudo systemctl restart display-manager' or 'sudo reboot'."
    echo "      - Or, from TTY, try 'export DISPLAY=:0; xrandr --auto' (may need to find correct DISPLAY)."
    read -rp "Proceed with testing? (y/N): " confirm_test
    if [[ ! "$confirm_test" =~ ^[Yy]$ ]]; then
        echo "Testing aborted."
        return
    fi

    echo "    Executing '$CUSTOM_XRANDR_SCRIPT_PATH'..."
    if bash "$CUSTOM_XRANDR_SCRIPT_PATH"; then
        echo "    Custom Xrandr script executed successfully."
    else
        echo "    Custom Xrandr script executed with an error (exit code $?)."
    fi

    echo ""
    echo "    Test execution finished."
    echo "    If the display configuration is as expected, you can proceed to save it as an autorandr profile."
    echo "    If not, re-edit '$CUSTOM_XRANDR_SCRIPT_PATH' and test again."
}

# --- Stage 5: Autorandr Profile Management ---
save_autorandr_profile() {
    echo
    echo "--- Stage 5a: Save Current Configuration as Autorandr Profile ---"
    echo "This saves your current Xrandr display configuration as an autorandr profile."

    if [[ -z "$DISPLAY" ]]; then echo "ERROR: No X session detected. Must be run from an active X session."; return 1; fi
    if [[ $EUID -eq 0 ]]; then echo "WARNING: Saving autorandr profiles is typically done as the desktop user."; fi
    if ! command -v autorandr &> /dev/null; then
        echo "ERROR: autorandr command not found. Please run Stage 1 (System Preparation)."
        return 1
    fi

    echo "    Ensure your displays are configured exactly as you want them"
    echo "    (e.g., after a successful test in Stage 4)."
    
    local current_profile
    current_profile=$(autorandr --current 2>/dev/null)
    if [[ -n "$current_profile" ]]; then
        echo "    Current detected autorandr profile: $current_profile"
    else
        echo "    No specific autorandr profile currently detected as active (or multiple match)."
    fi

    read -rp "Enter a name for this new autorandr profile (e.g., 'home_dual_monitor', 'laptop_only'): " profile_name
    if [[ -z "$profile_name" ]]; then
        echo "No profile name entered. Aborting save."
        return
    fi

    # Sanitize profile name (basic: replace spaces and special chars with underscore)
    profile_name=$(echo "$profile_name" | tr -s ' /\\:&?' '_')

    echo "    Saving current configuration as profile: '$profile_name'..."
    if autorandr --save "$profile_name"; then
        echo "    Profile '$profile_name' saved successfully."
        echo "    Autorandr should now automatically apply this profile when this display setup is detected"
        echo "    (assuming autorandr services are running from Stage 1)."
    else
        echo "ERROR: Failed to save autorandr profile '$profile_name'."
    fi
}

view_autorandr_profiles() {
    echo
    echo "--- Stage 5b: View Autorandr Profiles ---"
    if ! command -v autorandr &> /dev/null; then
        echo "ERROR: autorandr command not found. Please run Stage 1 (System Preparation)."
        return 1
    fi
    echo "    Available autorandr profiles:"
    autorandr --list
    local current_profile
    current_profile=$(autorandr --current 2>/dev/null)
     if [[ -n "$current_profile" ]]; then
        echo "    Currently active/detected profile(s): $current_profile"
    fi
}

load_autorandr_profile() {
    echo
    echo "--- Stage 5c: Load Autorandr Profile ---"
    echo "This attempts to load a saved autorandr profile."

    if [[ -z "$DISPLAY" ]]; then echo "ERROR: No X session detected. Must be run from an active X session."; return 1; fi
    if [[ $EUID -eq 0 ]]; then echo "WARNING: Loading autorandr profiles is typically done as the desktop user."; fi
    if ! command -v autorandr &> /dev/null; then
        echo "ERROR: autorandr command not found. Please run Stage 1 (System Preparation)."
        return 1
    fi

    echo "    Available profiles:"
    autorandr --list
    read -rp "Enter the name of the profile to load: " profile_to_load
    if [[ -z "$profile_to_load" ]]; then
        echo "No profile name entered. Aborting."
        return
    fi

    echo "    Attempting to load profile '$profile_to_load'..."
    # Using --change is often preferred as it only applies if the detected setup matches the profile.
    # --load or --force --load will apply it regardless.
    if autorandr --change "$profile_to_load"; then
        echo "    Profile '$profile_to_load' loaded/applied (if it matched current hardware or was forced by --change)."
        echo "    If it didn't change, it might be already active or not match. Try 'autorandr --force --load $profile_to_load'."
    else
        echo "ERROR: Failed to load/apply autorandr profile '$profile_to_load' with --change."
        echo "    Try 'autorandr --load $profile_to_load' or 'autorandr --force --load $profile_to_load'."
    fi
}


# --- Main Menu ---
main_menu() {
    ensure_config_dir # Create ~/Desktop/01-document/dotfiles/debian_display_master if it doesn't exist
    echo
    echo "Debian Bullseye Display Setup & Management Utility"
    echo "=================================================="
    echo "IMPORTANT: Read script header and option notes for SUDO/X Session requirements."
    echo

    PS3="Please choose an option: "
    options=(
        "1. Run ONE-TIME System Preparation (MUST RUN SCRIPT WITH SUDO)"
        "2. Collect Monitor Information (NEEDS ROOT FOR FULL DETAILS)"
        "3. Create/Edit Custom Xrandr Configuration Script (RUN AS USER)"
        "4. Test Custom Xrandr Configuration (RUN IN X SESSION AS USER)"
        "5. Save Current Configuration as Autorandr Profile (RUN IN X SESSION AS USER)"
        "6. View Autorandr Profiles (RUN AS USER)"
        "7. Load Autorandr Profile (RUN IN X SESSION AS USER)"
        "8. Exit"
    )
    COLUMNS=1 # For select formatting
    select optk in "${!options[@]}"; do # Iterate over keys for robust option handling
        local opt_text=${options[$optk]}
        local opt_num=$((optk + 1))

        case $opt_num in
            1) run_system_preparation ;;
            2) run_monitor_info_collection ;;
            3) edit_xrandr_template_config ;;
            4) test_custom_xrandr_config ;;
            5) save_autorandr_profile ;;
            6) view_autorandr_profiles ;;
            7) load_autorandr_profile ;;
            8) echo "Exiting."; exit 0 ;;
            *) echo "Invalid option $REPLY. Please choose a number from 1 to 8.";;
        esac
        # Prompt to continue after each action
        echo
        read -rp "Press Enter to return to the menu..."
        # Re-display menu
        echo
        echo "Debian Bullseye Display Setup & Management Utility"
        echo "=================================================="
        echo "IMPORTANT: Read script header and option notes for SUDO/X Session requirements."
        echo
    done
}

# --- Script Entry Point ---
main_menu

exit 0
{% endcodeblock %}
~~~~
===

-----
````````
---
tags: [scratchpad]
info: aberto.
date: 2025-05-26
type: post
layout: post
published: true
slug: x
title: 'X'
---
## INSTALLING X
Generally it can be installed from the live _CD or DVD_ or afterwards with the package manager. For example on __CRUX__:
* Installing a minimal set of xorg and xorg dependent tools one by one (you must know which _"DRIVER"_ you use)  
`prtget depinst xorg-server xorg-xf86-video-<DRIVER> xorg-font-util xkeyboard-config xorg-xinit`  
* Alternatively just install the metapackage _"xorg"_  

## CONFIGURING X
__X__ can be configured for several things.

__OPTION 1__  
You can generate a general configuration file containing all sorts of options and that will appear on your home directory and later move it to _"/etc/X11/xorg.conf"_. You need to stop the __X__ server and have root privileges for creating it.  
* Create a new configuration file "xorg.conf.new"  
`Xorg -configure`  
* change it to _"/etc/X11/xorg.conf"_  
`mv /path/to/xorg.conf.new /etc/X11/xorg.conf`  
* on other X versions the commands are  
`XFree86 -configure`  
`XFree86 -xf86config /etc/X11/XF86Config.new`  

__OPTION 2__  
Or you can create specific configuration files under the _"/etc/X11/xorg.conf.d/"_ directory for particular cases.

### SCREEN RESOLUTION
To make changes you generally don't need to know supported resolutions but it helps using defaults.
* List currently supported resolutions (optional):  
`xrandr`  
* Generate a modeline:  
`cvt <WIDTH> <HEIGHT> <REFRESH_RATE>`  
* Use that ouput to add changes on the configuration file  _"/etc/X11/xorg.conf"_:  

```

Section "Device"
        Identifier   "<DEVICE_NAME>"
        Driver       "<DRIVER_NAME>"
EndSection

Section "Monitor"
        Identifier	"<MONITOR_NAME>"
        Modeline        "<CVT_OUTPUT>
        Option    	"PreferredMode" "<THE_RESOLUTION_YOU_WANT>"
        Option          "Enable" "True"
EndSection

Section "Screen"
        Identifier	"<DEFAULT_SCREEN>"
        Monitor   	"<MONITOR_NAME>"
        Device          "<DEVICE_NAME>"
   SubSection "Display"
      Modes	  "<RESOLUTION_YOU_WANT>"
   EndSubSection
EndSection

```
  
In _"Modes"_ the resolution you want can contain a framerate appended but needs to be exactly the same from the modeline. A full example configuration follows:  

```

Section "Device"
    Identifier    "Device0"
    Driver        "Intel"
EndSection

Section "Monitor"
    Identifier    "HDMI1"
    Modeline "1280x720_60.00"   74.50  1280 1344 1472 1664  720 723 728 748 -hsync +vsync
    Option "PreferredMode" "1280x720"
    Option "Enable" "True"
EndSection

Section "Screen"
    Identifier     "Screen0"
    Monitor        "HDMI1"
    Device         "Device0"
    SubSection "Display"
        Modes       "1280x720_60.00"
    EndSubSection
EndSection


```
  
Notice the framerate appended with an underscore in _"Mode"_, this comes from _"Modeline"_.

### SCREEN TEARING
To solve screen tearing you can use any of these config files in its appropriate directory.

* If you have Intel add these changes to _"/etc/X11/xorg.conf"_ or in the separate file _"/etc/X11/xorg.conf.d/20-intel.conf"_:

```

Section "Device"
   Identifier  "Intel Graphics"
   Driver      "intel"
   Option      "TearFree"  "true"
EndSection

```


* If you still have issues with Intel add a line with the option _UXA_:

```

Section "Device"
   Identifier  "Intel Graphics"
   Driver      "intel"
   Option      "AccelMethod"  "uxa"
   Option      "TearFree" "true"
EndSection

```


* If you have AMD add these changes to _"/etc/X11/xorg.conf"_ or in the separate file _"/etc/X11/xorg.conf.d/20-amdgpu.conf_":

```

Section "Device"
   Identifier  "AMD Graphics"
   Driver      "amdgpu"
   Option      "TearFree"  "true"
EndSection

```
  

## FONTS
There are two ways of adding fonts, with __Fontconfig__ or with __X__ core fonts. Make sure the fonts and the directory (and all of its parents) are world-readable:
* The directory needs appropriate permissions.  
`chmod 755 /path/to/fonts/`  
* The fonts need appropriate permissions.  
`chmod 644 /path/to/fonts/*`  
* If the fonts are global they need to be owned by root.  
`chown root:root /path/to/fonts/*`  

### CORE FONTS
The next deals with core fonts.
* Fonts can be added to the database on _"/etc/X11/xorg.conf"_ or in the separate file _"/etc/X11/xorg.conf.d/fonts.conf_".
* Supported font formats are _BDF_, binary _PCF_, and _SNF_.
* Scalable fonts must appear in the font path before the bitmap fonts when possible.
* You can query the current _font paths_ (along with other information) by using __xset__:  
`xset q`  
* To see the list of installed fonts:  
`xlsfonts`  
* All this works for cursors too.

__STEP 1__: Create a font directory with font files and index files.
* First you might need to correctly name scalable fonts by creating a _fonts.scale_ file in the directory:  
`mkfontscale /path/to/fonts/`  
* Next create a proper font index file _fonts.dir_ to list available fonts in this directory:  
`mkfontdir /path/to/fonts/`  
* The _fonts.alias_ provides aliases you can use and is manually created.

__STEP 2__: Inform __X__ where to look for font directories.
* Edit _"/etc/X11/xorg.conf"_ or in the separate file _"/etc/X11/xorg.conf.d/fonts.conf"_:  

```

Section "Files"
        FontPath     "/path/to/fonts/"
        FontPath     "/path/to/other/fonts/"
EndSection

```
  
Where _"/path/to/fonts/"_ can be the default _/usr/local/share/fonts/_, a directory under _/usr/local/share/fonts/_, or any directory of your choosing.  

__STEP 3__: Re-scan the font directories to apply new fonts.
* Either restart __X__ or reload using _xset_ to apply changes:  
`xset fp rehash`  

__TEMPORARY CHANGES (OPTIONAL)__  
You can add fonts temporarily.  
* Temporarily add fonts first on the list:  
`xset +fp /path/to/fonts`  
* Temporarily add fonts last on the list:  
`xset fp+ /path/to/fonts`  

__TRUETYPE FONTS__  
* To enable TrueType® fonts enable Freetype by adding the following line either to _"/etc/X11/xorg.conf"_ or in the separate file _"/etc/X11/xorg.conf.d/fonts.conf"_:  

```

Section "Module"
	Load  "freetype"
EndSection

```
  

### FONTCONFIG
The next deals with __Fontconfig__.

__ADDING FONTS__  
* Fonts added under:  
`/usr/share/fonts/`  
* or:  
`/usr/local/share/fonts/`  
* or locally under:  
`~/.fonts/`  
* are automatically added after updating __Fontconfig__.

__COMMANDS__  
* To list fonts:  
`fc-list`  
* To show an ordered list of fonts matching a certain name or pattern:  
`fc-match -s <NAME>`  
* To update the list of fonts:  
`fc-cache -fv`  
* To update an specific directory:  
`fc-cache /path/to/fonts/`  

__GLOBAL CONFIGURATION__  
* User generated system-wide changes are in:  
`/etc/fonts/local.conf`  
* or by replacing files under the directory:  
`/etc/fonts/conf.d/`  
* with symbolic links to files from:  
`/etc/fonts/conf.avail/`  

The system-wide configuration file _/etc/fonts/fonts.conf_ is generally not touched by the user.  

__LOCAL CONFIGURATION__  
* User-specific configuration file (can be overridden with the "FONTCONFIG_FILE" environment variable):  
`~/.fonts.conf`  
* or:  
`~/.config/fontconfig/fonts.conf`  
* or making symbolic links of files from:  
`/etc/fonts/conf.avail/`  
* to:  
`~/.config/fontconfig/conf.d/`  

__BITMAP FONTS__
The bitmap fonts may not be enabled by default on __FONTCONFIG__.  
* Remove current configuration:  
`rm /etc/fonts/conf.d/70-no-bitmaps.conf`  
* Create symbolic link to configuration enabling it:  
`ln -s /etc/fonts/conf.avail/70-yes-bitmaps.conf /etc/fonts/conf.d/70-yes-bitmaps.conf`  

## THEME
To tweak the theme of your terminal emulator you need to tweak the _".Xresources"_ file.

Next is an example _".Xresources"_ file which goes under your home directory:

```

xterm*maximized:	true
xterm*background:	black
xterm*foreground:	grey
xterm*cursorColor:	green
xterm*cursorBlink:	false
xterm*faceName:	Fixedsys Excelsior 3.01:size=11:antialias=true
xterm*faceNameDoublesize:	WenQuanYi Zen Hei
xterm*termName:	xterm-256color
xterm*locale:	true
xterm*utf8Title:	true
xterm*dynamicColors: true
xterm*borderWidth: 0
xterm*eightBitInput:   false
xterm*metaSendsEscape: true
xterm*decTerminalID:	vt340


urxvt*maximized:	true
urxvt*background:	black
urxvt*foreground:	white
urxvt*cursorColor:	green
urxvt*cursorBlink:	false
urxvt*faceName:	GNU Unifont:size=12:antialias=true
urxvt*faceNameDoublesize:	WenQuanYi Zen Hei
urxvt*termName:	urxvt-256color
urxvt*locale:	true
urxvt*utf8Title:	true
urxvt*font: fixed
urxvt*boldFont: fixed
urxvt*dynamicColors: true
urxvt*borderWidth: 0

```
  

To load changes run:  
`xrdb -merge ~/.Xresources`

## NO DE
To use a window manager without any desktop environment, or even a login manager, you can just install the applications mentioned here and edit the _".xinitrc"_ file with the appropriate changes and start _"X"_ from the command line. The required applications are:
* Ratpoison (or your preferred window manager in the _".xinitrc"_ file)
* Xbindkeys
* hsetroot or imagemagick (or replace with your preferred wallpaper changer in the _".xinitrc"_ file)
* ImageMagick (or replace with your preferred screenshot program in the _".xinitrc"_ file)
* FFmpeg or libav-tools (or replace with your preferred screencasting program in the _".xinitrc"_ file)
* UXTerm or urxvt (in the case you want to set the terminal emulator theme with the _".Xresources"_ file)
* dmenu

### XINITRC CONFIGURATION FILE
Next is an example _".xinitrc"_ file which goes under your home directory:  

```

# load your preferred terminal settings
xrdb -merge -I$HOME ~/.Xresources

# load your preferred keybindings
xbindkeys

# set the wallpaper (requires hsetroot to be installed)
hsetroot -fill ~/.wallpaper.jpg

# alternative way to set the wallpaper using imagemagick (DISABLED)
#display -size 1280x800 -window root ~/.wallpaper.png

# launch the window manager (needs to be done at the end)
exec dbus-launch --sh-syntax --exit-with-session ratpoison

```

### LAUNCH X
After the configuration file is properly set, you login and type on the terminal:  
`startx`  
whenever you want to start X.

### LAUNCH X AT LOGIN
To launch X at login, place the following at either your _".bash_profile"_ or _".bashrc"_ file:

```

if [ $(tty) = "/dev/tty1" ]
then
    startx > /dev/null 2>&1
fi

```

This will automatically launch _"X"_ at the first _"tty"_ (_"virtual terminal"_). If you are confused, to switch between ttys press _"Ctrl-Alt-F\<X>"_ (where _"\<X>_" is a number). So to change to the tty with xorg you'll press _"Ctrl-Alt-F1"_.

## KEY BINDINGS
Custom keys can be added with the __Xbindkeys__ program.

### GETTING KEYS INFORMATION
With the help of the default xev program you can check the keys you want:
* Start the program and type the key you want to see its information  
`xev > keys.txt`  
* Look for the line that says  
`keycode KEY_NUMBER (keysym INGORE_THIS, KEY_NAME)`  
* Now on _".xbindkeysrc"_ add the information for each bind:

```

"WHAT_YOU_WANT_HERE_GOES_HERE"
  m:0x0 + c:KEY_NUMBER
  KEY_NAME

```


### XBINDKEYSRC CONFIGURATION FILE
In the example below we'll have the modified keys:
* The "windows" key switch windows using dmenu pre-installed.
* The "menu" key brings an application launcher you type names into using dmenu.
* The "print screen" key takes a screenshot using imagemagick.
* The "scroll lock" key records the desktop using either libav-tools or ffmpeg.
* The "mute" button if available will mute/unmute volume.
* The "lower volume" button if available will lower volume.
* The "raise volume" button if available will raise volume.

Now the example _".xbindkeysrc"_ file which goes under your home directory:

```

# Enable "Scroll_Lock" for the next keybinding
keystate_scrolllock= enable

# Switch windows using the "windows key" (needs dmenu)
"ratpoison -c "select $(ratpoison -c "windows "%t"" | dmenu -nf gray -nb black -sf black -sb gray -b -l 20)""
  Super_L

# Launch application using the "menu key" (needs dmenu)
"dmenu_run -nf gray -nb black -sf black -sb gray -b"
  m:0x0 + c:135
  Menu

# Take screenshot using the "print screen key" (needs imagemagick)
"import -window root png:$HOME/x_$(date "+%Y-%m-%d-%H:%M:%S").png"
  m:0x0 + c:107
  Print

# Record desktop with avconv (libav-tools) or install ffmpeg and replace avconv
"killall -INT avconv 2>/dev/null || avconv -f x11grab -r 10 -s $(xrandr | grep '*' |  tr -s ' ' | cut -d ' ' -f2) -i :0.0 $HOME/x_$(date "+%Y-%m-%d-%H:%M:%S").mp4 &"
  m:0x0 + c:78
  Scroll_Lock

# Mute/unmute volume
"amixer set Master toggle"
  m:0x0 + c:121
  XF86AudioMute

# Lower volume
"amixer set PCM 5%-"
  m:0x0 + c:122
  XF86AudioLowerVolume

# Raise volume
"amixer set PCM 5%+"
  m:0x0 + c:123
  XF86AudioRaiseVolume

```


## CLIPBOARD
_"Xsel"_ with the help of _"GNU Screen"_ will be used as intermediary between the terminal and _"X"_. The following commands are examples we will replace by more simple bindings:
* To paste from _"X"_ clipboard  
`xsel -ob`  
* To copy to _"X"_ clipboard from inside _"GNU Screen"_  
`cat | xsel -ib`  
Then hit _"Ctrl-a + ]"_, then _"Enter"_, then _"Ctrl-d"_.  

### CLIPBOARD BINDINGS
For ease of use we will use _"GNU Screen's"_ configuration file _".screenrc"_ to save shortcuts for clipboard exchange instead of the above commands. Save these in your _".screenrc"_ file:

```

# Copy from "GNU Screen" to "X" clipboard automatically when using "GNU Screen's" copy selection
bindkey -m ' ' eval 'stuff \040' 'writebuf' 'exec sh -c "xsel -ib < /tmp/screen-exchange"'

# Copy from "X" to "GNU Screen" clipboard by pressing "Ctr-a + b" + "Ctrl-a + ]" on "GNU Screen's" normal mode
bind b eval 'exec sh -c "xsel -ob > /tmp/screen-exchange && screen -X readbuf"'

```
  

## WINDOW MANAGER
Productive, automated, scriptable, and minimal, __Ratpoison__ is a strict tiling window manager using bindings similar to GNU Screen. A few of its benefits are.
* No mouse used, all done by commands called by typing _"control"_ and _"t"_ at the same time, plus another key.
* You can set your own bindings in the file _".ratpoisonrc"_ which is extremely friendly.
* Extensible by [scripts](http://ratpoison.wxcvbn.org/cgi-bin/wiki.pl/Scripts). The _"rpws"_ script for example adds multiple workspaces (comes by default with Ratpoison), another script (_"[expose.pl](http://ratpoison.wxcvbn.org/cgi-bin/wiki.pl/expose.pl)"_) gives a mozaic of current windows.
* Can temporarily switch to another window manager with the _"tmpwm"_ command for your comfort.
* Full manual available from the terminal:  
`info ratpoison`  

### BASIC SHORTCUTS
* Show the help cheatsheet:  
`Ctrl-t + ?`  
* Bring an application menu:  
`Ctrl-t + .`  
* Get time and date:  
`Ctrl-t + a`  
* Clear screen from help cheatsheet or menu:  
`Esc`  

* Show open windows:  
`Ctrl-t + w`  
* Close a window:  
`Ctrl-t + k`  
* Swith back between windows:  
`Ctrl-t + Ctrl-t`  
* Go to next window:  
`Ctrl-t + n`  
`Ctrl-t + Space`  
* Go to previous window:  
`Ctrl-t + p`  


* Split screen vertically:  
`Ctrl-t + s`  
* Split screen horizontally:  
`Ctrl-t + S`  
* Go to next frame:  
`Ctrl-t + Tab`  
* Go to previous frame:  
`Ctrl-t + Alt-Tab`  
* Make a window the only one visible:  
`Ctrl-t + Q`  

### RATPOISONRC CONFIGURATION FILE
The next custom _".ratpoisonrc"_ file goes under your home directory and can be customized to your needs. It adds several goodies through scripts like an expose-like effect showing all windows on the screen arranged in a mozaic which you can choose by pressing the number from its tag:

```

# text editor
bind e exec gjots2
bind E exec xterm -e elvis

# web browser
bind y exec icecat
# highlight an url in a window and the url is opened in a new tab
bind Y exec icecat -new-tab `$RATPOISON -c getsel`

# MOC as a music player, alsamixer as volume control
bind o exec xterm -e mocp
bind O exec xterm -e alsamixer

# file manager
bind d exec spacefm
bind D exec xterm -e vifm

# mail
bind g exec xterm -e mutt

# IRC
bind h exec xterm -e irssi

# RSS
bind j exec liferea
bind J exec xterm -e newsbeuter

# password manager
bind z exec xterm -e kpcli

# looks for the JDownloader program under the designated path
bind Z exec ~/jd2/JDownloader2

# expose-like switch window by using "Ctrl-t + ,"
bind comma exec ~/bin/expose.pl

# as colon invoke ratpoison commands, semicolon invoke shell commands ("Ctrl-t + ;")
bind semicolon exec

# no startup message announcing what the prefix keys are
startup_message off

# change font, color and position for messages
set font "Fixed-11"
set fgcolor gray
set bgcolor black
set bargravity c

# normal cursor
exec xsetroot -cursor_name left_ptr

# fix java swing, needs wmname from suckless
exec wmname LG3D

# multiple workspaces by using "Alt + FX" (where "FX" is from F1 to F4), needs rpws script
exec rpws init 4 -k

# get rid of the one pixel border around windows
set border 0

```
````````
-----

""""""
~~~~~~
---
tags: [scratchpad]
info: aberto.
date: 2025-10-07
type: post
layout: post
published: true
slug: auto-xrandr
title: 'auto xrandr for multi-monitor setup'
---

# documentation

## A. Tests-First Verification

### A1. Test Matrix

| ID                  | Behavior                     | Trigger/Command                               | Expectation                              | Exit |
| ------------------- | ---------------------------- | --------------------------------------------- | ---------------------------------------- | ---- |
| T-HELP              | Help prints header block     | `pwsh -File ./pwsh_monitor_working.ps1 -Help` | Usage text includes OPTIONS & EXIT CODES | 0    |
| T-HEADLESS          | Headless detection           | Unset `DISPLAY` + break `xrandr`              | Error then exit                          | 20   |
| T-MISS-DEP          | Missing dep and `-NoInstall` | Remove `xrandr` from PATH                     | Named missing dep; fail fast             | 2    |
| T-AUTOINSTALL       | Auto-install needs root      | `-AutoInstall` as non-root                    | Error “requires root”                    | 2    |
| T-INTERACTIVE       | Interactive selection        | ≥2 monitors                                   | Overlay confirm; accepted mode           | 0    |
| T-APPLY-SAVED       | Non-interactive apply        | Valid JSON config                             | One-line summary JSON                    | 0    |
| T-APPLY-NOCONFIG    | Missing config               | `-ApplySavedLayout` w/ nonexistent file       | Warning                                  | 23   |
| T-JSON-ERROR        | Malformed JSON               | Bad config file                               | Error                                    | 24   |
| T-INVALID-CONFIG    | Empty/invalid object         | Corrupt config                                | Error                                    | 22   |
| T-FINAL-APPLY-ERROR | xrandr fails on final        | Mock nonzero exit                             | Warning                                  | 1    |
| T-PRIMARY           | Largest area → primary       | Mixed resolutions                             | `--primary` set                          | 0    |

### A2. Pester Samples

**tests/Docs.Tests.ps1**

```powershell
Describe 'Documentation coverage' {
  It 'Help text exists and includes sections' {
    $out = pwsh -NoLogo -NoProfile -File ./pwsh_monitor_working.ps1 -Help
    $out | Should -Match 'OPTIONS'
    $out | Should -Match 'EXIT CODES'
  }
  It 'JSON summary schema on success' {
    $cfg = '{"HDMI-1":"1920x1080"}'
    $tmp = New-TemporaryFile
    Set-Content -Path $tmp -Value $cfg -Encoding UTF8
    $json = pwsh -NoLogo -NoProfile -File ./pwsh_monitor_working.ps1 -ApplySavedLayout -ConfigPath $tmp
    Remove-Item $tmp -Force
    $obj = $json | ConvertFrom-Json
    $obj.ok | Should -BeTrue
    $obj.mode | Should -Be 'apply-saved'
    $obj | Get-Member -Name primary,order,chosen,configFile | Should -Not -BeNullOrEmpty
  }
}
```

**tests/XrandrParsing.Tests.ps1**

```powershell
Describe 'xrandr parsing' {
  It 'Parses connected outputs' {
    Mock Get-XrandrLines { @('HDMI-1 connected primary 1920x1080+0+0', 'DP-1 connected 2560x1440+1920+0') }
    (Get-ConnectedOutputs) | Should -Be @('HDMI-1','DP-1')
  }
  It 'Extracts modes for an output' {
    Mock Get-XrandrLines { @(
      'HDMI-1 connected', '  1920x1080 60.00*+', '  1280x720 60.00',
      'DP-1 connected',   '  2560x1440 59.95*', '  1920x1080 60.00'
    ) }
    (Get-OutputModes 'HDMI-1') | Should -Contain '1920x1080'
  }
  It 'Verifies geometry match' {
    Mock Get-CurrentGeometry { [pscustomobject]@{W=1920;H=1080;X=0;Y=0} }
    (Verify-OutputGeometry 'HDMI-1' '1920x1080') | Should -BeTrue
  }
}
```

**tests/ExitCodes.Tests.ps1**

```powershell
Describe 'Exit codes' {
  It '-ApplySavedLayout missing file => 23' {
    $p = Start-Process pwsh -ArgumentList '-File','./pwsh_monitor_working.ps1','-ApplySavedLayout','-ConfigPath','/nope.json' -PassThru -Wait
    $p.ExitCode | Should -Be 23
  }
}
```

## B. Background & Scope

* **Problem:** Multi-monitor setup is error-prone across WMs and distros.
* **Goal:** Interactive discovery + verification; persisted JSON; non-interactive reapply; machine-parseable success.
* **Scope:** X11 `xrandr` only; Wayland not supported.

## C. Supported Environments

* Debian/Ubuntu(+derivatives), Fedora/RHEL/CentOS, openSUSE, Arch-based; WM/terminal agnostic.
* Requires `xrandr`, `python3` with `tkinter`, and PowerShell 7+.

## D. Feature/Request Status Matrix

| Request                  | Status      | Implementation Notes                                                 |
| ------------------------ | ----------- | -------------------------------------------------------------------- |
| `-ConfigPath` override   | Implemented | Default `$HOME/.config/pwsh-monitor-layout.json`; used in both paths |
| `-Help`                  | Implemented | `Show-Help` extracts header `<# ... #>` and exits 0                  |
| One-line success JSON    | Implemented | Both interactive and apply-saved paths emit schema                   |
| Portability auto-install | Implemented | PM detection + root requirement                                      |
| `-NoInstall` fast-fail   | Implemented | Throws if missing dep; exit 2                                        |
| Headless explicit exit   | Implemented | `Assert-XSessionOrExit` → exit 20                                    |
| Autostart `.desktop`     | Implemented | Writes to `~/.config/autostart/` with proper Exec                    |

## E. Usage

* **Interactive:** `pwsh -File ./pwsh_monitor_working.ps1`
* **Auto-install (root):** `sudo pwsh -File ./pwsh_monitor_working.ps1 -AutoInstall`
* **Apply saved:** `pwsh -File ./pwsh_monitor_working.ps1 -ApplySavedLayout [-ConfigPath <file>]`
* **Help:** `pwsh -File ./pwsh_monitor_working.ps1 -Help`

## F. Dependencies & Authority

* Ensured via `Ensure-Dep`; PMs: `apt`, `dnf`, `zypper`, `pacman`. Root required for auto-install.
* When root, sets `XAUTHORITY` to target user; defaults `DISPLAY` to `:0` if unset.

## G. Design & Key Functions

* Parsing/validation (`Get-ConnectedOutputs`, `Get-OutputModes`, `Get-CurrentGeometry`, `Verify-OutputGeometry`).
* Application (`Apply-Layout` with cumulative width positioning; `--primary` set by area heuristic).
* Overlay (`Show-OverlayTk`) for visual confirmation.
* Persistence/autostart and summary emission.

## H. Data Model & Files

* **Config JSON (ordered mapping):**

```json
{
  "HDMI-1": "1920x1080",
  "DP-1": "2560x1440"
}
```

* **Success Summary (stdout, single line):**

```json
{"ok":true,"mode":"interactive","primary":"HDMI-1","order":["HDMI-1","DP-1"],"chosen":{"HDMI-1":"1920x1080","DP-1":"2560x1440"},"configFile":"/home/user/.config/pwsh-monitor-layout.json"}
```

* **Transcripts:** `/tmp/pwsh_monitor_working-YYYYMMDD-HHMMSS.log` (fallback `$HOME/...`).
* **Autostart:** `~/.config/autostart/pwsh_monitor_working.desktop`.

## I. Error Handling & Exit Codes

| Code | Meaning                               | Typical Source                         | Remedy                                         |
| ---: | ------------------------------------- | -------------------------------------- | ---------------------------------------------- |
|    0 | Success                               | Normal completion                      | —                                              |
|    1 | General/user abort/final apply failed | `Prompt-YNQ` quit; `Apply-Layout` fail | Retry with `-DebugMode` or adjust modes        |
|    2 | Missing dep / install failure         | `Ensure-Dep`/`Install-Dep`             | Install packages or use `-AutoInstall` as root |
|   20 | Headless / no X11                     | `Assert-XSessionOrExit`                | Start X11; ensure `xrandr` works               |
|   21 | No connected monitors                 | `Get-ConnectedOutputs`                 | Check hardware/cables                          |
|   22 | Invalid/empty config                  | Apply-saved path                       | Fix JSON                                       |
|   23 | Config file not found                 | Apply-saved path                       | Provide correct `-ConfigPath`                  |
|   24 | JSON parse error                      | Apply-saved path                       | Fix JSON syntax                                |
|   25 | Permission/ownership error            | Autostart/config setup                 | Correct ownership and perms                    |

## J. Deployment & Autostart

* First run interactively to generate JSON; confirm overlay; verify autostart `.desktop`.
* For login issues, inspect latest transcript under `/tmp`.

## K. Troubleshooting

* **Overlay missing:** Install `python3-tk`/`tk`; some WMs may block undecorated topmost windows.
* **Apply-saved fails:** Outputs may be renamed (docks/GPUs); re-run interactive flow to refresh JSON.
* **Headless (20):** Ensure `DISPLAY` and functioning X server.

## L. Versioning

* **v0.1 (2025-10-14):** Initial structured docs and tests-first plan.

## M. Causality Links (Why → How Validated)

* **Correct ordering:** User selection + overlay → Pester interactive smoke + manual confirmation.
* **Accurate geometry:** Compare `Get-CurrentGeometry` against selected mode → Pester unit test for verifier.
* **Reproducibility:** Persist ordered mapping; non-interactive apply → schema test; exit-code tests.
* **Robust setup:** Auto-install with PM detection; guarded by root → negative test for non-root.
* **Headless clarity:** Explicit exit 20 → smoke test with unset `DISPLAY`.

{% codeblock bash %}
#!/usr/bin/env pwsh
<# 
pwsh_monitor_working.ps1 — Interactive + non-interactive multi-monitor configurator for X11 (Linux)

TARGET: Debian/Ubuntu/Derivatives, Fedora/RHEL/CentOS, openSUSE, Arch-based (pwsh, xrandr)
WM/TERM agnostic (works with ratpoison/Alacritty etc.)

KEY CAPABILITIES
- Interactive discovery of output order (left→right) and resolution selection per monitor using xrandr.
- Verifies applied geometry; shows a Tk red-border overlay to confirm the active monitor.
- Saves chosen layout to JSON and can re-apply non-interactively on login/autostart.
- Robust logging (Start-Transcript), strict error behavior, and explicit exit codes.

NEW/REQUESTED IMPROVEMENTS
- -ConfigPath <file> to override default config path (default: ~/.config/pwsh-monitor-layout.json).
- -Help: Prints usage, options, examples, and exit codes then exits 0.
- Emits a one-line machine-parseable JSON summary on success for both interactive and apply-saved paths.
- Portability hardening: auto-install gated by distro/pm detection (apt-get/dnf/zypper/pacman).
- -NoInstall: disable auto-install; fail fast if dependencies missing.
- Headless handling: detect missing X11/xrandr availability and exit with explicit code.

USAGE (examples)
  # First run (interactive):
  pwsh -File ./pwsh_monitor_working.ps1

  # Auto-install missing deps (root required):
  sudo pwsh -File ./pwsh_monitor_working.ps1 -AutoInstall

  # Save config to a specific path:
  pwsh -File ./pwsh_monitor_working.ps1 -ConfigPath "$HOME/.config/my-monitor-layout.json"

  # Non-interactive apply of saved layout (good for autostart):
  pwsh -File ./pwsh_monitor_working.ps1 -ApplySavedLayout

  # Print help:
  pwsh -File ./pwsh_monitor_working.ps1 -Help

OPTIONS
  -DebugMode             Verbose logging during execution.
  -AutoInstall           Attempt to install dependencies via detected package manager.
  -NoInstall             Do not install; fail fast if dependencies are missing.
  -ApplySavedLayout      Apply saved layout from the config JSON and exit.
  -OverlaySeconds <int>  Seconds to keep the red overlay visible when testing (default: 5).
  -TargetUser <string>   Login user for ownership of autostart/config when run as root (default: SUDO_USER/USER/linaro).
  -ScriptInstallPath     Path to place a self-copy used by autostart (default: $HOME/pwsh_monitor_working.ps1).
  -ConfigPath            Override config JSON path (default: $HOME/.config/pwsh-monitor-layout.json).
  -Help                  Show this help and exit.

EXIT CODES
  0  Success
  1  General error / user abort / final apply failed
  2  Missing dependency and -NoInstall provided (or auto-install disabled/unsupported)
 20  Headless / no X11 session detected (no DISPLAY or xrandr unusable)
 21  No connected monitors detected
 22  Invalid/empty configuration when using -ApplySavedLayout
 23  Config file not found for -ApplySavedLayout
 24  JSON parse error for -ConfigPath
 25  Permission or ownership errors during autostart/config setup

MACHINE-PARSABLE SUMMARY
  On success, prints a single line JSON to stdout like:
  {"ok":true,"mode":"interactive","primary":"HDMI-1","order":["HDMI-1","DP-1"],"chosen":{"HDMI-1":"1920x1080","DP-1":"2560x1440"},"configFile":"/home/user/.config/pwsh-monitor-layout.json"}

#>

[CmdletBinding()]
param(
    [switch] $DebugMode,
    [switch] $AutoInstall,
    [switch] $NoInstall,
    [switch] $ApplySavedLayout,
    [switch] $Help,
    [int]    $OverlaySeconds = 5,
    [string] $TargetUser = ($env:SUDO_USER ?? $env:USER ?? 'linaro'),
    [string] $ScriptInstallPath = "$HOME/pwsh_monitor_working.ps1",
    [string] $ConfigPath
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'
if ($DebugMode) { $VerbosePreference = 'Continue' }

function Stop-TranscriptSafe { try { Stop-Transcript | Out-Null } catch {} }

# Transcript
$tsFile = "/tmp/pwsh_monitor_working-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"
try { Start-Transcript -Path $tsFile -Force | Out-Null } catch {
    $tsFile = Join-Path $HOME "pwsh_monitor_working-$(Get-Date -Format 'yyyyMMdd-HHmmss').log"
    try { Start-Transcript -Path $tsFile -Force | Out-Null } catch {}
}
Write-Verbose "Transcript: $tsFile"

# ---------- Helpers ----------
function Show-Help {
    $path = $PSCommandPath
    if (-not $path) { $path = $MyInvocation.MyCommand.Path }
    $content = Get-Content -Raw -Path $path
    $helpBlock = [regex]::Match($content, '(?s)<#\s*(.*?)\s*#>').Groups[1].Value
    if ([string]::IsNullOrWhiteSpace($helpBlock)) {
        Write-Output "Usage: pwsh -File $path [-AutoInstall|-NoInstall] [-ApplySavedLayout] [-ConfigPath <file>] [-OverlaySeconds <int>] [-DebugMode] [-Help]"
    } else {
        Write-Output $helpBlock.Trim()
    }
}

function Test-Cmd([string]$Name) { $null -ne (Get-Command -Name $Name -ErrorAction SilentlyContinue) }

function Test-IsRoot {
    try { ((& id '-u' 2>$null) -eq 0) } catch {
        try { ((& whoami) -eq 'root') } catch { ($env:USER -eq 'root') }
    }
}

function Detect-PackageManager {
    if (Test-Cmd 'apt-get') { return 'apt' }
    if (Test-Cmd 'dnf')     { return 'dnf' }
    if (Test-Cmd 'zypper')  { return 'zypper' }
    if (Test-Cmd 'pacman')  { return 'pacman' }
    return $null
}

function Install-Dep([string]$pkg) {
    $pm = Detect-PackageManager
    if (-not $pm) { throw 'No supported package manager found.' }
    if (-not (Test-IsRoot)) { throw 'Auto-install requires root.' }

    switch ($pm) {
        'apt'    { & apt-get update -y; & apt-get install -y $pkg }
        'dnf'    { & dnf install -y $pkg }
        'zypper' { & zypper -n install -y $pkg }
        'pacman' { & pacman -Sy --noconfirm $pkg }
    }
}

function Ensure-Dep([string]$cmd, [string]$pkg, [string]$friendly) {
    if (Test-Cmd $cmd) { return }
    if ($NoInstall) { throw "Missing dependency '$friendly' and -NoInstall was specified." }
    if (-not $AutoInstall) { throw "Missing dependency '$friendly'. Rerun with -AutoInstall or install '$pkg' manually." }
    Install-Dep $pkg
    if (-not (Test-Cmd $cmd)) { throw "Dependency '$friendly' not available after install." }
}

function Test-PythonTk {
@'
import sys
try:
    import tkinter as t
    root = t.Tk()
    root.withdraw()
    print("OK")
except Exception as e:
    print("ERR", e)
    sys.exit(1)
'@ | Set-Content -Path ($tmp = [IO.Path]::GetTempFileName() + '.py') -Encoding UTF8
    try {
        $p = Start-Process -FilePath 'python3' -ArgumentList @($tmp) -PassThru -NoNewWindow -Wait
        return ($p.ExitCode -eq 0)
    } finally {
        try { Remove-Item $tmp -Force -ErrorAction SilentlyContinue } catch {}
    }
}

function Assert-XSessionOrExit {
    if (-not $env:DISPLAY) { $env:DISPLAY = ':0' }
    for ($i=0; $i -lt 6; $i++) {
        try { & xrandr --current | Out-Null; return } catch { Start-Sleep -Milliseconds 300 }
    }
    Write-Error 'No X11 display/xrandr available (headless or X not running).'
    Stop-TranscriptSafe; exit 20
}

# ---------- Dependency checks ----------
try {
    Ensure-Dep 'xrandr'  'x11-xserver-utils' 'xrandr'
    Ensure-Dep 'python3' 'python3'           'python3'
} catch {
    Write-Error $_.Exception.Message
    Stop-TranscriptSafe; exit 2
}

# ---------- X11 availability ----------
Assert-XSessionOrExit

# tkinter (package name differs by distro)
if (-not (Test-PythonTk)) {
    try {
        $pm = Detect-PackageManager
        switch ($pm) {
            'apt'    { Install-Dep 'python3-tk' }
            'dnf'    { Install-Dep 'python3-tkinter' }
            'zypper' { Install-Dep 'python3-tk' }
            'pacman' { Install-Dep 'tk' }
            default  { throw 'Unsupported package manager for tkinter.' }
        }
    } catch {
        Write-Error "Unable to install/verify tkinter: $($_.Exception.Message)"
        Stop-TranscriptSafe; exit 2
    }
    if (-not (Test-PythonTk)) {
        Write-Error 'python3-tk/tkinter not available after installation.'
        Stop-TranscriptSafe; exit 2
    }
}

# ---------- X11 env + authority ----------
$root = Test-IsRoot
$homeTarget = if ($root) { "/home/$TargetUser" } else { $HOME }
if (-not $env:DISPLAY) { $env:DISPLAY = ':0' }
if ($root) {
    $xaUser = "/home/$TargetUser/.Xauthority"
    if (Test-Path $xaUser) { $env:XAUTHORITY = $xaUser }
    elseif (Test-Path '/root/.Xauthority') { $env:XAUTHORITY = '/root/.Xauthority' }
} elseif (-not $env:XAUTHORITY) {
    $env:XAUTHORITY = Join-Path $HOME '.Xauthority'
}

# Config path default
if (-not $ConfigPath -or [string]::IsNullOrWhiteSpace($ConfigPath)) {
    $ConfigPath = Join-Path (Join-Path $homeTarget '.config') 'pwsh-monitor-layout.json'
}

# ---------- Early exits ----------
if ($Help) { Show-Help; Stop-TranscriptSafe; exit 0 }

# ---------- xrandr helpers ----------
function Get-XrandrLines { (& xrandr --query | Out-String) -split "`n" }

function Get-ConnectedOutputs {
    Get-XrandrLines | ForEach-Object {
        if ($_ -match '^\s*(\S+)\s+connected') { $Matches[1] }
    }
}

function Sort-OutputsPreferred([string[]]$Outputs) {
    $order = @('HDMI','DP','DVI','VGA','eDP')
    $picked = [System.Collections.Generic.List[string]]::new()
    foreach ($p in $order) {
        $Outputs | Where-Object { $_ -like "$p*" } | ForEach-Object { [void]$picked.Add($_) }
    }
    $Outputs | Where-Object { $picked -notcontains $_ } | ForEach-Object { [void]$picked.Add($_) }
    $picked | Select-Object -Unique
}

function Get-OutputModes([string]$Output) {
    $lines = Get-XrandrLines
    $in = $false
    $modes = [System.Collections.Generic.List[string]]::new()
    foreach ($ln in $lines) {
        if (-not $in) {
            if ($ln -match "^\s*$([Regex]::Escape($Output))\s+connected") { $in = $true; continue }
        } else {
            if ($ln -match '^\S+\s+(connected|disconnected)') { break }
            if ($ln -match '^\s+([0-9]{3,5}x[0-9]{3,5}\S*)') {
                $t = $Matches[1]
                if (-not $modes.Contains($t)) { [void]$modes.Add($t) }
            }
        }
    }
    if ($modes.Count -eq 0) { throw "No modes parsed for $Output" }
    return $modes.ToArray()
}

function Get-Size([string]$Token) {
    if ($Token -notmatch '^(\d{3,5})x(\d{3,5})') { throw "Invalid mode token: $Token" }
    [pscustomobject]@{ W = [int]$Matches[1]; H = [int]$Matches[2] }
}

function Get-CurrentGeometry([string]$Output) {
    $pattern = "^{0}\b" -f [Regex]::Escape($Output)
    $ln = Get-XrandrLines | Where-Object { $_ -match $pattern } | Select-Object -First 1
    if (-not $ln) { return $null }
    $m = [regex]::Match($ln, '(\d{3,5}x\d{3,5})\+(\d+)\+(\d+)')
    if (-not $m.Success) { return $null }
    $wxh = $m.Groups[1].Value
    $x = [int]$m.Groups[2].Value
    $y = [int]$m.Groups[3].Value
    $m2 = [regex]::Match($wxh, '^(\d{3,5})x(\d{3,5})$')
    if (-not $m2.Success) { return $null }
    [pscustomobject]@{ W = [int]$m2.Groups[1].Value; H = [int]$m2.Groups[2].Value; X = $x; Y = $y }
}

function Invoke-Xrandr([string[]]$XRArgs) {
    $p = Start-Process -FilePath 'xrandr' -ArgumentList $XRArgs -PassThru -NoNewWindow -Wait
    if ($DebugMode) { Write-Verbose ("xrandr " + ($XRArgs -join ' ') + " => " + $p.ExitCode) }
    $p.ExitCode
}

function Apply-Layout([System.Collections.Specialized.OrderedDictionary]$Map) {
    $x = 0
    foreach ($o in $Map.Keys) {
        $tok = [string]$Map[$o]
        $code = Invoke-Xrandr @('--output', $o, '--mode', $tok, '--pos', ("{0}x0" -f $x), '--rotate', 'normal')
        if ($code -ne 0) {
            Write-Warning ("xrandr failed for {0} token {1} (exit {2})" -f $o, $tok, $code)
            return $false
        }
        Start-Sleep -Milliseconds 120
        $sz = Get-Size $tok
        $x += $sz.W
    }
    Start-Sleep -Milliseconds 180
    return $true
}

function Verify-OutputGeometry([string]$Output, [string]$Token) {
    $want = Get-Size $Token
    $cur = Get-CurrentGeometry $Output
    if (-not $cur) {
        if ($DebugMode) { Write-Verbose "Verify: no geometry for $Output" }
        return $false
    }
    $ok = ($cur.W -eq $want.W -and $cur.H -eq $want.H)
    if ($DebugMode) {
        Write-Verbose ("Verify: {0} current={1}x{2} vs want={3}x{4} => {5}" -f $Output, $cur.W, $cur.H, $want.W, $want.H, $ok)
    }
    $ok
}

function Show-OverlayTk([int]$W,[int]$H,[int]$X,[int]$Y,[int]$Seconds) {
$py = @'
import sys, tkinter as t
w, h, x, y, sec = map(int, sys.argv[1:6])
root = t.Tk()
root.overrideredirect(1)
root.attributes("-topmost", True)
root.geometry(f"{w}x{h}+{x}+{y}")
t.Frame(root, width=w, height=h, highlightbackground="red", highlightthickness=8).pack()
root.after(sec*1000, root.destroy)
root.mainloop()
'@
    $tmp = [IO.Path]::GetTempFileName() + '.py'
    [IO.File]::WriteAllText($tmp, $py)
    $p = Start-Process -FilePath 'python3' -ArgumentList @($tmp, $W, $H, $X, $Y, $Seconds) -PassThru -NoNewWindow
    $timeout = [Math]::Max($Seconds + 3, 8)
    $exited = $true
    try { Wait-Process -Id $p.Id -Timeout $timeout } catch { $exited = $false }
    if (-not $exited) {
        try { Stop-Process -Id $p.Id -Force -ErrorAction SilentlyContinue } catch {}
        Write-Warning 'Overlay timeout; killed.'
    }
    try { Remove-Item $tmp -Force -ErrorAction SilentlyContinue } catch {}
}

function Prompt-YNQ([string]$Msg) {
    while ($true) {
        $r = Read-Host $Msg
        switch -Regex ($r) {
            '^(?i)y$' { return 'y' }
            '^(?i)n$' { return 'n' }
            '^(?i)q$' { return 'q' }
            default   { Write-Host 'Please type y, n, or q.' -ForegroundColor Yellow }
        }
    }
}

# ---------- Apply saved layout fast-path ----------
if ($ApplySavedLayout) {
    if (-not (Test-Path $ConfigPath)) {
        Write-Warning "Config not found: $ConfigPath"
        Stop-TranscriptSafe; exit 23
    }
    try {
        $raw = Get-Content -Raw -Path $ConfigPath
        $obj = $raw | ConvertFrom-Json
    } catch {
        Write-Error "Failed to parse config JSON: $($_.Exception.Message)"
        Stop-TranscriptSafe; exit 24
    }
    if (-not $obj) { Write-Error 'Empty/invalid configuration object.'; Stop-TranscriptSafe; exit 22 }

    $orderedChosen = [System.Collections.Specialized.OrderedDictionary]::new()
    foreach ($p in $obj.PSObject.Properties) {
        $orderedChosen[$p.Name] = [string]$p.Value
    }

    if ($orderedChosen.Count -eq 0) { Write-Error 'No entries in configuration.'; Stop-TranscriptSafe; exit 22 }

    if (-not (Apply-Layout $orderedChosen)) {
        Write-Warning 'Applying saved layout reported errors.'
        Stop-TranscriptSafe; exit 1
    }

    $primary = $null; $maxA = -1
    foreach ($o in $orderedChosen.Keys) {
        $sz = Get-Size ([string]$orderedChosen[$o])
        $a  = $sz.W * $sz.H
        if ($a -gt $maxA) { $primary = $o; $maxA = $a }
    }
    $null = Invoke-Xrandr @('--output', $primary, '--primary')

    $summary = [pscustomobject]@{
        ok         = $true
        mode       = 'apply-saved'
        primary    = $primary
        order      = @($orderedChosen.Keys)
        chosen     = $orderedChosen
        configFile = $ConfigPath
    } | ConvertTo-Json -Compress
    Write-Output $summary
    Stop-TranscriptSafe; exit 0
}

# ---------- Probe outputs ----------
$outs = Get-ConnectedOutputs
if (-not $outs -or $outs.Count -eq 0) { Write-Error 'No connected monitors detected.'; Stop-TranscriptSafe; exit 21 }

# ---------- Interactive ordering ----------
$orderedOuts = [System.Collections.Generic.List[string]]::new()
if ($outs.Count -gt 1) {
    $remaining = [System.Collections.Generic.List[string]]::new()
    $remaining.AddRange([string[]]$outs)
    Write-Host "Multiple monitors detected: $($remaining -join ', ')" -ForegroundColor Cyan
    while ($remaining.Count -gt 0) {
        if ($orderedOuts.Count -eq 0) {
            Write-Host "Which monitor should be on the far left?"
        } else {
            Write-Host "Which monitor should be to the right of $($orderedOuts[-1])?"
        }
        for ($i=0; $i -lt $remaining.Count; $i++) { Write-Host "  [$($i+1)] $($remaining[$i])" }
        $ans = Read-Host "Enter number (1-$($remaining.Count))"
        if (($ans -match '^\d+$') -and ([int]$ans -ge 1) -and ([int]$ans -le $remaining.Count)) {
            $choiceIndex = [int]$ans - 1
            $orderedOuts.Add($remaining[$choiceIndex])
            $remaining.RemoveAt($choiceIndex)
        } else {
            Write-Warning "Invalid selection."
        }
    }
} else {
    $orderedOuts.Add($outs[0])
}
Write-Host "Final monitor order (left-to-right): $($orderedOuts -join ' -> ')" -ForegroundColor Green

# ---------- Gather modes ----------
$All   = @{}
$First = @{}
foreach ($o in $orderedOuts) {
    $m = Get-OutputModes $o
    $All[$o] = $m
    $First[$o] = $m[0]
    if ($DebugMode) { Write-Verbose ("Modes[{0}] (#{1}): {2}" -f $o, $m.Count, ($m -join ' ')) }
}

$Chosen = [System.Collections.Specialized.OrderedDictionary]::new()
foreach ($o in $orderedOuts) { $Chosen[$o] = $null }

# ---------- Per-output interactive selection ----------
foreach ($current in $orderedOuts) {
    Write-Host ("======== Configuring {0} ========" -f $current) -ForegroundColor Cyan
    $cands = @($All[$current])
    $accepted = $false

    for ($i = 0; $i -lt $cands.Count; $i++) {
        $tok = $cands[$i]
        Write-Host ("---> [{0}/{1}] Trying {2} for {3}" -f ($i + 1), $cands.Count, $tok, $current) -ForegroundColor Green

        $proposal = [System.Collections.Specialized.OrderedDictionary]::new()
        foreach ($o in $orderedOuts) {
            if ($o -eq $current) { $proposal[$o] = $tok }
            else { $proposal[$o] = ($Chosen[$o] ?? $First[$o]) }
        }

        if (-not (Apply-Layout $proposal)) { Write-Warning ("Skip {0}: xrandr exit!=0" -f $tok); continue }
        if (-not (Verify-OutputGeometry $current $tok)) { Write-Warning ("Skip {0}: geometry mismatch" -f $tok); continue }

        $xoff = 0
        foreach ($o in $orderedOuts) {
            if ($o -eq $current) { break }
            $sz = Get-Size ([string]$proposal[$o])
            $xoff += $sz.W
        }
        $szC = Get-Size $tok
        Show-OverlayTk -W $szC.W -H $szC.H -X $xoff -Y 0 -Seconds $OverlaySeconds

        $ans = Prompt-YNQ ("Was the red rectangle fully enclosed on {0} at {1}? [y=accept / n=next / q=quit]" -f $current, $tok)
        if ($ans -eq 'y') { $Chosen[$current] = $tok; $accepted = $true; break }
        if ($ans -eq 'q') { Write-Warning 'User aborted.'; Stop-TranscriptSafe; exit 1 }
    }

    if (-not $accepted) {
        $fb = $First[$current]
        Write-Warning ("No accepted mode for {0}. Falling back to {1}" -f $current, $fb)
        $Chosen[$current] = $fb
    }
}

# ---------- Final apply ----------
Write-Host "Final configuration selected. Applying..." -ForegroundColor Cyan
if (-not (Apply-Layout $Chosen)) {
    Write-Warning 'Final layout application reported errors.'
    Stop-TranscriptSafe; exit 1
}

# choose primary as largest area
$primary = $null; $maxA = -1
foreach ($o in $orderedOuts) {
    $sz = Get-Size ([string]$Chosen[$o])
    $a  = $sz.W * $sz.H
    if ($a -gt $maxA) { $primary = $o; $maxA = $a }
}
$null = Invoke-Xrandr @('--output', $primary, '--primary')

# ---------- Save config + autostart ----------
try {
    $configDir = Split-Path -Parent $ConfigPath
    if (-not (Test-Path $configDir)) {
        if ($root) { & sudo -u $TargetUser mkdir -p -- $configDir }
        else       { New-Item -ItemType Directory -Path $configDir -Force | Out-Null }
    }

    $tmpChosen = [ordered]@{}
    foreach ($k in $Chosen.Keys) { $tmpChosen[$k] = [string]$Chosen[$k] }
    ($tmpChosen | ConvertTo-Json) | Set-Content -Path $ConfigPath -Encoding UTF8
    if ($root) { & chown "${TargetUser}:${TargetUser}" $ConfigPath }
    Write-Host "[INFO] Configuration saved to $ConfigPath" -ForegroundColor DarkCyan

    $autoDir = Join-Path $homeTarget '.config/autostart'
    if (-not (Test-Path $autoDir)) {
        if ($root) { & sudo -u $TargetUser mkdir -p -- $autoDir }
        else       { New-Item -ItemType Directory -Path $autoDir -Force | Out-Null }
    }
    if (-not (Test-Path $ScriptInstallPath)) {
        $src = $PSCommandPath; if (-not $src) { $src = $MyInvocation.MyCommand.Path }
        Copy-Item -Path $src -Destination $ScriptInstallPath -Force
        if ($root) { & chown "${TargetUser}:${TargetUser}" $ScriptInstallPath }
        & chmod +x $ScriptInstallPath
    }
    $desktopFile = Join-Path $autoDir 'pwsh_monitor_working.desktop'
    $execLine = "pwsh -File $ScriptInstallPath -ApplySavedLayout -ConfigPath `"$ConfigPath`""
@"
[Desktop Entry]
Type=Application
Exec=$execLine
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
Name=PwshAutoMonitor
Comment=Autoconfigure monitors layout (pwsh)
"@ | Set-Content -Path $desktopFile -Encoding UTF8 -NoNewline
    if ($root) { & chown "${TargetUser}:${TargetUser}" $desktopFile }
    & chmod 0644 $desktopFile
    Write-Host ("[INFO] Autostart installed at {0} for user {1}" -f $desktopFile, $TargetUser) -ForegroundColor DarkCyan
} catch {
    Write-Warning ("Autostart/config setup issue: {0}" -f $_.Exception.Message)
}

# ---------- Success summary (single-line JSON) ----------
$summary2 = [pscustomobject]@{
    ok         = $true
    mode       = 'interactive'
    primary    = $primary
    order      = @($orderedOuts)
    chosen     = $Chosen
    configFile = $ConfigPath
} | ConvertTo-Json -Compress
Write-Output $summary2

Stop-TranscriptSafe
exit 0
{% endcodeblock %}
~~~~~~
""""""

@@@
:::
'''

TASKS=[
So, your tasks, as the AI ASSISTANT, are all the ones necessary to properly output and complete, integrated, fully-functional, holistically cohesive and coherent, final `bash` script that leverages each and every data/information/knowledge presented above in order to build an 'once-for-all' solution for setting up automatically with persistence (endures rebooting) dual monitors of different resolutions, sizes, connected from different ports, one HDMI and the other VGA, within an debian 11 bullseye - arm64 rk3588 gmali610 32GB of RAM - operating system running `ratpoison` as its unique window/desktop manager. NO PLACEHOLDERS. NO YAPPING.
]
}