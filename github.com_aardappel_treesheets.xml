<repomix><file_summary>This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where empty lines have been removed, line numbers have been added, content has been formatted for parsing in xml style, security check has been disabled.<purpose>This file contains a packed representation of a subset of the repository&apos;s contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.</purpose><file_format>The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file</file_format><usage_guidelines>- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.</usage_guidelines><notes>- Some files may have been excluded based on .gitignore rules and Repomix&apos;s configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/translations/**
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Line numbers have been added to the beginning of each line
- Content has been formatted for parsing in xml style
- Security check has been disabled - content may contain sensitive information
- Files are sorted by Git change count (files with more changes are at the bottom)</notes></file_summary><directory_structure>.github/
  workflows/
    build.yml
platform/
  linux/
    com.strlen.TreeSheets.desktop
    com.strlen.TreeSheets.svg
    com.strlen.TreeSheets.xml
  osx/
    App.icns
    Info.plist
  win/
    icon1.ico
    treesheets.rc
src/
  cell.h
  document.h
  evaluator.h
  events.h
  genpot.bat
  grid.h
  image.h
  lobster_impl.cpp
  main.cpp
  pot_update.sh
  script_interface.h
  selection.h
  stdafx.cpp
  stdafx.h
  system.h
  text.h
  threadpool.h
  tools.h
  treesheets_impl.h
  tsapp.h
  tscanvas.h
  tsframe.h
  wxtools.h
thirdparty/
  StackWalker/
    StackWalker.cpp
    StackWalker.h
    StackWalkerHelpers.cpp
TS/
  docs/
    images/
      documentation/
        deleted.png
        edit.png
        grid.png
        gridline.png
        gridline2.png
        gridsel1.png
        gridsel2.png
        gridsel3.png
        insert.png
        long1.png
        long2.png
        long3.png
        new.png
        postgrid.png
        pregrid.png
        textsize.png
        zoomed.png
      screenshots/
        screenshot_personel.png
        screenshot_sales.png
        screenshot_todo_half.png
        screenshot_todo_linux.png
        screenshot_todo_mac.png
        screenshot_todo.png
        screenshot_tutorial.png
        screenshot_tutorial2.png
        screenshot_unicode.png
      check.png
      excl.png
      stop.png
      treesheets_logo.png
    donations.html
    file_format_spec.txt
    history.txt
    screenshots.html
    script_reference_update.bat
    script_reference.html
    tutorial.html
  examples/
    contrib/
      help/
        treesheet key quick reference (by WiM) 3 posted-ko.cts
        treesheet key quick reference (by WiM) 3 posted.cts
        treesheet menu including images landscape final-ko.cts
        treesheet menu including images landscape final.cts
      intro-ko.cts
      intro-ru.cts
      Procrastination.cts
      structogram-quicksort.cts
      todo_calendar-zh.cts
      weekly+calendar.cts
      what-i-like-about-treesheets.cts
      yearly-calendar.cts
    imported_from_xml_examples/
      books.cts
      cd_catalog.cts
      menu.cts
      plant_catalog.cts
    complex_eval.cts
    operation-reference-ko.cts
    operation-reference.cts
    personel_file.cts
    sales.cts
    simple_graph.cts
    todo_calendar.cts
    tutorial-de.cts
    tutorial-fr.cts
    tutorial-ko.cts
    tutorial-pt_BR.cts
    tutorial-ru.cts
    tutorial-sp.cts
    tutorial-zh.cts
    tutorial.cts
    unicode_test-ko.cts
    unicode_test.cts
    work_breakdown_structure.cts
  images/
    material/
      toolbar/
        cancel_dark.svg
        cancel.svg
        editcopy_dark.svg
        editcopy.svg
        editpaste_dark.svg
        editpaste.svg
        filenew_dark.svg
        filenew.svg
        fileopen_dark.svg
        fileopen.svg
        filesave_dark.svg
        filesave.svg
        filesaveas_dark.svg
        filesaveas.svg
        image_dark.svg
        image.svg
        newgrid_dark.svg
        newgrid.svg
        replace_dark.svg
        replace.svg
        replaceall_dark.svg
        replaceall.svg
        run_dark.svg
        run.svg
        search_dark.svg
        search.svg
        undo_dark.svg
        undo.svg
        zoomin_dark.svg
        zoomin.svg
        zoomout_dark.svg
        zoomout.svg
      LICENSE.material
      LICENSE.vscode-icons
    nuvola/
      dropdown/
        apply.png
        back.png
        bookcase.png
        bookmark.png
        bug.png
        cache.png
        cancel.png
        clanbomber.png
        color_line.png
        configure.png
        down.png
        edit_add.png
        edit_remove.png
        email.png
        forward.png
        gohome.png
        history.png
        kalarm.png
        kcmprocessor.png
        kcoloredit.png
        kfm_home.png
        kgpg_key3.png
        kgpg.png
        ksysv.png
        kuser.png
        kweather.png
        ledblue.png
        ledgreen.png
        ledlightblue.png
        ledlightgreen.png
        ledorange.png
        ledpurple.png
        ledred.png
        ledyellow.png
        maybe.png
        messagebox_info.png
        messagebox_warning.png
        misc.png
        mozilla.png
        no.png
        noatunloopsong.png
        package_games_arcade.png
        package_network.png
        package_toys.png
        player_pause.png
        player_play.png
        player_stop.png
        up.png
      author
      fold.png
      license.txt
      readme.txt
      thanks.to
    render/
      line_ne.png
      line_nw.png
      line_se.png
      line_sw.png
    icon16.png
    icon32.png
  scripts/
    Export JSON.lobster
    Statistics.lobster
  readme-ko.html
  readme-zh_CN.html
  readme.html
.clang-format
.gitattributes
.gitignore
CMakeLists.txt
README.md
TODO.txt
ZLIB_LICENSE.txt</directory_structure><files>This section contains the contents of the repository&apos;s files.<file path=".github/workflows/build.yml">  1: name: CI
  2: on:
  3:   push:
  4:     branches:
  5:       - master
  6:   pull_request:
  7:     branches:
  8:       - master
  9: jobs:
 10:   build-linux:
 11:     name: Build Linux (${{ matrix.arch }})
 12:     runs-on: ${{ matrix.os }}
 13:     strategy:
 14:       matrix:
 15:         include:
 16:           - arch: x64
 17:             os: ubuntu-latest
 18:           - arch: arm64
 19:             os: ubuntu-24.04-arm
 20:     permissions:
 21:       contents: write
 22:     steps:
 23:     - uses: actions/checkout@v6
 24:     - name: cache build
 25:       uses: actions/cache@v5
 26:       with:
 27:         path: _build/_deps
 28:         key: ${{ runner.os }}-${{ matrix.arch }}-cmake-02-build-${{ hashFiles(&apos;CMakeLists.txt&apos;) }}
 29:         restore-keys: ${{ runner.os }}-${{ matrix.arch }}-cmake-02-build
 30:     - name: apt update
 31:       run: sudo apt-get -o Acquire::Retries=3 update
 32:     - name: install opengl
 33:       run: sudo apt-get -o Acquire::Retries=3 install mesa-common-dev libgl1-mesa-dev libgl1 libglx-mesa0 libxext-dev
 34:     - name: install gtk
 35:       run: sudo apt-get -o Acquire::Retries=3 install libgtk-3-dev
 36:     - name: cmake
 37:       # starting with wxWidgets 3.3.0 we will be able to use wxUSE_SYS_LIBS
 38:       run: |
 39:         cmake -S . -B _build \
 40:         -DCMAKE_INSTALL_PREFIX=/usr \
 41:         -DCPACK_PACKAGING_INSTALL_PREFIX=/usr \
 42:         -DCMAKE_BUILD_TYPE=Release \
 43:         -DwxBUILD_SHARED=OFF \
 44:         -DwxBUILD_INSTALL=OFF \
 45:         -DwxUSE_REGEX=builtin \
 46:         -DwxUSE_ZLIB=builtin \
 47:         -DwxUSE_EXPAT=builtin \
 48:         -DwxUSE_LIBJPEG=builtin \
 49:         -DwxUSE_LIBPNG=builtin \
 50:         -DwxUSE_LIBTIFF=builtin \
 51:         -DwxUSE_LIBWEBP=builtin \
 52:         -DwxUSE_NANOSVG=builtin \
 53:         -DTREESHEETS_VERSION=${{ github.run_number }}
 54:     - name: build and package TreeSheets
 55:       run: cmake --build _build --target package -j4
 56:     - name: Remove epoch from .deb filename
 57:       run: |
 58:         shopt -s extglob
 59:         for file in _build/treesheets_*:*.deb; do mv -v &quot;${file}&quot; &quot;${file/_+([[:digit:]]):/_}&quot;; done
 60:     - name: Create release
 61:       if: github.event_name == &apos;push&apos;
 62:       uses: ncipollo/release-action@v1
 63:       with:
 64:         tag: ${{ github.run_number }}
 65:         allowUpdates: true
 66:         omitBody: true
 67:         commit: ${{ github.sha }}
 68:         artifacts: &quot;_build/treesheets_*.deb&quot;
 69:     - name: Upload artifacts
 70:       if: github.event_name == &apos;pull_request&apos;
 71:       uses: actions/upload-artifact@v4
 72:       with:
 73:         name: linux-builds-${{ matrix.arch }}
 74:         path: _build/treesheets_*.deb
 75:     - name: Remove CPack artifact
 76:       run: rm -f _build/treesheets_*.deb
 77:   build-windows:
 78:     name: Build Windows (${{ matrix.arch }})
 79:     runs-on: ${{ matrix.os }}
 80:     strategy:
 81:       matrix:
 82:         include:
 83:           - arch: x64
 84:             os: windows-latest
 85:             extra_flags: &quot;-A x64&quot;
 86:           - arch: arm64
 87:             os: windows-11-arm
 88:             extra_flags: &quot;-A ARM64 -DENABLE_LOBSTER=OFF&quot; # tinycc currently does not fully support Windows on ARM
 89:     permissions:
 90:       contents: write
 91:     steps:
 92:     - uses: actions/checkout@v6
 93:     - name: cache build
 94:       uses: actions/cache@v5
 95:       with:
 96:         path: _build
 97:         key: ${{ runner.os }}-${{ matrix.arch }}-cmake-02-build-${{ hashFiles(&apos;CMakeLists.txt&apos;) }}
 98:         restore-keys: ${{ runner.os }}-${{ matrix.arch }}-cmake-02-build
 99:     - name: Add msbuild to PATH
100:       uses: microsoft/setup-msbuild@v2
101:     - name: cmake
102:       run: &gt;
103:         cmake -S . -B _build 
104:         -DCMAKE_BUILD_TYPE=Release 
105:         -DwxBUILD_SHARED=OFF 
106:         -DwxBUILD_INSTALL=OFF 
107:         -DTREESHEETS_VERSION=${{ github.run_number }}
108:         ${{ matrix.extra_flags }}
109:     - name: build and package
110:       run: cmake --build _build --config Release --target package -j
111:     - name: Create release
112:       if: github.event_name == &apos;push&apos;
113:       uses: ncipollo/release-action@v1
114:       with:
115:         tag: ${{ github.run_number }}
116:         allowUpdates: true
117:         omitBody: true
118:         commit: ${{ github.sha }}
119:         artifacts: &quot;_build/TreeSheets-*.exe, _build/TreeSheets-*.zip&quot;
120:     - name: Upload artifacts
121:       if: github.event_name == &apos;pull_request&apos;
122:       uses: actions/upload-artifact@v4
123:       with:
124:         name: windows-builds-${{ matrix.arch }}
125:         path: |
126:           _build/TreeSheets-*.exe
127:           _build/TreeSheets-*.zip
128:     - name: Remove CPack artifacts
129:       run: |
130:         Remove-Item -Path _build/TreeSheets-*.exe -Force
131:         Remove-Item -Path _build/TreeSheets-*.zip -Force
132:       shell: powershell
133:   build-mac:
134:     name: Build Mac
135:     runs-on: macos-latest
136:     env:
137:       minmac: 10.15
138:     permissions:
139:       contents: write
140:     steps:
141:     - uses: actions/checkout@v6
142:     - name: cache build
143:       uses: actions/cache@v5
144:       with:
145:         path: _build/_deps
146:         key: ${{ runner.os }}-cmake-03-build-${{ hashFiles(&apos;CMakeLists.txt&apos;) }}
147:         restore-keys: ${{ runner.os }}-cmake-03-build
148:     - name: Prepare Plist
149:       run: /usr/libexec/PlistBuddy -c &quot;Set :LSMinimumSystemVersion $minmac&quot; platform/osx/Info.plist
150:     - name: cmake
151:       run: cmake -S . -B _build -DCMAKE_BUILD_TYPE=Release -DCMAKE_OSX_ARCHITECTURES=&quot;arm64;x86_64&quot; -DCMAKE_OSX_DEPLOYMENT_TARGET=&quot;$minmac&quot; -DwxBUILD_SHARED=OFF -DwxBUILD_INSTALL=OFF -DwxUSE_SYS_LIBS=OFF -DTREESHEETS_VERSION=${{ github.run_number }}
152:     - name: Build and package TreeSheets
153:       run: cmake --build _build --target package -j4
154:     - name: Create release
155:       if: github.event_name == &apos;push&apos;
156:       uses: ncipollo/release-action@v1
157:       with:
158:         tag: ${{ github.run_number }}
159:         allowUpdates: true
160:         omitBody: true
161:         commit: ${{ github.sha }}
162:         artifacts: &quot;_build/TreeSheets-*.dmg&quot;
163:     - name: Upload artifacts
164:       if: github.event_name == &apos;pull_request&apos;
165:       uses: actions/upload-artifact@v4
166:       with:
167:         name: macos-disk-image
168:         path: _build/TreeSheets-*.dmg
169:     - name: Remove CPack artifact
170:       run: rm -f _build/TreeSheets-*.dmg</file><file path="platform/linux/com.strlen.TreeSheets.desktop"> 1: [Desktop Entry]
 2: Version=1.0
 3: Type=Application
 4: Name=TreeSheets
 5: GenericName=Hierarchical Spreadsheet
 6: GenericName[it]=Fogli di Calcolo
 7: Comment=A hierarchical spreadsheet / outliner productivity tool.
 8: TryExec=TreeSheets
 9: Exec=TreeSheets %f
10: Terminal=false
11: Icon=com.strlen.TreeSheets
12: StartupWMClass=TreeSheets
13: MimeType=application/x-treesheets;
14: Categories=Office;Utility;Spreadsheet;TextEditor;
15: Keywords=mindmaps;knowledge;organizer;organiser;information;brainstorming;pim;database;todo;</file><file path="platform/linux/com.strlen.TreeSheets.svg">  1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
  2: &lt;!-- Created with Inkscape (http://www.inkscape.org/) --&gt;
  3: 
  4: &lt;svg
  5:    xmlns:osb=&quot;http://www.openswatchbook.org/uri/2009/osb&quot;
  6:    xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;
  7:    xmlns:cc=&quot;http://creativecommons.org/ns#&quot;
  8:    xmlns:rdf=&quot;http://www.w3.org/1999/02/22-rdf-syntax-ns#&quot;
  9:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;
 10:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
 11:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
 12:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
 13:    width=&quot;680&quot;
 14:    height=&quot;680&quot;
 15:    viewBox=&quot;0 0 179.91666 179.91667&quot;
 16:    version=&quot;1.1&quot;
 17:    id=&quot;svg8&quot;
 18:    inkscape:version=&quot;0.92.5 (2060ec1f9f, 2020-04-08)&quot;
 19:    sodipodi:docname=&quot;treesheets.svg&quot;
 20:    inkscape:export-filename=&quot;/home/matthew/Desktop/treesheets.png&quot;
 21:    inkscape:export-xdpi=&quot;96&quot;
 22:    inkscape:export-ydpi=&quot;96&quot;&gt;
 23:   &lt;defs
 24:      id=&quot;defs2&quot;&gt;
 25:     &lt;linearGradient
 26:        id=&quot;linearGradient901&quot;
 27:        osb:paint=&quot;solid&quot;&gt;
 28:       &lt;stop
 29:          style=&quot;stop-color:#000000;stop-opacity:1;&quot;
 30:          offset=&quot;0&quot;
 31:          id=&quot;stop899&quot; /&gt;
 32:     &lt;/linearGradient&gt;
 33:   &lt;/defs&gt;
 34:   &lt;sodipodi:namedview
 35:      id=&quot;base&quot;
 36:      pagecolor=&quot;#ffffff&quot;
 37:      bordercolor=&quot;#666666&quot;
 38:      borderopacity=&quot;1.0&quot;
 39:      inkscape:pageopacity=&quot;0.0&quot;
 40:      inkscape:pageshadow=&quot;2&quot;
 41:      inkscape:zoom=&quot;0.733172&quot;
 42:      inkscape:cx=&quot;322.37837&quot;
 43:      inkscape:cy=&quot;271.15816&quot;
 44:      inkscape:document-units=&quot;px&quot;
 45:      inkscape:current-layer=&quot;layer1&quot;
 46:      showgrid=&quot;false&quot;
 47:      inkscape:window-width=&quot;1920&quot;
 48:      inkscape:window-height=&quot;1014&quot;
 49:      inkscape:window-x=&quot;0&quot;
 50:      inkscape:window-y=&quot;0&quot;
 51:      inkscape:window-maximized=&quot;1&quot;
 52:      units=&quot;px&quot; /&gt;
 53:   &lt;metadata
 54:      id=&quot;metadata5&quot;&gt;
 55:     &lt;rdf:RDF&gt;
 56:       &lt;cc:Work
 57:          rdf:about=&quot;&quot;&gt;
 58:         &lt;dc:format&gt;image/svg+xml&lt;/dc:format&gt;
 59:         &lt;dc:type
 60:            rdf:resource=&quot;http://purl.org/dc/dcmitype/StillImage&quot; /&gt;
 61:         &lt;dc:title&gt;&lt;/dc:title&gt;
 62:       &lt;/cc:Work&gt;
 63:     &lt;/rdf:RDF&gt;
 64:   &lt;/metadata&gt;
 65:   &lt;g
 66:      inkscape:label=&quot;Layer 1&quot;
 67:      inkscape:groupmode=&quot;layer&quot;
 68:      id=&quot;layer1&quot;
 69:      transform=&quot;translate(-19.704056,-40.32725)&quot;&gt;
 70:     &lt;g
 71:        id=&quot;g23&quot;
 72:        transform=&quot;matrix(1.0592611,0,0,1.0770814,-1.1013222,-16.908959)&quot;&gt;
 73:       &lt;rect
 74:          y=&quot;59.368668&quot;
 75:          x=&quot;25.867487&quot;
 76:          height=&quot;154.58766&quot;
 77:          width=&quot;157.39896&quot;
 78:          id=&quot;rect75-3&quot;
 79:          style=&quot;fill:#ffffff;fill-opacity:1;stroke:#767676;stroke-width:12.45077991;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1&quot; /&gt;
 80:       &lt;path
 81:          inkscape:connector-curvature=&quot;0&quot;
 82:          id=&quot;path15&quot;
 83:          d=&quot;M 37.041672,132.95834 H 170.08929&quot;
 84:          style=&quot;fill:none;stroke:#6d6d6d;stroke-width:3.06500006;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:12.26, 12.26;stroke-dashoffset:0;stroke-opacity:1&quot; /&gt;
 85:       &lt;path
 86:          inkscape:connector-curvature=&quot;0&quot;
 87:          id=&quot;path15-8&quot;
 88:          d=&quot;M 36.588093,163.95238 H 169.63572&quot;
 89:          style=&quot;fill:none;stroke:#6d6d6d;stroke-width:3.06500006;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:12.26000013, 12.26000013;stroke-dashoffset:0;stroke-opacity:1&quot; /&gt;
 90:       &lt;path
 91:          inkscape:connector-curvature=&quot;0&quot;
 92:          id=&quot;path15-5&quot;
 93:          d=&quot;M 129.26786,203.41308 V 70.36547&quot;
 94:          style=&quot;fill:none;stroke:#6d6d6d;stroke-width:3.06500006;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:4;stroke-dasharray:12.26000013, 12.26000013;stroke-dashoffset:0;stroke-opacity:1&quot; /&gt;
 95:       &lt;g
 96:          id=&quot;flowRoot913&quot;
 97:          style=&quot;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:74.66666412px;line-height:1.25;font-family:&apos;Libris ADF Std&apos;;-inkscape-font-specification:&apos;Libris ADF Std, Bold&apos;;font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-feature-settings:normal;text-align:start;letter-spacing:0px;word-spacing:0px;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-opacity:1&quot;
 98:          transform=&quot;matrix(0.76673,0,0,0.76673,893.21672,-3.6280039)&quot;
 99:          aria-label=&quot;TS&quot;&gt;
100:         &lt;path
101:            id=&quot;path825&quot;
102:            style=&quot;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:74.66666412px;font-family:&apos;Libris ADF Std&apos;;-inkscape-font-specification:&apos;Libris ADF Std, Bold&apos;;font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-feature-settings:normal;text-align:start;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-opacity:1&quot;
103:            d=&quot;m -1078.6855,155.60379 c 0,-15.38133 -0.075,-31.35999 -0.075,-46.74133 h 15.1574 l 2.3893,-6.79466 h -41.664 l -2.9867,6.79466 h 17.7707 c 0,8.43734 0.1493,15.456 0.1493,21.056 0,21.87733 -0.7466,25.16267 -2.3146,27.104 z&quot;
104:            inkscape:connector-curvature=&quot;0&quot; /&gt;
105:         &lt;path
106:            id=&quot;path827&quot;
107:            style=&quot;font-style:normal;font-variant:normal;font-weight:bold;font-stretch:normal;font-size:74.66666412px;font-family:&apos;Libris ADF Std&apos;;-inkscape-font-specification:&apos;Libris ADF Std, Bold&apos;;font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-feature-settings:normal;text-align:start;writing-mode:lr-tb;text-anchor:start;fill:#000000;fill-opacity:1;stroke:none;stroke-opacity:1&quot;
108:            d=&quot;m -1064.2003,150.07846 c 2.688,4.40533 11.2747,6.12267 15.9787,7.69067 12.2453,0 18.6667,-10.37867 18.6667,-18.592 0,-3.808 -1.792,-7.24267 -4.928,-9.856 -2.0907,-1.64267 -8.6614,-2.83733 -12.32,-4.85333 -3.8827,-2.09067 -6.1227,-5.67467 -6.1227,-9.25867 0,-2.61333 0.5973,-4.85333 1.6427,-6.34667 0.896,-0.14933 1.7173,-0.224 2.24,-0.224 3.2853,0 8.96,1.86667 11.7226,5.74934 l 7.9894,-5.00267 c -2.7627,-4.40533 -7.5414,-6.72 -11.9467,-6.72 -3.5093,0 -10.0053,1.49333 -12.3947,3.36 -4.928,4.032 -10.4533,8.88533 -10.4533,14.26133 0,3.50934 1.1947,6.64534 3.808,9.10934 h -0.075 c 2.3894,2.464 8.8854,3.65866 11.3494,4.85333 l 1.8666,0.896 c 4.6294,2.24 8.736,4.256 8.736,8.96 0,5.00266 -1.344,7.24266 -2.6133,7.24266 -3.8827,0 -10.1547,-2.016 -12.8427,-6.64533 z&quot;
109:            inkscape:connector-curvature=&quot;0&quot; /&gt;
110:       &lt;/g&gt;
111:     &lt;/g&gt;
112:   &lt;/g&gt;
113: &lt;/svg&gt;</file><file path="platform/linux/com.strlen.TreeSheets.xml"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 2: &lt;mime-info xmlns=&quot;http://www.freedesktop.org/standards/shared-mime-info&quot;&gt;
 3:   &lt;mime-type type=&quot;application/x-treesheets&quot;&gt;
 4:     &lt;comment xml:lang=&quot;en&quot;&gt;TreeSheets document&lt;/comment&gt;
 5:     &lt;icon name=&quot;com.strlen.TreeSheets&quot;/&gt;
 6:     &lt;glob pattern=&quot;*.cts&quot;/&gt;
 7:     &lt;magic priority=&quot;50&quot;&gt;
 8:       &lt;match type=&quot;string&quot; value=&quot;TSFF&quot; offset=&quot;0&quot;/&gt;
 9:     &lt;/magic&gt;
10:     &lt;sub-class-of type=&quot;application/octet-stream&quot;/&gt;
11:   &lt;/mime-type&gt;
12: &lt;/mime-info&gt;</file><file path="platform/osx/Info.plist"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 2: &lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
 3: &lt;plist version=&quot;1.0&quot;&gt;
 4: &lt;dict&gt;
 5: 	&lt;key&gt;CFBundleDevelopmentRegion&lt;/key&gt;
 6: 	&lt;string&gt;English&lt;/string&gt;
 7: 	&lt;key&gt;CFBundleDocumentTypes&lt;/key&gt;
 8: 	&lt;array&gt;
 9: 	&lt;dict&gt;
10: 		&lt;key&gt;CFBundleTypeRole&lt;/key&gt;
11: 		&lt;string&gt;Editor&lt;/string&gt;
12: 		&lt;key&gt;CFBundleTypeExtensions&lt;/key&gt;
13: 		&lt;array&gt;
14: 			&lt;string&gt;cts&lt;/string&gt;
15: 		&lt;/array&gt;
16: 		&lt;key&gt;CFBundleTypeIconFile&lt;/key&gt;
17: 		&lt;string&gt;App&lt;/string&gt;
18: 		&lt;key&gt;CFBundleTypeName&lt;/key&gt;
19: 		&lt;string&gt;${MACOSX_BUNDLE_BUNDLE_NAME}&lt;/string&gt;
20: 	&lt;/dict&gt;
21: 	&lt;/array&gt;
22: 	&lt;key&gt;CFBundleExecutable&lt;/key&gt;
23: 	&lt;string&gt;${MACOSX_BUNDLE_EXECUTABLE_NAME}&lt;/string&gt;
24: 	&lt;key&gt;CFBundleIconFile&lt;/key&gt;
25: 	&lt;string&gt;${MACOSX_BUNDLE_ICON_FILE}&lt;/string&gt;
26: 	&lt;key&gt;CFBundleIdentifier&lt;/key&gt;
27: 	&lt;string&gt;${MACOSX_BUNDLE_GUI_IDENTIFIER}&lt;/string&gt;
28: 	&lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;
29: 	&lt;string&gt;6.0&lt;/string&gt;
30: 	&lt;key&gt;CFBundleLocalizations&lt;/key&gt;
31: 	&lt;array&gt;
32: 		&lt;string&gt;English&lt;/string&gt;
33: 		&lt;string&gt;German&lt;/string&gt;
34: 		&lt;string&gt;French&lt;/string&gt;
35: 		&lt;string&gt;Chinese&lt;/string&gt;
36: 		&lt;string&gt;Portuguese&lt;/string&gt;
37: 		&lt;string&gt;Russian&lt;/string&gt;
38: 		&lt;string&gt;Korean&lt;/string&gt;
39: 	&lt;/array&gt;
40: 	&lt;key&gt;CFBundleName&lt;/key&gt;
41: 	&lt;string&gt;${MACOSX_BUNDLE_BUNDLE_NAME}&lt;/string&gt;
42: 	&lt;key&gt;CFBundlePackageType&lt;/key&gt;
43: 	&lt;string&gt;APPL&lt;/string&gt;
44: 	&lt;key&gt;CFBundleSignature&lt;/key&gt;
45: 	&lt;string&gt;????&lt;/string&gt;
46: 	&lt;key&gt;CFBundleVersion&lt;/key&gt;
47: 	&lt;string&gt;${MACOSX_BUNDLE_BUNDLE_VERSION}&lt;/string&gt;
48: 	&lt;key&gt;CSResourcesFileMapped&lt;/key&gt;
49: 	&lt;true/&gt;
50: 	&lt;key&gt;LSApplicationCategoryType&lt;/key&gt;
51: 	&lt;string&gt;public.app-category.productivity&lt;/string&gt;
52: 	&lt;key&gt;LSMinimumSystemVersion&lt;/key&gt;
53: 	&lt;string&gt;10.15&lt;/string&gt;
54: 	&lt;key&gt;NSHighResolutionCapable&lt;/key&gt;
55: 	&lt;true/&gt;
56: 	&lt;key&gt;NSHumanReadableCopyright&lt;/key&gt;
57: 	&lt;string&gt;${MACOSX_BUNDLE_COPYRIGHT}&lt;/string&gt;
58: 	&lt;key&gt;NSMainNibFile&lt;/key&gt;
59: 	&lt;string&gt;MainMenu&lt;/string&gt;
60: 	&lt;key&gt;NSPrincipalClass&lt;/key&gt;
61: 	&lt;string&gt;NSApplication&lt;/string&gt;
62: &lt;/dict&gt;
63: &lt;/plist&gt;</file><file path="platform/win/treesheets.rc">1: #include &quot;wx/msw/wx.rc&quot;
2: IDI_ICON1 ICON DISCARDABLE &quot;icon1.ico&quot;</file><file path="src/cell.h">  1: /* The evaluation types for a cell.
  2: CT_DATA: &quot;Data&quot;
  3: CT_CODE: &quot;Operation&quot;
  4: CT_VARD: &quot;Variable Assign&quot;
  5: CT_VARU: &quot;Variable Read&quot;
  6: CT_VIEWH: &quot;Horizontal View&quot;
  7: CT_VIEWV: &quot;Vertical View&quot;
  8: */
  9: enum { CT_DATA = 0, CT_CODE, CT_VARD, CT_VIEWH, CT_VARU, CT_VIEWV };
 10: /* The drawstyles for a cell:
 11: */
 12: enum { DS_GRID, DS_BLOBSHIER, DS_BLOBLINE };
 13: /**
 14:     The Cell structure represents the editable cells in the sheet.
 15:     They are mutable structures containing a text and grid object. Along with
 16:     formatting information.
 17: */
 18: struct Cell {
 19:     Cell *parent;
 20:     int sx {0};
 21:     int sy {0};
 22:     int ox {0};
 23:     int oy {0};
 24:     int minx {0};
 25:     int miny {0};
 26:     int ycenteroff {0};
 27:     int txs {0};
 28:     int tys {0};
 29:     int celltype;
 30:     Text text;
 31:     Grid *grid;
 32:     uint cellcolor {g_cellcolor_default};
 33:     uint actualcellcolor {g_cellcolor_default};
 34:     uint textcolor {g_textcolor_default};
 35:     bool tiny {false};
 36:     bool verticaltextandgrid {true};
 37:     wxUint8 drawstyle {DS_GRID};
 38:     Cell(Cell *_p = nullptr, const Cell *_clonefrom = nullptr, int _ct = CT_DATA,
 39:          Grid *_g = nullptr)
 40:         : parent(_p), celltype(_ct), grid(_g) {
 41:         text.cell = this;
 42:         if (_g) _g-&gt;cell = this;
 43:         if (_p) {
 44:             text.relsize = _p-&gt;text.relsize;
 45:             verticaltextandgrid = _p-&gt;verticaltextandgrid;
 46:         }
 47:         if (_clonefrom) CloneStyleFrom(_clonefrom);
 48:     }
 49:     ~Cell() { DELETEP(grid); }
 50:     void Clear() {
 51:         DELETEP(grid);
 52:         text.t.Clear();
 53:         text.image = nullptr;
 54:         Reset();
 55:     }
 56:     bool HasText() const { return !text.t.empty(); }
 57:     bool HasTextSize() const { return HasText() || text.relsize; }
 58:     bool HasTextState() const { return HasTextSize() || text.image; }
 59:     bool HasHeader() const { return HasText() || text.image; }
 60:     bool HasContent() const { return HasHeader() || grid; }
 61:     bool GridShown(Document *doc) const {
 62:         return grid &amp;&amp; (!grid-&gt;folded || this == doc-&gt;currentdrawroot);
 63:     }
 64:     int MinRelsize()  // the smallest relsize is actually the biggest text
 65:     {
 66:         int rs = INT_MAX;
 67:         if (grid) {
 68:             rs = grid-&gt;MinRelsize(rs);
 69:         } else if (HasText()) {
 70:             // the &quot;else&quot; causes oversized titles but a readable grid when you zoom, if only
 71:             // the grid has been shrunk
 72:             rs = text.MinRelsize(rs);
 73:         }
 74:         return rs;
 75:     }
 76:     size_t EstimatedMemoryUse() {
 77:         return sizeof(Cell) + text.EstimatedMemoryUse() + (grid ? grid-&gt;EstimatedMemoryUse() : 0);
 78:     }
 79:     void Layout(Document *doc, wxDC &amp;dc, int depth, int maxcolwidth, bool forcetiny) {
 80:         tiny = text.filtered &amp;&amp; !grid || forcetiny ||
 81:                doc-&gt;PickFont(dc, depth, text.relsize, text.stylebits);
 82:         int ixs = 0, iys = 0;
 83:         if (!tiny) sys-&gt;ImageSize(text.DisplayImage(), ixs, iys);
 84:         int leftoffset = 0;
 85:         if (!HasText()) {
 86:             if (!ixs || !iys) {
 87:                 sx = sy = tiny ? 1 : dc.GetCharHeight();
 88:             } else {
 89:                 leftoffset = dc.GetCharHeight();
 90:             }
 91:         } else {
 92:             text.TextSize(dc, sx, sy, tiny, leftoffset, maxcolwidth);
 93:         }
 94:         if (ixs &amp;&amp; iys) {
 95:             sx += ixs + 2;
 96:             sy = max(iys + 2, sy);
 97:         }
 98:         text.extent = sx + depth * dc.GetCharHeight();
 99:         txs = sx;
100:         tys = sy;
101:         if (GridShown(doc)) {
102:             if (HasHeader()) {
103:                 if (verticaltextandgrid) {
104:                     int osx = sx;
105:                     if (drawstyle == DS_BLOBLINE &amp;&amp; !tiny) sy += 4;
106:                     grid-&gt;Layout(doc, dc, depth, sx, sy, leftoffset, sy, tiny || forcetiny);
107:                     sx = max(sx, osx);
108:                 } else {
109:                     int osy = sy;
110:                     if (drawstyle == DS_BLOBLINE &amp;&amp; !tiny) sx += 18;
111:                     grid-&gt;Layout(doc, dc, depth, sx, sy, sx, 0, tiny || forcetiny);
112:                     sy = max(sy, osy);
113:                 }
114:             } else
115:                 tiny = grid-&gt;Layout(doc, dc, depth, sx, sy, 0, 0, forcetiny);
116:         }
117:         ycenteroff = !verticaltextandgrid ? (sy - tys) / 2 : 0;
118:         if (!tiny) {
119:             sx += g_margin_extra * 2;
120:             sy += g_margin_extra * 2;
121:         }
122:     }
123:     void Render(Document *doc, int bx, int by, wxDC &amp;dc, int depth, int ml, int mr, int mt, int mb,
124:                 int maxcolwidth, int cell_margin) {
125:         // Choose color from celltype (program operations)
126:         switch (celltype) {
127:             case CT_VARD: actualcellcolor = 0xFF8080; break;
128:             case CT_VARU: actualcellcolor = 0xFFA0A0; break;
129:             case CT_VIEWH:
130:             case CT_VIEWV: actualcellcolor = 0x80FF80; break;
131:             case CT_CODE: actualcellcolor = 0x8080FF; break;
132:             default: actualcellcolor = cellcolor; break;
133:         }
134:         uint parentcolor = doc-&gt;Background();
135:         if (parent &amp;&amp; this != doc-&gt;currentdrawroot) {
136:             Cell *p = parent;
137:             while (p &amp;&amp; p-&gt;drawstyle == DS_BLOBLINE)
138:                 p = p == doc-&gt;currentdrawroot ? nullptr : p-&gt;parent;
139:             if (p) parentcolor = p-&gt;actualcellcolor;
140:         }
141:         if (sys-&gt;darkennonmatchingcells &amp;&amp; !text.IsInSearch()) {
142:             auto cp = (uchar *)&amp;actualcellcolor;
143:             loop(i, 4) cp[i] = cp[i] * 800 / 1000;
144:         }
145:         if (drawstyle == DS_GRID &amp;&amp; actualcellcolor != parentcolor) {
146:             DrawRectangle(dc, actualcellcolor, bx - ml, by - mt, sx + ml + mr, sy + mt + mb);
147:         }
148:         if (drawstyle != DS_GRID &amp;&amp; HasContent() &amp;&amp; !tiny) {
149:             if (actualcellcolor == parentcolor) {
150:                 auto cp = (uchar *)&amp;actualcellcolor;
151:                 loop(i, 4) cp[i] = cp[i] * 850 / 1000;
152:             }
153:             dc.SetBrush(wxBrush(LightColor(actualcellcolor)));
154:             dc.SetPen(wxPen(LightColor(actualcellcolor)));
155:             if (drawstyle == DS_BLOBSHIER)
156:                 dc.DrawRoundedRectangle(bx - cell_margin, by - cell_margin, minx + cell_margin * 2,
157:                                         miny + cell_margin * 2, sys-&gt;roundness);
158:             else if (HasHeader())
159:                 dc.DrawRoundedRectangle(bx - cell_margin + g_margin_extra / 2,
160:                                         by - cell_margin + ycenteroff + g_margin_extra / 2,
161:                                         txs + cell_margin * 2 + g_margin_extra,
162:                                         tys + cell_margin * 2 + g_margin_extra, sys-&gt;roundness);
163:             // FIXME: this half a g_margin_extra is a bit of hack
164:         }
165:         dc.SetTextBackground(wxColour(LightColor(actualcellcolor)));
166:         int xoff = verticaltextandgrid ? 0 : text.extent - depth * dc.GetCharHeight();
167:         int yoff = text.Render(doc, bx, by + ycenteroff, depth, dc, xoff, maxcolwidth);
168:         yoff = verticaltextandgrid ? yoff : 0;
169:         if (GridShown(doc)) grid-&gt;Render(doc, bx, by, dc, depth, sx - xoff, sy - yoff, xoff, yoff);
170:     }
171:     void CloneStyleFrom(Cell const *o) {
172:         cellcolor = o-&gt;cellcolor;
173:         textcolor = o-&gt;textcolor;
174:         verticaltextandgrid = o-&gt;verticaltextandgrid;
175:         drawstyle = o-&gt;drawstyle;
176:         text.stylebits = o-&gt;text.stylebits;
177:     }
178:     unique_ptr&lt;Cell&gt; Clone(Cell *_parent) const {
179:         auto c = make_unique&lt;Cell&gt;(_parent, this, celltype,
180:                                    grid ? new Grid(grid-&gt;xs, grid-&gt;ys) : nullptr);
181:         c-&gt;text = text;
182:         c-&gt;text.cell = c.get();
183:         if (grid) { grid-&gt;Clone(c-&gt;grid); }
184:         return c;
185:     }
186:     bool IsInside(int x, int y) const { return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; sx &amp;&amp; y &lt; sy; }
187:     int GetX(Document *doc) const { return ox + (parent ? parent-&gt;GetX(doc) : doc-&gt;hierarchysize); }
188:     int GetY(Document *doc) const { return oy + (parent ? parent-&gt;GetY(doc) : doc-&gt;hierarchysize); }
189:     int Depth() const { return parent ? parent-&gt;Depth() + 1 : 0; }
190:     Cell *Parent(int i) { return i ? parent-&gt;Parent(i - 1) : this; }
191:     Cell *SetParent(Cell *g) {
192:         parent = g;
193:         return this;
194:     }
195:     bool IsParentOf(const Cell *c) {
196:         return c-&gt;parent == this || (c-&gt;parent &amp;&amp; IsParentOf(c-&gt;parent));
197:     }
198:     uint SwapColor(uint c) { return ((c &amp; 0xFF) &lt;&lt; 16) | (c &amp; 0xFF00) | ((c &amp; 0xFF0000) &gt;&gt; 16); }
199:     wxString ToText(int indent, const Selection &amp;sel, int format, Document *doc, bool inheritstyle,
200:                     Cell *root) {
201:         wxString str = text.ToText(indent, sel, format);
202:         if ((format == A_EXPHTMLT || format == A_EXPHTMLTI || format == A_EXPHTMLTE) &amp;&amp;
203:             (text.stylebits &amp; (STYLE_UNDERLINE | STYLE_STRIKETHRU)) &amp;&amp; this != root &amp;&amp;
204:             !str.IsEmpty()) {
205:             wxString spanstyle = L&quot;text-decoration:&quot;;
206:             spanstyle += (text.stylebits &amp; STYLE_UNDERLINE) ? L&quot; underline&quot; : wxEmptyString;
207:             spanstyle += (text.stylebits &amp; STYLE_STRIKETHRU) ? L&quot; line-through&quot; : wxEmptyString;
208:             spanstyle += L&quot;;&quot;;
209:             str.Prepend(L&quot;&lt;span style=\&quot;&quot; + spanstyle + L&quot;\&quot;&gt;&quot;);
210:             str.Append(L&quot;&lt;/span&gt;&quot;);
211:         }
212:         if (format == A_EXPCSV) {
213:             if (grid) return grid-&gt;ToText(indent, sel, format, doc, inheritstyle, root);
214:             str.Replace(L&quot;\&quot;&quot;, L&quot;\&quot;\&quot;&quot;);
215:             return L&quot;\&quot;&quot; + str + L&quot;\&quot;&quot;;
216:         }
217:         if (sel.cursor != sel.cursorend) return str;
218:         str.Append(LINE_SEPARATOR);
219:         if (grid) str.Append(grid-&gt;ToText(indent, sel, format, doc, inheritstyle, root));
220:         if (format == A_EXPXML) {
221:             str.Prepend(L&quot;&gt;&quot;);
222:             if (text.relsize) {
223:                 str.Prepend(L&quot;\&quot;&quot;);
224:                 str.Prepend(wxString() &lt;&lt; -text.relsize);
225:                 str.Prepend(L&quot; relsize=\&quot;&quot;);
226:             }
227:             if (text.stylebits) {
228:                 str.Prepend(L&quot;\&quot;&quot;);
229:                 str.Prepend(wxString() &lt;&lt; text.stylebits);
230:                 str.Prepend(L&quot; stylebits=\&quot;&quot;);
231:             }
232:             if (cellcolor != 0xFFFFFF) {
233:                 str.Prepend(L&quot;\&quot;&quot;);
234:                 str.Prepend(wxString::Format(L&quot;0x%06X&quot;, cellcolor));
235:                 str.Prepend(L&quot; colorbg=\&quot;&quot;);
236:             }
237:             if (textcolor != 0x000000) {
238:                 str.Prepend(L&quot;\&quot;&quot;);
239:                 str.Prepend(wxString::Format(L&quot;0x%06X&quot;, textcolor));
240:                 str.Prepend(L&quot; colorfg=\&quot;&quot;);
241:             }
242:             if (celltype != CT_DATA) {
243:                 str.Prepend(L&quot;\&quot;&quot;);
244:                 str.Prepend(wxString() &lt;&lt; celltype);
245:                 str.Prepend(L&quot; type=\&quot;&quot;);
246:             }
247:             str.Prepend(L&quot;&lt;cell&quot;);
248:             str.Append(L&apos; &apos;, indent);
249:             str.Append(L&quot;&lt;/cell&gt;\n&quot;);
250:         } else if ((format == A_EXPHTMLT || format == A_EXPHTMLTI || format == A_EXPHTMLTE) &amp;&amp;
251:                    this != root) {
252:             wxString style;
253:             if (!inheritstyle || !parent ||
254:                 (text.stylebits &amp; STYLE_BOLD) != (parent-&gt;text.stylebits &amp; STYLE_BOLD))
255:                 style +=
256:                     text.stylebits &amp; STYLE_BOLD ? L&quot;font-weight: bold;&quot; : L&quot;font-weight: normal;&quot;;
257:             if (!inheritstyle || !parent ||
258:                 (text.stylebits &amp; STYLE_ITALIC) != (parent-&gt;text.stylebits &amp; STYLE_ITALIC))
259:                 style +=
260:                     text.stylebits &amp; STYLE_ITALIC ? L&quot;font-style: italic;&quot; : L&quot;font-style: normal;&quot;;
261:             if (!inheritstyle || !parent ||
262:                 (text.stylebits &amp; STYLE_FIXED) != (parent-&gt;text.stylebits &amp; STYLE_FIXED))
263:                 style += text.stylebits &amp; STYLE_FIXED ? L&quot;font-family: monospace;&quot;
264:                                                       : L&quot;font-family: sans-serif;&quot;;
265:             if (!inheritstyle || cellcolor != (parent ? parent-&gt;cellcolor : doc-&gt;Background()))
266:                 style += wxString::Format(L&quot;background-color: #%06X;&quot;, SwapColor(cellcolor));
267:             auto exporttextcolor = IsTag(doc) ? doc-&gt;tags[text.t] : textcolor;
268:             auto parenttextcolor =
269:                 parent ? parent-&gt;IsTag(doc) ? doc-&gt;tags[parent-&gt;text.t] : parent-&gt;textcolor
270:                        : 0x000000;
271:             if (!inheritstyle || exporttextcolor != parenttextcolor)
272:                 style += wxString::Format(L&quot;color: #%06X;&quot;, SwapColor(exporttextcolor));
273:             str.Prepend(style.IsEmpty() ? wxString(L&quot;&lt;td&gt;&quot;)
274:                                         : wxString(L&quot;&lt;td style=\&quot;&quot;) + style + wxString(L&quot;\&quot;&gt;&quot;));
275:             str.Append(L&apos; &apos;, indent);
276:             str.Append(L&quot;&lt;/td&gt;\n&quot;);
277:         } else if (format == A_EXPHTMLB &amp;&amp; (text.t.Len() || grid) &amp;&amp; this != root) {
278:             str.Prepend(L&quot;&lt;li&gt;&quot;);
279:             str.Append(L&apos; &apos;, indent);
280:             str.Append(L&quot;&lt;/li&gt;\n&quot;);
281:         } else if (format == A_EXPHTMLO &amp;&amp; text.t.Len()) {
282:             wxString h = wxString(L&quot;h&quot;) + wxChar(L&apos;0&apos; + indent / 2) + L&quot;&gt;&quot;;
283:             str.Prepend(L&quot;&lt;&quot; + h);
284:             str.Append(L&apos; &apos;, indent);
285:             str.Append(L&quot;&lt;/&quot; + h + L&quot;\n&quot;);
286:         }
287:         str.Pad(indent, L&apos; &apos;, false);
288:         return str;
289:     }
290:     void RelSize(int dir, int zoomdepth) {
291:         text.RelSize(dir, zoomdepth);
292:         if (grid) grid-&gt;RelSize(dir, zoomdepth);
293:     }
294:     void Reset() { ox = oy = sx = sy = minx = miny = ycenteroff = 0; }
295:     void ResetChildren() {
296:         Reset();
297:         if (grid) grid-&gt;ResetChildren();
298:     }
299:     void ResetLayout() {
300:         Reset();
301:         if (parent) parent-&gt;ResetLayout();
302:     }
303:     void LazyLayout(Document *doc, wxDC &amp;dc, int depth, int maxcolwidth, bool forcetiny) {
304:         if (sx == 0) {
305:             Layout(doc, dc, depth, maxcolwidth, forcetiny);
306:             minx = sx;
307:             miny = sy;
308:         } else {
309:             sx = minx;
310:             sy = miny;
311:         }
312:     }
313:     void AddUndo(Document *doc) {
314:         ResetLayout();
315:         doc-&gt;AddUndo(this);
316:     }
317:     void Save(wxDataOutputStream &amp;dos, Cell *ocs) const {
318:         dos.Write8(celltype);
319:         dos.Write32(cellcolor);
320:         dos.Write32(textcolor);
321:         dos.Write8(drawstyle);
322:         uint cellflags = this == ocs ? TS_SELECTION_MASK : 0;
323:         if (HasTextState()) {
324:             cellflags |= grid ? TS_BOTH : TS_TEXT;
325:             dos.Write8(cellflags);
326:             text.Save(dos);
327:             if (grid) grid-&gt;Save(dos, ocs);
328:         } else if (grid) {
329:             cellflags |= TS_GRID;
330:             dos.Write8(cellflags);
331:             grid-&gt;Save(dos, ocs);
332:         } else {
333:             cellflags |= TS_NEITHER;
334:             dos.Write8(cellflags);
335:         }
336:     }
337:     Grid *AddGrid(int x = 1, int y = 1) {
338:         if (!grid) {
339:             grid = new Grid(x, y, this);
340:             grid-&gt;InitCells(this);
341:             if (parent) grid-&gt;CloneStyleFrom(parent-&gt;grid);
342:         }
343:         return grid;
344:     }
345:     Cell *LoadGrid(wxDataInputStream &amp;dis, int &amp;numcells, int &amp;textbytes, Cell *&amp;ics) {
346:         int xs = dis.Read32();
347:         auto g = new Grid(xs, dis.Read32());
348:         grid = g;
349:         g-&gt;cell = this;
350:         if (!g-&gt;LoadContents(dis, numcells, textbytes, ics)) return nullptr;
351:         return this;
352:     }
353:     static Cell *LoadWhich(wxDataInputStream &amp;dis, Cell *_p, int &amp;numcells, int &amp;textbytes, Cell *&amp;ics) {
354:         auto c = new Cell(_p, nullptr, dis.Read8());
355:         numcells++;
356:         if (sys-&gt;versionlastloaded &gt;= 8) {
357:             c-&gt;cellcolor = dis.Read32() &amp; 0xFFFFFF;
358:             c-&gt;textcolor = dis.Read32() &amp; 0xFFFFFF;
359:         }
360:         if (sys-&gt;versionlastloaded &gt;= 15) c-&gt;drawstyle = dis.Read8();
361:         int ts = dis.Read8();
362:         if (ts &amp; TS_SELECTION_MASK) {
363:             ics = c;
364:             ts &amp;= ~TS_SELECTION_MASK;
365:         }
366:         switch (ts) {
367:             case TS_BOTH:
368:             case TS_TEXT:
369:                 c-&gt;text.Load(dis);
370:                 textbytes += c-&gt;text.t.Len();
371:                 if (ts == TS_TEXT) return c;
372:             case TS_GRID: return c-&gt;LoadGrid(dis, numcells, textbytes, ics);
373:             case TS_NEITHER: return c;
374:             default: return nullptr;
375:         }
376:     }
377:     unique_ptr&lt;Cell&gt; Eval(auto &amp;ev) const {
378:         // Evaluates the internal grid if it exists, otherwise, evaluate the text.
379:         return grid ? grid-&gt;Eval(ev) : text.Eval(ev);
380:     }
381:     void Paste(Document *document, const Cell *original, Selection &amp;selection) {
382:         parent-&gt;AddUndo(document);
383:         ResetLayout();
384:         if (original-&gt;HasText()) {
385:             if (!HasText() || !selection.TextEdit()) {
386:                 cellcolor = original-&gt;cellcolor;
387:                 textcolor = original-&gt;textcolor;
388:                 text.stylebits = original-&gt;text.stylebits;
389:             }
390:             text.Insert(document, original-&gt;text.t, selection, false);
391:         }
392:         if (original-&gt;text.image) text.image = original-&gt;text.image;
393:         if (original-&gt;grid) {
394:             auto gridclone = new Grid(original-&gt;grid-&gt;xs, original-&gt;grid-&gt;ys);
395:             gridclone-&gt;cell = this;
396:             original-&gt;grid-&gt;Clone(gridclone);
397:             // Note: deleting grid may invalidate c if its a child of grid, so clear it.
398:             original = nullptr;
399:             DELETEP(grid);  // FIXME: could merge instead?
400:             grid = gridclone;
401:             if (!HasText())
402:                 grid-&gt;MergeWithParent(parent-&gt;grid, selection, document);  // deletes grid/this.
403:         }
404:     }
405:     Cell *FindNextSearchMatch(const wxString &amp;s, Cell *best, Cell *selected, bool &amp;lastwasselected,
406:                               bool reverse) {
407:         if (reverse &amp;&amp; grid)
408:             best = grid-&gt;FindNextSearchMatch(s, best, selected, lastwasselected, reverse);
409:         if ((sys-&gt;casesensitivesearch ? text.t.Find(s) : text.t.Lower().Find(s)) &gt;= 0) {
410:             if (lastwasselected) best = this;
411:             lastwasselected = false;
412:         }
413:         if (selected == this) lastwasselected = true;
414:         if (!reverse &amp;&amp; grid)
415:             best = grid-&gt;FindNextSearchMatch(s, best, selected, lastwasselected, reverse);
416:         return best;
417:     }
418:     Cell *FindNextFilterMatch(Cell *best, Cell *selected, bool &amp;lastwasselected) {
419:         if (!text.filtered) {
420:             if (lastwasselected) best = this;
421:             lastwasselected = false;
422:         }
423:         if (selected == this) lastwasselected = true;
424:         if (grid) best = grid-&gt;FindNextFilterMatch(best, selected, lastwasselected);
425:         return best;
426:     }
427:     Cell *FindLink(const Selection &amp;sel, Cell *link, Cell *best, bool &amp;lastthis, bool &amp;stylematch,
428:                    bool forward, bool image) {
429:         if (grid) best = grid-&gt;FindLink(sel, link, best, lastthis, stylematch, forward, image);
430:         if (link == this) {
431:             lastthis = true;
432:             return best;
433:         }
434:         if (image ? link-&gt;text.image == text.image
435:                   : link-&gt;text.ToText(0, sel, A_EXPTEXT) == text.t) {
436:             if (link-&gt;text.stylebits != text.stylebits || link-&gt;cellcolor != cellcolor ||
437:                 link-&gt;textcolor != textcolor) {
438:                 if (!stylematch) best = nullptr;
439:                 stylematch = true;
440:             } else if (stylematch) {
441:                 return best;
442:             }
443:             if (!best || lastthis) {
444:                 lastthis = false;
445:                 return this;
446:             }
447:         }
448:         return best;
449:     }
450:     void FindReplaceAll(const wxString &amp;s, const wxString &amp;ls) {
451:         if (grid) grid-&gt;FindReplaceAll(s, ls);
452:         text.ReplaceStr(s, ls);
453:     }
454:     Cell *FindExact(const wxString &amp;s) {
455:         return text.t == s ? this : (grid ? grid-&gt;FindExact(s) : nullptr);
456:     }
457:     void ImageRefCount(bool includefolded) {
458:         if (grid) grid-&gt;ImageRefCount(includefolded);
459:         if (text.image) text.image-&gt;trefc++;
460:     }
461:     void SetBorder(int width) {
462:         if (grid) grid-&gt;user_grid_outer_spacing = width;
463:     }
464:     void ColorChange(Document *doc, int which, uint color) {
465:         switch (which) {
466:             case A_CELLCOLOR: cellcolor = color; break;
467:             case A_TEXTCOLOR:
468:                 if (IsTag(doc)) {
469:                     doc-&gt;tags[text.t] = color;
470:                 } else {
471:                     textcolor = color;
472:                 }
473:                 break;
474:             case A_BORDCOLOR:
475:                 if (parent &amp;&amp; parent-&gt;grid) parent-&gt;grid-&gt;bordercolor = color;
476:                 break;
477:         }
478:         text.WasEdited();
479:     }
480:     void SetGridTextLayout(int ds, bool vert, bool noset) {
481:         if (!noset) verticaltextandgrid = vert;
482:         if (ds != -1) drawstyle = ds;
483:         if (grid) grid-&gt;SetGridTextLayout(ds, vert, noset, grid-&gt;SelectAll());
484:     }
485:     bool IsTag(Document *doc) { return doc-&gt;tags.contains(text.t); }
486:     void MaxDepthLeaves(int curdepth, int &amp;maxdepth, int &amp;leaves) {
487:         if (curdepth &gt; maxdepth) maxdepth = curdepth;
488:         if (grid)
489:             grid-&gt;MaxDepthLeaves(curdepth + 1, maxdepth, leaves);
490:         else
491:             leaves++;
492:     }
493:     int ColWidth() {
494:         return parent ? parent-&gt;grid-&gt;colwidths[parent-&gt;grid-&gt;FindCell(this).x]
495:                       : sys-&gt;defaultmaxcolwidth;
496:     }
497:     void CollectCells(auto &amp;itercells, bool recurse = true) {
498:         itercells.push_back(this);
499:         if (grid &amp;&amp; recurse) grid-&gt;CollectCells(itercells);
500:     }
501:     Cell *Graph() {
502:         auto n = text.GetNum();
503:         text.t.Clear();
504:         text.t.Append(L&apos;|&apos;, n);
505:         return this;
506:     }
507: };</file><file path="src/document.h">   1: struct UndoItem {
   2:     vector&lt;Selection&gt; path;
   3:     vector&lt;Selection&gt; selpath;
   4:     Selection sel;
   5:     unique_ptr&lt;Cell&gt; clone;
   6:     size_t estimated_size {0};
   7:     uintptr_t cloned_from;  // May be dead.
   8:     int generation {0};
   9: };
  10: struct Document {
  11:     TSCanvas *canvas {nullptr};
  12:     Cell *root {nullptr};
  13:     Selection prev;
  14:     Selection hover;
  15:     Selection selected;
  16:     Selection begindrag;
  17:     int isctrlshiftdrag;
  18:     int scrollx;
  19:     int scrolly;
  20:     int maxx;
  21:     int maxy;
  22:     int centerx {0};
  23:     int centery {0};
  24:     int layoutxs;
  25:     int layoutys;
  26:     int hierarchysize;
  27:     int fgutter {6};
  28:     int lasttextsize;
  29:     int laststylebits;
  30:     Cell *currentdrawroot;  // for use during Render() calls
  31:     vector&lt;unique_ptr&lt;UndoItem&gt;&gt; undolist;
  32:     vector&lt;unique_ptr&lt;UndoItem&gt;&gt; redolist;
  33:     vector&lt;Selection&gt; drawpath;
  34:     int pathscalebias {0};
  35:     wxString filename {L&quot;&quot;};
  36:     long lastmodsinceautosave {0};
  37:     long undolistsizeatfullsave {0};
  38:     long lastsave {wxGetLocalTime()};
  39:     bool modified {false};
  40:     bool tmpsavesuccess {true};
  41:     wxDataObjectComposite *dndobjc {new wxDataObjectComposite()};
  42:     wxTextDataObject *dndobjt {new wxTextDataObject()};
  43:     wxBitmapDataObject *dndobji {new wxBitmapDataObject()};
  44:     wxFileDataObject *dndobjf {new wxFileDataObject()};
  45:     struct Printout : wxPrintout {
  46:         Document *doc;
  47:         Printout(Document *d) : wxPrintout(L&quot;printout&quot;), doc(d) {}
  48:         bool OnPrintPage(int page) {
  49:             auto dc = GetDC();
  50:             if (!dc) return false;
  51:             doc-&gt;Print(*dc, *this);
  52:             return true;
  53:         }
  54:         bool OnBeginDocument(int startPage, int endPage) {
  55:             return wxPrintout::OnBeginDocument(startPage, endPage);
  56:         }
  57:         void GetPageInfo(int *minPage, int *maxPage, int *selPageFrom, int *selPageTo) {
  58:             *minPage = 1;
  59:             *maxPage = 1;
  60:             *selPageFrom = 1;
  61:             *selPageTo = 1;
  62:         }
  63:         bool HasPage(int pageNum) { return pageNum == 1; }
  64:     };
  65:     bool while_printing {false};
  66:     wxPrintData printData;
  67:     wxPageSetupDialogData pageSetupData;
  68:     uint printscale {0};
  69:     bool scaledviewingmode {false};
  70:     bool paintscrolltoselection {true};
  71:     double currentviewscale {1.0};
  72:     bool searchfilter {false};
  73:     int editfilter {0};
  74:     wxDateTime lastmodificationtime;
  75:     map&lt;wxString, uint&gt; tags;
  76:     vector&lt;Cell *&gt; itercells;
  77:     #define loopcellsin(par, c) \
  78:         CollectCells(par);      \
  79:         loopv(_i, itercells) for (auto c = itercells[_i]; c; c = nullptr)
  80:     #define loopallcells(c)     \
  81:         CollectCells(root); \
  82:         for (auto c : itercells)
  83:     #define loopallcellssel(c, rec) \
  84:         CollectCellsSel(rec);     \
  85:         for (auto c : itercells)
  86:     Document() {
  87:         ResetFont();
  88:         pageSetupData = printData;
  89:         pageSetupData.SetMarginTopLeft(wxPoint(15, 15));
  90:         pageSetupData.SetMarginBottomRight(wxPoint(15, 15));
  91:         dndobjc-&gt;Add(dndobjt);
  92:         dndobjc-&gt;Add(dndobji);
  93:         dndobjc-&gt;Add(dndobjf);
  94:     }
  95:     ~Document() { DELETEP(root); }
  96:     uint Background() { return root ? root-&gt;cellcolor : 0xFFFFFF; }
  97:     void InitCellSelect(Cell *initialselected, int xsize, int ysize) {
  98:         if (!initialselected) {
  99:             SetSelect(Selection(root-&gt;grid, 0, 0, 1, 1));
 100:             return;
 101:         }
 102:         SetSelect(initialselected-&gt;parent-&gt;grid-&gt;FindCell(initialselected));
 103:         selected.xs = xsize;
 104:         selected.ys = ysize;
 105:     }
 106:     void InitWith(Cell *root, const wxString &amp;filename, Cell *initialselected, int xsize, int ysize) {
 107:         this-&gt;root = root;
 108:         InitCellSelect(initialselected, xsize, ysize);
 109:         ChangeFileName(filename, false);
 110:     }
 111:     void UpdateFileName(int page = -1) {
 112:         sys-&gt;frame-&gt;SetPageTitle(filename, modified ? (lastmodsinceautosave ? L&quot;*&quot; : L&quot;+&quot;) : L&quot;&quot;,
 113:                                  page);
 114:     }
 115:     void ChangeFileName(const wxString &amp;newfilename, bool checkext) {
 116:         filename = newfilename;
 117:         if (checkext) {
 118:             wxFileName wxfn(filename);
 119:             if (!wxfn.HasExt()) filename.Append(L&quot;.cts&quot;);
 120:         }
 121:         UpdateFileName();
 122:     }
 123:     const wxChar *SaveDB(bool *success, bool istempfile = false, int page = -1) {
 124:         if (filename.empty()) return _(L&quot;Save cancelled.&quot;);
 125:         auto ocs = selected.GetFirst();
 126:         auto start_saving_time = wxGetLocalTimeMillis();
 127:         {  // limit destructors
 128:             wxBusyCursor wait;
 129:             if (!istempfile &amp;&amp; sys-&gt;makebaks &amp;&amp; ::wxFileExists(filename)) {
 130:                 ::wxRenameFile(filename, sys-&gt;BakName(filename));
 131:             }
 132:             auto savefilename = istempfile ? sys-&gt;TmpName(filename) : filename;
 133:             wxFFileOutputStream fos(savefilename);
 134:             if (!fos.IsOk()) {
 135:                 if (!istempfile)
 136:                     wxMessageBox(
 137:                         _(L&quot;Error writing TreeSheets file! (try saving under new filename).&quot;),
 138:                         savefilename.wx_str(), wxOK, sys-&gt;frame);
 139:                 return _(L&quot;Error writing to file.&quot;);
 140:             }
 141:             wxDataOutputStream sos(fos);
 142:             fos.Write(&quot;TSFF&quot;, 4);
 143:             char vers = TS_VERSION;
 144:             fos.Write(&amp;vers, 1);
 145:             sos.Write8(selected.xs);
 146:             sos.Write8(selected.ys);
 147:             sos.Write8(ocs ? drawpath.size() : 0);  // zoom level
 148:             RefreshImageRefCount(true);
 149:             int realindex = 0;
 150:             loopv(i, sys-&gt;imagelist) {
 151:                 if (auto &amp;image = *sys-&gt;imagelist[i]; image.trefc) {
 152:                     fos.PutC(image.type);
 153:                     sos.WriteDouble(image.display_scale);
 154:                     wxInt64 imagelen(image.data.size());
 155:                     sos.Write64(imagelen);
 156:                     fos.Write(image.data.data(), imagelen);
 157:                     image.savedindex = realindex++;
 158:                 }
 159:             }
 160:             fos.Write(&quot;D&quot;, 1);
 161:             wxZlibOutputStream zos(fos, 9);
 162:             if (!zos.IsOk()) return _(L&quot;Zlib error while writing file.&quot;);
 163:             wxDataOutputStream dos(zos);
 164:             root-&gt;Save(dos, ocs);
 165:             for (auto &amp;[tag, color] : tags) {
 166:                 dos.WriteString(tag);
 167:                 dos.Write32(color);
 168:             }
 169:             dos.WriteString(wxEmptyString);
 170:         }
 171:         lastmodsinceautosave = 0;
 172:         lastsave = wxGetLocalTime();
 173:         auto end_saving_time = wxGetLocalTimeMillis();
 174:         if (!istempfile) {
 175:             undolistsizeatfullsave = undolist.size();
 176:             modified = false;
 177:             tmpsavesuccess = true;
 178:             sys-&gt;FileUsed(filename, this);
 179:             if (::wxFileExists(sys-&gt;TmpName(filename))) ::wxRemoveFile(sys-&gt;TmpName(filename));
 180:         }
 181:         if (sys-&gt;autohtmlexport) {
 182:             ExportFile(sys-&gt;ExtName(filename, L&quot;.html&quot;),
 183:                        sys-&gt;autohtmlexport == A_AUTOEXPORT_HTML_WITH_IMAGES - A_AUTOEXPORT_HTML_NONE
 184:                            ? A_EXPHTMLTE
 185:                            : A_EXPHTMLT,
 186:                        false);
 187:         }
 188:         UpdateFileName(page);
 189:         if (success) *success = true;
 190:         sys-&gt;frame-&gt;SetStatus(wxString::Format(_(L&quot;Saved %s successfully (in %lld milliseconds).&quot;),
 191:                                                filename.c_str(),
 192:                                                end_saving_time - start_saving_time)
 193:                                   .c_str());
 194:         return _(L&quot;&quot;);
 195:     }
 196:     void DrawSelect(wxDC &amp;dc, Selection &amp;s) {
 197:         if (!s.grid) return;
 198:         ResetFont();
 199:         s.grid-&gt;DrawSelect(this, dc, s);
 200:     }
 201:     void UpdateHover(wxDC &amp;dc, int mx, int my) {
 202:         ResetFont();
 203:         int x, y;
 204:         canvas-&gt;CalcUnscrolledPosition(mx, my, &amp;x, &amp;y);
 205:         prev = hover;
 206:         hover = Selection();
 207:         auto drawroot = WalkPath(drawpath);
 208:         if (drawroot-&gt;grid)
 209:             drawroot-&gt;grid-&gt;FindXY(
 210:                 this, x / currentviewscale - centerx / currentviewscale - hierarchysize,
 211:                 y / currentviewscale - centery / currentviewscale - hierarchysize, dc);
 212:     }
 213:     void ScrollIfSelectionOutOfView(Selection &amp;sel) {
 214:         if (!scaledviewingmode) {
 215:             // required, since sizes of things may have been reset by the last editing operation
 216:             int canvasw, canvash;
 217:             canvas-&gt;GetClientSize(&amp;canvasw, &amp;canvash);
 218:             if ((layoutys &gt; canvash || layoutxs &gt; canvasw) &amp;&amp; sel.grid) {
 219:                 wxRect r = sel.grid-&gt;GetRect(this, sel);
 220:                 if (r.y &lt; scrolly || r.y + r.height &gt; maxy || r.x &lt; scrollx || r.x + r.width &gt; maxx) {
 221:                     canvas-&gt;Scroll(r.width &gt; canvasw || r.x &lt; scrollx ? r.x
 222:                                    : r.x + r.width &gt; maxx             ? r.x + r.width - canvasw
 223:                                                                       : scrollx,
 224:                                    r.height &gt; canvash || r.y &lt; scrolly ? r.y
 225:                                    : r.y + r.height &gt; maxy             ? r.y + r.height - canvash
 226:                                                                        : scrolly);
 227:                 }
 228:             }
 229:         }
 230:     }
 231:     void ScrollOrZoom(bool zoomiftiny = false) {
 232:         if (!selected.grid) return;
 233:         auto drawroot = WalkPath(drawpath);
 234:         // If we jumped to a cell which may be insided a folded cell, we have to unfold it
 235:         // because the rest of the code doesn&apos;t deal with a selection that is invisible :)
 236:         for (auto cg = selected.grid-&gt;cell; cg; cg = cg-&gt;parent) {
 237:             // Unless we&apos;re under the drawroot, no need to unfold further.
 238:             if (cg == drawroot) break;
 239:             if (cg-&gt;grid-&gt;folded) {
 240:                 cg-&gt;grid-&gt;folded = false;
 241:                 cg-&gt;ResetLayout();
 242:                 cg-&gt;ResetChildren();
 243:             }
 244:         }
 245:         for (auto cg = selected.grid-&gt;cell; cg; cg = cg-&gt;parent)
 246:             if (cg == drawroot) {
 247:                 if (zoomiftiny) ZoomTiny();
 248:                 paintscrolltoselection = true;
 249:                 canvas-&gt;Refresh();
 250:                 return;
 251:             }
 252:         Zoom(-100, false);
 253:         if (zoomiftiny) ZoomTiny();
 254:     }
 255:     void ZoomTiny() {
 256:         if (auto c = selected.GetCell(); c &amp;&amp; c-&gt;tiny) {
 257:             Zoom(1);  // seems to leave selection box in a weird location?
 258:             if (selected.GetCell() != c) ZoomTiny();
 259:         }
 260:     }
 261:     void ResetCursor() {
 262:         if (selected.grid) selected.SetCursorEdit(this, selected.TextEdit());
 263:     }
 264:     void SetSelect(const Selection &amp;sel = Selection()) {
 265:         selected = sel;
 266:         begindrag = sel;
 267:     }
 268:     void SelectUp() {
 269:         if (!isctrlshiftdrag || isctrlshiftdrag == 3 || begindrag.EqLoc(selected)) return;
 270:         auto cell = selected.GetCell();
 271:         if (!cell) return;
 272:         auto targetcell = begindrag.ThinExpand(this);
 273:         selected = begindrag;
 274:         if (targetcell) {
 275:             auto is_parent = targetcell-&gt;IsParentOf(cell);
 276:             auto targetcell_parent = targetcell-&gt;parent;  // targetcell may be deleted.
 277:             targetcell-&gt;Paste(this, cell, begindrag);
 278:             // If is_parent, cell has been deleted already.
 279:             if (isctrlshiftdrag == 1 &amp;&amp; !is_parent) {
 280:                 cell-&gt;parent-&gt;AddUndo(this);
 281:                 Selection cellselection = cell-&gt;parent-&gt;grid-&gt;FindCell(cell);
 282:                 cell-&gt;parent-&gt;grid-&gt;MultiCellDeleteSub(this, cellselection);
 283:             }
 284:             hover = targetcell_parent ? targetcell_parent-&gt;grid-&gt;FindCell(targetcell) : Selection();
 285:             SetSelect(hover);
 286:             wxClientDC dc(canvas); // TODO: replace with wxInfoDC starting wxWidgets 3.3.0
 287:             Layout(dc);
 288:         }
 289:     }
 290:     void DoubleClick() {
 291:         SetSelect(hover);
 292:         if (selected.Thin() &amp;&amp; selected.grid) {
 293:             selected.SelAll();
 294:         } else if (Cell *c = selected.GetCell()) {
 295:             selected.EnterEditOnly(this);
 296:             c-&gt;text.SelectWord(selected);
 297:             begindrag = selected;
 298:         }
 299:     }
 300:     void Drop() {
 301:         switch (dndobjc-&gt;GetReceivedFormat().GetType()) {
 302:             case wxDF_BITMAP: PasteOrDrop(*dndobji); break;
 303:             case wxDF_FILENAME: PasteOrDrop(*dndobjf); break;
 304:             case wxDF_TEXT:
 305:             case wxDF_UNICODETEXT: PasteOrDrop(*dndobjt);
 306:             default:;
 307:         }
 308:     }
 309:     auto CopyEntireCells(wxString &amp;s, int action) {
 310:         sys-&gt;clipboardcopy = s;
 311:         auto html =
 312:             selected.grid-&gt;ConvertToText(selected, 0, action == A_COPYWI ? A_EXPHTMLTI : A_EXPHTMLT,
 313:                                          this, false, currentdrawroot);
 314:         return new wxHTMLDataObject(html);
 315:     }
 316:     void Copy(int action) {
 317:         auto c = selected.GetCell();
 318:         sys-&gt;clipboardcopy = wxEmptyString;
 319:         switch (action) {
 320:             case A_DRAGANDDROP: {
 321:                 sys-&gt;cellclipboard = c ? c-&gt;Clone(nullptr) : selected.grid-&gt;CloneSel(selected);
 322:                 wxDataObjectComposite dragdata;
 323:                 if (c &amp;&amp; !c-&gt;text.t &amp;&amp; c-&gt;text.image) {
 324:                     auto image = c-&gt;text.image;
 325:                     if (!image-&gt;data.empty()) {
 326:                         auto &amp;[it, mime] = imagetypes.at(image-&gt;type);
 327:                         auto bitmap = ConvertBufferToWxBitmap(image-&gt;data, it);
 328:                         dragdata.Add(new wxBitmapDataObject(bitmap));
 329:                     }
 330:                 } else {
 331:                     auto s = selected.grid-&gt;ConvertToText(selected, 0, A_EXPTEXT, this, false,
 332:                                                           currentdrawroot);
 333:                     dragdata.Add(new wxTextDataObject(s));
 334:                     if (!selected.TextEdit()) {
 335:                         auto htmlobj = CopyEntireCells(s, wxID_COPY);
 336:                         dragdata.Add(htmlobj);
 337:                     }
 338:                 }
 339:                 wxDropSource dragsource(dragdata, canvas);
 340:                 dragsource.DoDragDrop(true);
 341:                 break;
 342:             }
 343:             case A_COPYCT: {
 344:                 sys-&gt;cellclipboard = nullptr;
 345:                 auto clipboardtextdata = new wxDataObjectComposite();
 346:                 wxString s = &quot;&quot;;
 347:                 loopallcellssel(c, true) if (c-&gt;text.t.Len()) s += c-&gt;text.t + &quot; &quot;;
 348:                 if (!selected.TextEdit()) sys-&gt;clipboardcopy = s;
 349:                 clipboardtextdata-&gt;Add(new wxTextDataObject(s));
 350:                 if (wxTheClipboard-&gt;Open()) {
 351:                     wxTheClipboard-&gt;SetData(clipboardtextdata);
 352:                     wxTheClipboard-&gt;Close();
 353:                 }
 354:                 break;
 355:             }
 356:             case wxID_COPY:
 357:             case A_COPYWI:
 358:             default: {
 359:                 sys-&gt;cellclipboard = c ? c-&gt;Clone(nullptr) : selected.grid-&gt;CloneSel(selected);
 360:                 if (c &amp;&amp; !c-&gt;text.t &amp;&amp; c-&gt;text.image) {
 361:                     auto image = c-&gt;text.image;
 362:                     if (!image-&gt;data.empty() &amp;&amp; wxTheClipboard-&gt;Open()) {
 363:                         auto &amp;[it, mime] = imagetypes.at(image-&gt;type);
 364:                         auto bitmap = ConvertBufferToWxBitmap(image-&gt;data, it);
 365:                         wxTheClipboard-&gt;SetData(new wxBitmapDataObject(bitmap));
 366:                         wxTheClipboard-&gt;Close();
 367:                     }
 368:                 } else {
 369:                     auto clipboarddata = new wxDataObjectComposite();
 370:                     auto s = selected.grid-&gt;ConvertToText(selected, 0, A_EXPTEXT, this, false,
 371:                                                           currentdrawroot);
 372:                     clipboarddata-&gt;Add(new wxTextDataObject(s));
 373:                     if (!selected.TextEdit()) {
 374:                         auto htmlobj = CopyEntireCells(s, action);
 375:                         clipboarddata-&gt;Add(htmlobj);
 376:                     }
 377:                     if (wxTheClipboard-&gt;Open()) {
 378:                         wxTheClipboard-&gt;SetData(clipboarddata);
 379:                         wxTheClipboard-&gt;Close();
 380:                     }
 381:                 }
 382:                 break;
 383:             }
 384:         }
 385:         return;
 386:     }
 387:     void ZoomSetDrawPath(int dir, bool fromroot = true) {
 388:         int len = max(0, (fromroot ? 0 : drawpath.size()) + dir);
 389:         if (!len &amp;&amp; drawpath.empty()) return;
 390:         if (dir &gt; 0) {
 391:             if (!selected.grid) return;
 392:             auto c = selected.GetCell();
 393:             CreatePath(c &amp;&amp; c-&gt;grid ? c : selected.grid-&gt;cell, drawpath);
 394:         } else if (dir &lt; 0) {
 395:             auto drawroot = WalkPath(drawpath);
 396:             if (drawroot-&gt;grid &amp;&amp; drawroot-&gt;grid-&gt;folded)
 397:                 SetSelect(drawroot-&gt;parent-&gt;grid-&gt;FindCell(drawroot));
 398:         }
 399:         if (auto diff = static_cast&lt;int&gt;(drawpath.size()) - max(0, len); diff &gt; 0)
 400:             drawpath.erase(drawpath.begin(), drawpath.begin() + diff);
 401:     }
 402:     void Zoom(int dir, bool fromroot = false) {
 403:         ZoomSetDrawPath(dir, fromroot);
 404:         auto drawroot = WalkPath(drawpath);
 405:         if (selected.GetCell() == drawroot &amp;&amp; drawroot-&gt;grid) {
 406:             // We can&apos;t have the drawroot selected, so we must move the selection to the children.
 407:             SetSelect(Selection(drawroot-&gt;grid, 0, 0, drawroot-&gt;grid-&gt;xs, drawroot-&gt;grid-&gt;ys));
 408:         }
 409:         drawroot-&gt;ResetLayout();
 410:         drawroot-&gt;ResetChildren();
 411:         paintscrolltoselection = true;
 412:         canvas-&gt;Refresh();
 413:     }
 414:     const wxChar *NoSel() { return _(L&quot;This operation requires a selection.&quot;); }
 415:     const wxChar *OneCell() { return _(L&quot;This operation works on a single selected cell only.&quot;); }
 416:     const wxChar *NoThin() { return _(L&quot;This operation doesn&apos;t work on thin selections.&quot;); }
 417:     const wxChar *NoGrid() { return _(L&quot;This operation requires a cell that contains a grid.&quot;); }
 418:     const wxChar *Wheel(int dir, bool alt, bool ctrl, bool shift, bool hierarchical = true) {
 419:         if (!dir) return nullptr;
 420:         if (alt) {
 421:             if (!selected.grid) return NoSel();
 422:             if (selected.xs &gt; 0) {
 423:                 if (!LastUndoSameCellAny(selected.grid-&gt;cell)) selected.grid-&gt;cell-&gt;AddUndo(this);
 424:                 selected.grid-&gt;ResizeColWidths(dir, selected, hierarchical);
 425:                 selected.grid-&gt;cell-&gt;ResetLayout();
 426:                 selected.grid-&gt;cell-&gt;ResetChildren();
 427:                 paintscrolltoselection = true;
 428:                 canvas-&gt;Refresh();
 429:                 return dir &gt; 0 ? _(L&quot;Column width increased.&quot;) : _(L&quot;Column width decreased.&quot;);
 430:             }
 431:             return L&quot;nothing to resize&quot;;
 432:         } else if (shift) {
 433:             if (!selected.grid) return NoSel();
 434:             selected.grid-&gt;cell-&gt;AddUndo(this);
 435:             selected.grid-&gt;ResetChildren();
 436:             selected.grid-&gt;RelSize(-dir, selected, pathscalebias);
 437:             paintscrolltoselection = true;
 438:             canvas-&gt;Refresh();
 439:             return dir &gt; 0 ? _(L&quot;Text size increased.&quot;) : _(L&quot;Text size decreased.&quot;);
 440:         } else if (ctrl) {
 441:             int steps = abs(dir);
 442:             dir = sign(dir);
 443:             loop(i, steps) Zoom(dir);
 444:             return dir &gt; 0 ? _(L&quot;Zoomed in.&quot;) : _(L&quot;Zoomed out.&quot;);
 445:         } else {
 446:             ASSERT(0);
 447:             return nullptr;
 448:         }
 449:     }
 450:     void Layout(wxDC &amp;dc) {
 451:         ResetFont();
 452:         dc.SetUserScale(1, 1);
 453:         currentdrawroot = WalkPath(drawpath);
 454:         int psb = currentdrawroot == root ? 0 : currentdrawroot-&gt;MinRelsize();
 455:         if (psb &lt; 0 || psb == INT_MAX) psb = 0;
 456:         if (psb != pathscalebias) currentdrawroot-&gt;ResetChildren();
 457:         pathscalebias = psb;
 458:         currentdrawroot-&gt;LazyLayout(this, dc, 0, currentdrawroot-&gt;ColWidth(), false);
 459:         ResetFont();
 460:         PickFont(dc, 0, 0, 0);
 461:         hierarchysize = 0;
 462:         for (Cell *p = currentdrawroot-&gt;parent; p; p = p-&gt;parent)
 463:             if (p-&gt;text.t.Len()) hierarchysize += dc.GetCharHeight();
 464:         hierarchysize += fgutter;
 465:         layoutxs = currentdrawroot-&gt;sx + hierarchysize + fgutter;
 466:         layoutys = currentdrawroot-&gt;sy + hierarchysize + fgutter;
 467:     }
 468:     void ShiftToCenter(wxDC &amp;dc) {
 469:         int dlx = dc.DeviceToLogicalX(0);
 470:         int dly = dc.DeviceToLogicalY(0);
 471:         dc.SetDeviceOrigin(dlx &gt; 0 ? -dlx : centerx, dly &gt; 0 ? -dly : centery);
 472:         dc.SetUserScale(currentviewscale, currentviewscale);
 473:     }
 474:     void Render(wxDC &amp;dc) {
 475:         ResetFont();
 476:         PickFont(dc, 0, 0, 0);
 477:         dc.SetTextForeground(*wxLIGHT_GREY);
 478:         int i = 0;
 479:         for (auto p = currentdrawroot-&gt;parent; p; p = p-&gt;parent)
 480:             if (p-&gt;text.t.Len()) {
 481:                 int off = hierarchysize - dc.GetCharHeight() * ++i;
 482:                 auto s = p-&gt;text.t;
 483:                 if (static_cast&lt;int&gt;(s.Len()) &gt; sys-&gt;defaultmaxcolwidth) {
 484:                     // should take the width of these into account for layoutys, but really, the
 485:                     // worst that can happen on a thin window is that its rendering gets cut off
 486:                     s = s.Left(sys-&gt;defaultmaxcolwidth) + L&quot;...&quot;;
 487:                 }
 488:                 dc.DrawText(s, off, off);
 489:             }
 490:         dc.SetTextForeground(sys-&gt;darkmode ? *wxWHITE : *wxBLACK);
 491:         currentdrawroot-&gt;Render(this, hierarchysize, hierarchysize, dc, 0, 0, 0, 0, 0,
 492:                                 currentdrawroot-&gt;ColWidth(), 0);
 493:     }
 494:     void SelectClick(bool right = false) {
 495:         begindrag = Selection();
 496:         if (!(right &amp;&amp; hover.IsInside(selected))) {
 497:             if (selected.GetCell() == hover.GetCell() &amp;&amp; hover.GetCell())
 498:                 hover.EnterEditOnly(this);
 499:             else
 500:                 hover.ExitEdit(this);
 501:             SetSelect(hover);
 502:         }
 503:     }
 504:     void Draw(wxDC &amp;dc) {
 505:         if (!root) return;
 506:         canvas-&gt;GetClientSize(&amp;maxx, &amp;maxy);
 507:         Layout(dc);
 508:         dc.SetBackground(wxBrush(wxColor(LightColor(Background()))));
 509:         dc.Clear();
 510:         double xscale = maxx / static_cast&lt;double&gt;(layoutxs);
 511:         double yscale = maxy / static_cast&lt;double&gt;(layoutys);
 512:         currentviewscale = min(xscale, yscale);
 513:         if (currentviewscale &gt; 5)
 514:             currentviewscale = 5;
 515:         else if (currentviewscale &lt; 1)
 516:             currentviewscale = 1;
 517:         if (scaledviewingmode &amp;&amp; currentviewscale &gt; 1) {
 518:             dc.SetUserScale(currentviewscale, currentviewscale);
 519:             canvas-&gt;SetVirtualSize(maxx, maxy);
 520:             maxx /= currentviewscale;
 521:             maxy /= currentviewscale;
 522:             scrollx = scrolly = 0;
 523:         } else {
 524:             currentviewscale = 1;
 525:             dc.SetUserScale(1, 1);
 526:             canvas-&gt;SetVirtualSize(layoutxs, layoutys);
 527:             canvas-&gt;GetViewStart(&amp;scrollx, &amp;scrolly);
 528:             maxx += scrollx;
 529:             maxy += scrolly;
 530:         }
 531:         centerx = sys-&gt;centered &amp;&amp; !scrollx &amp;&amp; maxx &gt; layoutxs
 532:                       ? (maxx - layoutxs) / 2 * currentviewscale
 533:                       : 0;
 534:         centery = sys-&gt;centered &amp;&amp; !scrolly &amp;&amp; maxy &gt; layoutys
 535:                       ? (maxy - layoutys) / 2 * currentviewscale
 536:                       : 0;
 537:         ShiftToCenter(dc);
 538:         Render(dc);
 539:         DrawSelect(dc, selected);
 540:         if (paintscrolltoselection) {
 541:             wxTheApp-&gt;CallAfter([this](){
 542:                 ScrollIfSelectionOutOfView(selected);
 543:                 #ifdef __WXMAC__
 544:                     canvas-&gt;Refresh();
 545:                 #endif
 546:             });
 547:             paintscrolltoselection = false;
 548:         }
 549:         if (scaledviewingmode) { dc.SetUserScale(1, 1); }
 550:     }
 551:     void Print(wxDC &amp;dc, wxPrintout &amp;po) {
 552:         Layout(dc);
 553:         maxx = layoutxs;
 554:         maxy = layoutys;
 555:         scrollx = scrolly = 0;
 556:         po.FitThisSizeToPage(printscale ? wxSize(printscale, 1) : wxSize(maxx, maxy));
 557:         wxRect fitRect = po.GetLogicalPageRect();
 558:         wxCoord xoff = (fitRect.width - maxx) / 2;
 559:         wxCoord yoff = (fitRect.height - maxy) / 2;
 560:         po.OffsetLogicalOrigin(xoff, yoff);
 561:         while_printing = true;
 562:         Render(dc);
 563:         while_printing = false;
 564:     }
 565:     int TextSize(int depth, int relsize) {
 566:         return max(g_mintextsize(), g_deftextsize - depth - relsize + pathscalebias);
 567:     }
 568:     bool FontIsMini(int textsize) { return textsize == g_mintextsize(); }
 569:     bool PickFont(wxDC &amp;dc, int depth, int relsize, int stylebits) {
 570:         int textsize = TextSize(depth, relsize);
 571:         if (textsize != lasttextsize || stylebits != laststylebits) {
 572:             wxFont font(textsize - (while_printing || scaledviewingmode),
 573:                         stylebits &amp; STYLE_FIXED ? wxFONTFAMILY_TELETYPE : wxFONTFAMILY_DEFAULT,
 574:                         stylebits &amp; STYLE_ITALIC ? wxFONTSTYLE_ITALIC : wxFONTSTYLE_NORMAL,
 575:                         stylebits &amp; STYLE_BOLD ? wxFONTWEIGHT_BOLD : wxFONTWEIGHT_NORMAL,
 576:                         (stylebits &amp; STYLE_UNDERLINE) != 0,
 577:                         stylebits &amp; STYLE_FIXED ? sys-&gt;defaultfixedfont : sys-&gt;defaultfont);
 578:             if (stylebits &amp; STYLE_STRIKETHRU) font.SetStrikethrough(true);
 579:             dc.SetFont(font);
 580:             lasttextsize = textsize;
 581:             laststylebits = stylebits;
 582:         }
 583:         return FontIsMini(textsize);
 584:     }
 585:     void ResetFont() {
 586:         lasttextsize = INT_MAX;
 587:         laststylebits = -1;
 588:     }
 589:     bool CheckForChanges() {
 590:         if (modified) {
 591:             ThreeChoiceDialog tcd(sys-&gt;frame, filename,
 592:                                   _(L&quot;Changes have been made, are you sure you wish to continue?&quot;),
 593:                                   _(L&quot;Save and Close&quot;), _(L&quot;Discard Changes&quot;), _(L&quot;Cancel&quot;));
 594:             switch (tcd.Run()) {
 595:                 case 0: {
 596:                     bool success = false;
 597:                     Save(false, &amp;success);
 598:                     return !success;
 599:                 }
 600:                 case 1: return false;
 601:                 default:
 602:                 case 2: return true;
 603:             }
 604:         }
 605:         return false;
 606:     }
 607:     void RemoveTmpFile() {
 608:         if (!filename.empty() &amp;&amp; ::wxFileExists(sys-&gt;TmpName(filename)))
 609:             ::wxRemoveFile(sys-&gt;TmpName(filename));
 610:     }
 611:     bool CloseDocument() {
 612:         bool keep = CheckForChanges();
 613:         if (!keep) RemoveTmpFile();
 614:         return keep;
 615:     }
 616:     const wxChar *Export(const wxChar *fmt, const wxChar *pat, const wxChar *message, int action) {
 617:         wxFileName tsfn(filename);
 618:         auto exportfilename = ::wxFileSelector(message, tsfn.GetPath(), tsfn.GetName(), fmt, pat,
 619:                                                wxFD_SAVE | wxFD_OVERWRITE_PROMPT | wxFD_CHANGE_DIR);
 620:         if (exportfilename.empty()) return _(L&quot;Export cancelled.&quot;);
 621:         wxFileName expfn(exportfilename);
 622:         if (!expfn.HasExt()) {
 623:             expfn.SetExt(fmt);
 624:             exportfilename = expfn.GetFullPath();
 625:         }
 626:         return ExportFile(exportfilename, action, true);
 627:     }
 628:     wxBitmap GetBitmap() {
 629:         maxx = layoutxs;
 630:         maxy = layoutys;
 631:         scrollx = scrolly = 0;
 632:         wxBitmap bm(maxx, maxy, 24);
 633:         wxMemoryDC mdc(bm);
 634:         DrawRectangle(mdc, Background(), 0, 0, maxx, maxy);
 635:         Layout(mdc);
 636:         Render(mdc);
 637:         return bm;
 638:     }
 639:     wxBitmap GetSubBitmap(const Selection &amp;sel) {
 640:         wxRect r = sel.grid-&gt;GetRect(this, sel, true);
 641:         return GetBitmap().GetSubBitmap(r);
 642:     }
 643:     void RefreshImageRefCount(bool includefolded) {
 644:         loopv(i, sys-&gt;imagelist) sys-&gt;imagelist[i]-&gt;trefc = 0;
 645:         root-&gt;ImageRefCount(includefolded);
 646:     }
 647:     const wxChar *ExportFile(const wxString &amp;filename, int action, bool currentview) {
 648:         Cell *exportroot = currentview ? currentdrawroot : root;
 649:         if (action == A_EXPIMAGE) {
 650:             auto bitmap = GetBitmap();
 651:             canvas-&gt;Refresh();
 652:             if (!bitmap.SaveFile(filename, wxBITMAP_TYPE_PNG)) return _(L&quot;Error writing PNG file!&quot;);
 653:         } else {
 654:             wxFFileOutputStream fos(filename, L&quot;w+b&quot;);
 655:             if (!fos.IsOk()) {
 656:                 wxMessageBox(_(L&quot;Error exporting file!&quot;), filename.wx_str(), wxOK, sys-&gt;frame);
 657:                 return _(L&quot;Error writing to file!&quot;);
 658:             }
 659:             wxTextOutputStream dos(fos);
 660:             wxString content = exportroot-&gt;ToText(0, Selection(), action, this, true, exportroot);
 661:             switch (action) {
 662:                 case A_EXPXML:
 663:                     dos.WriteString(
 664:                         L&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;
 665:                         L&quot;&lt;!DOCTYPE cell [\n&quot;
 666:                         L&quot;&lt;!ELEMENT cell (grid)&gt;\n&quot;
 667:                         L&quot;&lt;!ELEMENT grid (row*)&gt;\n&quot;
 668:                         L&quot;&lt;!ELEMENT row (cell*)&gt;\n&quot;
 669:                         L&quot;]&gt;\n&quot;);
 670:                     dos.WriteString(content);
 671:                     break;
 672:                 case A_EXPHTMLT:
 673:                 case A_EXPHTMLTI:
 674:                 case A_EXPHTMLTE:
 675:                 case A_EXPHTMLB:
 676:                 case A_EXPHTMLO:
 677:                     dos.WriteString(
 678:                         L&quot;&lt;!DOCTYPE html&gt;\n&quot;
 679:                         L&quot;&lt;html&gt;\n&lt;head&gt;\n&lt;style&gt;\n&quot;
 680:                         L&quot;body { font-family: sans-serif; }\n&quot;
 681:                         L&quot;table, th, td { border: 1px solid #A0A0A0; border-collapse: collapse;&quot;
 682:                         L&quot; padding: 3px; vertical-align: top; }\n&quot;
 683:                         L&quot;li { }\n&lt;/style&gt;\n&quot;
 684:                         L&quot;&lt;title&gt;export of TreeSheets file &quot;);
 685:                     dos.WriteString(this-&gt;filename);
 686:                     dos.WriteString(
 687:                         L&quot;&lt;/title&gt;\n&lt;meta charset=\&quot;UTF-8\&quot; /&gt;\n&quot;
 688:                         L&quot;&lt;/head&gt;\n&lt;body&gt;\n&quot;);
 689:                     dos.WriteString(content);
 690:                     dos.WriteString(L&quot;&lt;/body&gt;\n&lt;/html&gt;\n&quot;);
 691:                     break;
 692:                 case A_EXPCSV:
 693:                 case A_EXPTEXT: dos.WriteString(content); break;
 694:             }
 695:             if (action == A_EXPHTMLTE) ExportAllImages(filename, exportroot);
 696:         }
 697:         return _(L&quot;File exported successfully.&quot;);
 698:     }
 699:     const wxChar *Save(bool saveas, bool *success = nullptr) {
 700:         if (!saveas &amp;&amp; !filename.empty()) { return SaveDB(success); }
 701:         auto filename = ::wxFileSelector(_(L&quot;Choose TreeSheets file to save:&quot;), L&quot;&quot;, L&quot;&quot;, L&quot;cts&quot;,
 702:                                          _(L&quot;TreeSheets Files (*.cts)|*.cts|All Files (*.*)|*.*&quot;),
 703:                                          wxFD_SAVE | wxFD_OVERWRITE_PROMPT | wxFD_CHANGE_DIR);
 704:         if (filename.empty()) return _(L&quot;Save cancelled.&quot;);  // avoid name being set to &quot;&quot;
 705:         ChangeFileName(filename, true);
 706:         return SaveDB(success);
 707:     }
 708:     void AutoSave(bool minimized, int page) {
 709:         if (sys-&gt;autosave &amp;&amp; tmpsavesuccess &amp;&amp; !filename.empty() &amp;&amp; lastmodsinceautosave &amp;&amp;
 710:             (lastmodsinceautosave + 60 &lt; wxGetLocalTime() || lastsave + 300 &lt; wxGetLocalTime() ||
 711:              minimized)) {
 712:             tmpsavesuccess = false;
 713:             SaveDB(&amp;tmpsavesuccess, true, page);
 714:         }
 715:     }
 716:     const wxChar *Key(int uk, int k, bool alt, bool ctrl, bool shift, bool &amp;unprocessed) {
 717:         if (uk == WXK_NONE || k &lt; &apos; &apos; &amp;&amp; k || k == WXK_DELETE) {
 718:             switch (k) {
 719:                 case WXK_BACK:  // no menu shortcut available in wxwidgets
 720:                     if (!ctrl) return Action(A_BACKSPACE);
 721:                     break;  // Prevent Ctrl+H from being treated as Backspace
 722:                 case WXK_RETURN:
 723:                     return Action(shift  ? A_ENTERGRID
 724:                                   : ctrl ? A_ENTERCELL_JUMPTOSTART
 725:                                          : A_ENTERCELL);
 726:                 case WXK_ESCAPE:  // docs say it can be used as a menu accelerator, but it does not
 727:                                   // trigger from there?
 728:                     return Action(A_CANCELEDIT);
 729:                 #ifdef WIN32  // works fine on Linux, not sure OS X
 730:                 case WXK_PAGEDOWN: canvas-&gt;CursorScroll(0, g_scrollratecursor); return nullptr;
 731:                 case WXK_PAGEUP: canvas-&gt;CursorScroll(0, -g_scrollratecursor); return nullptr;
 732:                 #endif
 733:                 #ifdef __WXGTK__
 734:                 // Due to limitations within GTK, wxGTK does not support specific keycodes 
 735:                 // as accelerator keys for menu items. See wxWidgets documentation for the 
 736:                 // wxMenuItem class in order to obtain more details. This is why we implement 
 737:                 // the missing handling of these accelerator keys in the following section.
 738:                 // Please be aware that the custom implementation has the downside of these
 739:                 // &quot;accelerator keys&quot; being suppressed in the menu items on wxGTK.
 740:                     case WXK_DELETE: return Action(A_DELETE);
 741:                     case WXK_LEFT:
 742:                         return Action(shift ? (ctrl ? A_SCLEFT : A_SLEFT)
 743:                                             : (ctrl ? A_MLEFT : A_LEFT));
 744:                     case WXK_RIGHT:
 745:                         return Action(shift ? (ctrl ? A_SCRIGHT : A_SRIGHT)
 746:                                             : (ctrl ? A_MRIGHT : A_RIGHT));
 747:                     case WXK_UP:
 748:                         return Action(shift ? (ctrl ? A_SCUP : A_SUP) : (ctrl ? A_MUP : A_UP));
 749:                     case WXK_DOWN:
 750:                         return Action(shift ? (ctrl ? A_SCDOWN : A_SDOWN)
 751:                                             : (ctrl ? A_MDOWN : A_DOWN));
 752:                     case WXK_HOME:
 753:                         return Action(shift ? (ctrl ? A_SHOME : A_SHOME)
 754:                                             : (ctrl ? A_CHOME : A_HOME));
 755:                     case WXK_END:
 756:                         return Action(shift ? (ctrl ? A_SEND : A_SEND) : (ctrl ? A_CEND : A_END));
 757:                     case WXK_TAB:
 758:                         if (ctrl &amp;&amp; !shift) {
 759:                             // WXK_CONTROL_I (italics) arrives as the same keycode as WXK_TAB + ctrl
 760:                             // on Linux?? They&apos;re both keycode 9 in defs.h We ignore it here, such
 761:                             // that CTRL+I works, but it means only CTRL+SHIFT+TAB works on Linux as
 762:                             // a way to switch tabs.
 763:                             // Also, even though we ignore CTRL+TAB, and it is not assigned in the
 764:                             // menus, it still has the
 765:                             // effect of de-selecting
 766:                             // the current tab (requires a click to re-activate). FIXME??
 767:                             break;
 768:                         }
 769:                         return Action(shift ? (ctrl ? A_PREVFILE : A_PREV)
 770:                                             : (ctrl ? A_NEXTFILE : A_NEXT));
 771:                     case WXK_PAGEUP:
 772:                         if (ctrl) return Action(alt ? A_INCWIDTHNH : A_ZOOMIN);
 773:                         if (shift) return Action(A_INCSIZE);
 774:                         if (!alt) canvas-&gt;CursorScroll(0, -g_scrollratecursor);
 775:                         return nullptr;
 776:                     case WXK_PAGEDOWN:
 777:                         if (ctrl) return Action(alt ? A_DECWIDTHNH : A_ZOOMOUT);
 778:                         if (shift) return Action(A_DECSIZE);
 779:                         if (!alt) canvas-&gt;CursorScroll(0, g_scrollratecursor);
 780:                         return nullptr;
 781:                 #endif
 782:             }
 783:         } else if (uk &gt;= &apos; &apos;) {
 784:             if (!selected.grid) return NoSel();
 785:             auto c = selected.ThinExpand(this);
 786:             if (!c) {
 787:                 selected.Wrap(this);
 788:                 c = selected.GetCell();
 789:             }
 790:             c-&gt;AddUndo(this);  // FIXME: not needed for all keystrokes, or at least, merge all
 791:                                // keystroke undos within same cell
 792:             c-&gt;text.Key(this, uk, selected);
 793:             paintscrolltoselection = true;
 794:             canvas-&gt;Refresh();
 795:             return nullptr;
 796:         }
 797:         unprocessed = true;
 798:         return nullptr;
 799:     }
 800:     const wxChar *Action(int action) {
 801:         switch (action) {
 802:             case wxID_EXECUTE:
 803:                 root-&gt;AddUndo(this);
 804:                 sys-&gt;evaluator.Eval(root);
 805:                 root-&gt;ResetChildren();
 806:                 selected = Selection();
 807:                 begindrag = Selection();
 808:                 canvas-&gt;Refresh();
 809:                 return _(L&quot;Evaluation finished.&quot;);
 810:             case wxID_UNDO:
 811:                 if (undolist.size()) {
 812:                     Undo(undolist, redolist);
 813:                     return nullptr;
 814:                 } else {
 815:                     return _(L&quot;Nothing more to undo.&quot;);
 816:                 }
 817:             case wxID_REDO:
 818:                 if (redolist.size()) {
 819:                     Undo(redolist, undolist, true);
 820:                     return nullptr;
 821:                 } else {
 822:                     return _(L&quot;Nothing more to redo.&quot;);
 823:                 }
 824:             case wxID_SAVE: return Save(false);
 825:             case wxID_SAVEAS: return Save(true);
 826:             case A_SAVEALL: sys-&gt;SaveAll(); return nullptr;
 827:             case A_EXPXML: return Export(L&quot;xml&quot;, L&quot;*.xml&quot;, _(L&quot;Choose XML file to write&quot;), action);
 828:             case A_EXPHTMLT:
 829:             case A_EXPHTMLTE:
 830:             case A_EXPHTMLB:
 831:             case A_EXPHTMLO:
 832:                 return Export(L&quot;html&quot;, L&quot;*.html&quot;, _(L&quot;Choose HTML file to write&quot;), action);
 833:             case A_EXPTEXT:
 834:                 return Export(L&quot;txt&quot;, L&quot;*.txt&quot;, _(L&quot;Choose Text file to write&quot;), action);
 835:             case A_EXPIMAGE:
 836:                 return Export(L&quot;png&quot;, L&quot;*.png&quot;, _(L&quot;Choose PNG file to write&quot;), action);
 837:             case A_EXPCSV: {
 838:                 int maxdepth = 0, leaves = 0;
 839:                 currentdrawroot-&gt;MaxDepthLeaves(0, maxdepth, leaves);
 840:                 if (maxdepth &gt; 1)
 841:                     return _(
 842:                         L&quot;Cannot export grid that is not flat (zoom the view to the desired grid, and/or use Flatten).&quot;);
 843:                 return Export(L&quot;csv&quot;, L&quot;*.csv&quot;, _(L&quot;Choose CSV file to write&quot;), action);
 844:             }
 845:             case A_IMPXML:
 846:             case A_IMPXMLA:
 847:             case A_IMPTXTI:
 848:             case A_IMPTXTC:
 849:             case A_IMPTXTS:
 850:             case A_IMPTXTT: {
 851:                 wxArrayString filenames;
 852:                 GetFilesFromUser(filenames, sys-&gt;frame, _(L&quot;Please select file(s) to import:&quot;),
 853:                                  _(L&quot;*.*&quot;));
 854:                 const wxChar *message = nullptr;
 855:                 for (auto &amp;filename : filenames) message = sys-&gt;Import(filename, action);
 856:                 return message;
 857:             }
 858:             case wxID_OPEN: {
 859:                 wxArrayString filenames;
 860:                 GetFilesFromUser(filenames, sys-&gt;frame,
 861:                                  _(L&quot;Please select TreeSheets file(s) to load:&quot;),
 862:                                  _(L&quot;TreeSheets Files (*.cts)|*.cts|All Files (*.*)|*.*&quot;));
 863:                 const wxChar *message = nullptr;
 864:                 for (auto &amp;filename : filenames) message = sys-&gt;Open(filename);
 865:                 return message;
 866:             }
 867:             case wxID_CLOSE: {
 868:                 if (sys-&gt;frame-&gt;notebook-&gt;GetPageCount() &lt;= 1) {
 869:                     sys-&gt;frame-&gt;fromclosebox = false;
 870:                     sys-&gt;frame-&gt;Close();
 871:                     return nullptr;
 872:                 }
 873:                 if (!CloseDocument()) {
 874:                     int pagenumber = sys-&gt;frame-&gt;notebook-&gt;GetSelection();
 875:                     // sys-&gt;frame-&gt;notebook-&gt;AdvanceSelection();
 876:                     sys-&gt;frame-&gt;notebook-&gt;DeletePage(pagenumber);
 877:                 }
 878:                 return nullptr;
 879:             }
 880:             case wxID_NEW: {
 881:                 int size = static_cast&lt;int&gt;(
 882:                     ::wxGetNumberFromUser(_(L&quot;What size grid would you like to start with?&quot;),
 883:                                           _(L&quot;size:&quot;), _(L&quot;New Sheet&quot;), 10, 1, 25, sys-&gt;frame));
 884:                 if (size &lt; 0) return _(L&quot;New file cancelled.&quot;);
 885:                 sys-&gt;InitDB(size);
 886:                 sys-&gt;frame-&gt;GetCurrentTab()-&gt;Refresh();
 887:                 return nullptr;
 888:             }
 889:             case wxID_ABOUT: {
 890:                 wxAboutDialogInfo info;
 891:                 info.SetName(L&quot;TreeSheets&quot;);
 892:                 info.SetVersion(wxT(PACKAGE_VERSION));
 893:                 info.SetCopyright(L&quot;(C) 2025 Wouter van Oortmerssen and Tobias Predel&quot;);
 894:                 auto desc = wxString::Format(L&quot;%s\n\n%s &quot; wxVERSION_STRING,
 895:                                              _(L&quot;The Free Form Hierarchical Information Organizer&quot;),
 896:                                              _(L&quot;Uses&quot;));
 897:                 info.SetDescription(desc);
 898:                 wxAboutBox(info);
 899:                 return nullptr;
 900:             }
 901:             case wxID_HELP: sys-&gt;LoadTutorial(); return nullptr;
 902:             case A_HELP_OP_REF: sys-&gt;LoadOpRef(); return nullptr;
 903:             case A_TUTORIALWEBPAGE:
 904:                 #ifdef __WXMAC__
 905:                     wxLaunchDefaultBrowser(L&quot;file://&quot; +
 906:                                        sys-&gt;frame-&gt;app-&gt;GetDocPath(L&quot;docs/tutorial.html&quot;));  // RbrtPntn
 907:                 #else
 908:                     wxLaunchDefaultBrowser(sys-&gt;frame-&gt;app-&gt;GetDocPath(L&quot;docs/tutorial.html&quot;));
 909:                 #endif
 910:                 return nullptr;
 911:             #ifdef ENABLE_LOBSTER
 912:                 case A_SCRIPTREFERENCE:
 913:                     #ifdef __WXMAC__
 914:                         wxLaunchDefaultBrowser(L&quot;file://&quot; +
 915:                                            sys-&gt;frame-&gt;app-&gt;GetDocPath(L&quot;docs/script_reference.html&quot;));  // RbrtPntn
 916:                     #else
 917:                         wxLaunchDefaultBrowser(sys-&gt;frame-&gt;app-&gt;GetDocPath(L&quot;docs/script_reference.html&quot;));
 918:                     #endif
 919:                     return nullptr;
 920:             #endif
 921:             case A_ZOOMIN:
 922:                 return Wheel(1, false, true,
 923:                              false);  // Zoom( 1, dc); return &quot;zoomed in (menu)&quot;;
 924:             case A_ZOOMOUT:
 925:                 return Wheel(-1, false, true,
 926:                              false);  // Zoom(-1, dc); return &quot;zoomed out (menu)&quot;;
 927:             case A_INCSIZE: return Wheel(1, false, false, true);
 928:             case A_DECSIZE: return Wheel(-1, false, false, true);
 929:             case A_INCWIDTH: return Wheel(1, true, false, false);
 930:             case A_DECWIDTH: return Wheel(-1, true, false, false);
 931:             case A_INCWIDTHNH: return Wheel(1, true, false, false, false);
 932:             case A_DECWIDTHNH: return Wheel(-1, true, false, false, false);
 933:             case wxID_SELECT_FONT:
 934:             case A_SET_FIXED_FONT: {
 935:                 wxFontData fdat;
 936:                 fdat.SetInitialFont(wxFont(
 937:                     g_deftextsize,
 938:                     action == wxID_SELECT_FONT ? wxFONTFAMILY_DEFAULT : wxFONTFAMILY_TELETYPE,
 939:                     wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL, false,
 940:                     action == wxID_SELECT_FONT ? sys-&gt;defaultfont : sys-&gt;defaultfixedfont));
 941:                 if (wxFontDialog fd(sys-&gt;frame, fdat); fd.ShowModal() == wxID_OK) {
 942:                     wxFont font = fd.GetFontData().GetChosenFont();
 943:                     g_deftextsize = min(20, max(10, font.GetPointSize()));
 944:                     sys-&gt;cfg-&gt;Write(L&quot;defaultfontsize&quot;, g_deftextsize);
 945:                     switch (action) {
 946:                         case wxID_SELECT_FONT:
 947:                             sys-&gt;defaultfont = font.GetFaceName();
 948:                             sys-&gt;cfg-&gt;Write(L&quot;defaultfont&quot;, sys-&gt;defaultfont);
 949:                             break;
 950:                         case A_SET_FIXED_FONT:
 951:                             sys-&gt;defaultfixedfont = font.GetFaceName();
 952:                             sys-&gt;cfg-&gt;Write(L&quot;defaultfixedfont&quot;, sys-&gt;defaultfixedfont);
 953:                             break;
 954:                     }
 955:                     // root-&gt;ResetChildren();
 956:                     sys-&gt;frame-&gt;TabsReset();  // ResetChildren on all
 957:                     canvas-&gt;Refresh();
 958:                 }
 959:                 return nullptr;
 960:             }
 961:             case wxID_PRINT: {
 962:                 wxPrintDialogData printDialogData(printData);
 963:                 wxPrinter printer(&amp;printDialogData);
 964:                 Printout printout(this);
 965:                 if (printer.Print(sys-&gt;frame, &amp;printout, true)) {
 966:                     printData = printer.GetPrintDialogData().GetPrintData();
 967:                 }
 968:                 return nullptr;
 969:             }
 970:             case A_PRINTSCALE: {
 971:                 printscale = (uint)::wxGetNumberFromUser(
 972:                     _(L&quot;How many pixels wide should a page be? (0 for auto fit)&quot;), _(L&quot;scale:&quot;),
 973:                     _(L&quot;Set Print Scale&quot;), 0, 0, 5000, sys-&gt;frame);
 974:                 return nullptr;
 975:             }
 976:             case wxID_PREVIEW: {
 977:                 wxPrintDialogData printDialogData(printData);
 978:                 auto preview =
 979:                     new wxPrintPreview(new Printout(this), new Printout(this), &amp;printDialogData);
 980:                 auto pframe = new wxPreviewFrame(preview, sys-&gt;frame, _(L&quot;Print Preview&quot;),
 981:                                                  wxPoint(100, 100), wxSize(600, 650));
 982:                 pframe-&gt;Centre(wxBOTH);
 983:                 pframe-&gt;Initialize();
 984:                 pframe-&gt;Show(true);
 985:                 return nullptr;
 986:             }
 987:             case A_PAGESETUP: {
 988:                 pageSetupData = printData;
 989:                 wxPageSetupDialog pageSetupDialog(sys-&gt;frame, &amp;pageSetupData);
 990:                 pageSetupDialog.ShowModal();
 991:                 printData = pageSetupDialog.GetPageSetupDialogData().GetPrintData();
 992:                 pageSetupData = pageSetupDialog.GetPageSetupDialogData();
 993:                 return nullptr;
 994:             }
 995:             case A_NEXTFILE: sys-&gt;frame-&gt;CycleTabs(1); return nullptr;
 996:             case A_PREVFILE: sys-&gt;frame-&gt;CycleTabs(-1); return nullptr;
 997:             case A_DEFBGCOL: {
 998:                 auto oldbg = Background();
 999:                 if (auto color = PickColor(sys-&gt;frame, oldbg); color != (uint)-1) {
1000:                     root-&gt;AddUndo(this);
1001:                     loopallcells(c) {
1002:                         if (c-&gt;cellcolor == oldbg &amp;&amp; (!c-&gt;parent || c-&gt;parent-&gt;cellcolor == color))
1003:                             c-&gt;cellcolor = color;
1004:                     }
1005:                     canvas-&gt;Refresh();
1006:                 }
1007:                 return nullptr;
1008:             }
1009:             case A_DEFCURCOL: {
1010:                 if (auto color = PickColor(sys-&gt;frame, sys-&gt;cursorcolor); color != (uint)-1) {
1011:                     sys-&gt;cfg-&gt;Write(L&quot;cursorcolor&quot;, sys-&gt;cursorcolor = color);
1012:                     canvas-&gt;Refresh();
1013:                 }
1014:                 return nullptr;
1015:             }
1016:             case A_SEARCHNEXT:
1017:             case A_SEARCHPREV: {
1018:                 if (sys-&gt;searchstring.Len()) return SearchNext(false, true, action == A_SEARCHPREV);
1019:                 if (auto c = selected.GetCell()) {
1020:                     auto s = c-&gt;text.ToText(0, selected, A_EXPTEXT);
1021:                     if (!s.Len()) return _(L&quot;No text to search for.&quot;);
1022:                     sys-&gt;frame-&gt;filter-&gt;SetFocus();
1023:                     sys-&gt;frame-&gt;filter-&gt;SetValue(s);
1024:                     return nullptr;
1025:                 } else {
1026:                     return _(L&quot;You need to select one cell if you want to search for its text.&quot;);
1027:                 }
1028:             }
1029:             case A_CASESENSITIVESEARCH: {
1030:                 sys-&gt;casesensitivesearch = !(sys-&gt;casesensitivesearch);
1031:                 sys-&gt;cfg-&gt;Write(L&quot;casesensitivesearch&quot;, sys-&gt;casesensitivesearch);
1032:                 sys-&gt;searchstring = (sys-&gt;casesensitivesearch)
1033:                                         ? sys-&gt;frame-&gt;filter-&gt;GetValue()
1034:                                         : sys-&gt;frame-&gt;filter-&gt;GetValue().Lower();
1035:                 auto message = SearchNext(false, false, false);
1036:                 canvas-&gt;Refresh();
1037:                 return message;
1038:             }
1039:             case A_ROUND0:
1040:             case A_ROUND1:
1041:             case A_ROUND2:
1042:             case A_ROUND3:
1043:             case A_ROUND4:
1044:             case A_ROUND5:
1045:             case A_ROUND6:
1046:                 sys-&gt;cfg-&gt;Write(L&quot;roundness&quot;, long(sys-&gt;roundness = action - A_ROUND0));
1047:                 canvas-&gt;Refresh();
1048:                 return nullptr;
1049:             case A_OPENCELLCOLOR:
1050:                 if (sys-&gt;frame-&gt;cellcolordropdown) sys-&gt;frame-&gt;cellcolordropdown-&gt;ShowPopup();
1051:                 break;
1052:             case A_OPENTEXTCOLOR:
1053:                 if (sys-&gt;frame-&gt;textcolordropdown) sys-&gt;frame-&gt;textcolordropdown-&gt;ShowPopup();
1054:                 break;
1055:             case A_OPENBORDCOLOR:
1056:                 if (sys-&gt;frame-&gt;bordercolordropdown) sys-&gt;frame-&gt;bordercolordropdown-&gt;ShowPopup();
1057:                 break;
1058:             case A_OPENIMGDROPDOWN:
1059:                 if (sys-&gt;frame-&gt;imagedropdown) sys-&gt;frame-&gt;imagedropdown-&gt;ShowPopup();
1060:                 break;
1061:             case A_REPLACEONCE:
1062:             case A_REPLACEONCEJ:
1063:             case A_REPLACEALL: {
1064:                 if (!sys-&gt;searchstring.Len()) return _(L&quot;No search.&quot;);
1065:                 auto replaces = sys-&gt;frame-&gt;replaces-&gt;GetValue();
1066:                 auto lreplaces =
1067:                     sys-&gt;casesensitivesearch ? (wxString)wxEmptyString : replaces.Lower();
1068:                 if (action == A_REPLACEALL) {
1069:                     root-&gt;AddUndo(this);  // expensive?
1070:                     root-&gt;FindReplaceAll(replaces, lreplaces);
1071:                     root-&gt;ResetChildren();
1072:                     canvas-&gt;Refresh();
1073:                 } else {
1074:                     loopallcellssel(c, true) if (c-&gt;text.IsInSearch()) c-&gt;AddUndo(this);
1075:                     selected.grid-&gt;ReplaceStr(this, replaces, lreplaces, selected);
1076:                     if (action == A_REPLACEONCEJ) return SearchNext(false, true, false);
1077:                 }
1078:                 return _(L&quot;Text has been replaced.&quot;);
1079:             }
1080:             case A_CLEARREPLACE: {
1081:                 sys-&gt;frame-&gt;replaces-&gt;Clear();
1082:                 canvas-&gt;SetFocus();
1083:                 return nullptr;
1084:             }
1085:             case A_CLEARSEARCH: {
1086:                 sys-&gt;frame-&gt;filter-&gt;Clear();
1087:                 canvas-&gt;SetFocus();
1088:                 return nullptr;
1089:             }
1090:             case A_SCALED:
1091:                 scaledviewingmode = !scaledviewingmode;
1092:                 root-&gt;ResetChildren();
1093:                 canvas-&gt;Refresh();
1094:                 return scaledviewingmode ? _(L&quot;Now viewing TreeSheet to fit to the screen exactly, press F12 to return to normal.&quot;)
1095:                                          : _(L&quot;1:1 scale restored.&quot;);
1096:             case A_FILTERRANGE: {
1097:                 DateTimeRangeDialog rd(sys-&gt;frame);
1098:                 if (rd.Run() == wxID_OK) ApplyEditRangeFilter(rd.begin, rd.end);
1099:                 return nullptr;
1100:             }
1101:             case A_FILTER5:
1102:                 editfilter = 5;
1103:                 ApplyEditFilter();
1104:                 return nullptr;
1105:             case A_FILTER10:
1106:                 editfilter = 10;
1107:                 ApplyEditFilter();
1108:                 return nullptr;
1109:             case A_FILTER20:
1110:                 editfilter = 20;
1111:                 ApplyEditFilter();
1112:                 return nullptr;
1113:             case A_FILTER50:
1114:                 editfilter = 50;
1115:                 ApplyEditFilter();
1116:                 return nullptr;
1117:             case A_FILTERM:
1118:                 editfilter++;
1119:                 ApplyEditFilter();
1120:                 return nullptr;
1121:             case A_FILTERL:
1122:                 editfilter--;
1123:                 ApplyEditFilter();
1124:                 return nullptr;
1125:             case A_FILTERS: SetSearchFilter(true); return nullptr;
1126:             case A_FILTEROFF: SetSearchFilter(false); return nullptr;
1127:             case A_CUSTKEY: {
1128:                 wxArrayString strs, keys;
1129:                 for (auto &amp;[s, k] : sys-&gt;frame-&gt;menustrings) {
1130:                     strs.push_back(s);
1131:                     keys.push_back(k);
1132:                 }
1133:                 wxSingleChoiceDialog choice(
1134:                     sys-&gt;frame, _(L&quot;Please pick a menu item to change the key binding for&quot;),
1135:                     _(L&quot;Key binding&quot;), strs);
1136:                 choice.SetSize(wxSize(500, 700));
1137:                 choice.Centre();
1138:                 if (choice.ShowModal() == wxID_OK) {
1139:                     int sel = choice.GetSelection();
1140:                     wxTextEntryDialog textentry(sys-&gt;frame,
1141:                                                 _(L&quot;Please enter the new key binding string&quot;),
1142:                                                 _(L&quot;Key binding&quot;), keys[sel]);
1143:                     if (textentry.ShowModal() == wxID_OK) {
1144:                         auto key = textentry.GetValue();
1145:                         sys-&gt;frame-&gt;menustrings[strs[sel]] = key;
1146:                         sys-&gt;cfg-&gt;Write(strs[sel], key);
1147:                         return _(L&quot;NOTE: key binding will take effect next run of TreeSheets.&quot;);
1148:                     }
1149:                 }
1150:                 return _(L&quot;Keybinding cancelled.&quot;);
1151:             }
1152:             case A_SETLANG: {
1153:                 auto trans = wxTranslations::Get();
1154:                 if (!trans) return _(L&quot;Failed to get translation.&quot;);
1155:                 wxArrayString langs = trans-&gt;GetAvailableTranslations(L&quot;ts&quot;);
1156:                 langs.Insert(wxEmptyString, 0);
1157:                 wxSingleChoiceDialog choice(
1158:                     sys-&gt;frame, _(L&quot;Please select the language for the interface (requires restart). Please select the empty row if you want to use the default language.&quot;),
1159:                     _(L&quot;Available languages&quot;), langs);
1160:                 if (choice.ShowModal() == wxID_OK) {
1161:                     sys-&gt;cfg-&gt;Write(L&quot;defaultlang&quot;, choice.GetStringSelection());
1162:                 }
1163:                 return nullptr;
1164:             }
1165:         }
1166:         if (!selected.grid) return NoSel();
1167:         auto cell = selected.GetCell();
1168:         switch (action) {
1169:             case A_BACKSPACE:
1170:                 if (selected.Thin()) {
1171:                     if (selected.xs)
1172:                         DelRowCol(selected.y, 0, selected.grid-&gt;ys, 1, -1, selected.y - 1, 0, -1);
1173:                     else
1174:                         DelRowCol(selected.x, 0, selected.grid-&gt;xs, 1, selected.x - 1, -1, -1, 0);
1175:                 } else if (cell &amp;&amp; selected.TextEdit()) {
1176:                     if (selected.cursorend == 0) return nullptr;
1177:                     cell-&gt;AddUndo(this);
1178:                     cell-&gt;text.Backspace(selected);
1179:                     canvas-&gt;Refresh();
1180:                 } else {
1181:                     selected.grid-&gt;MultiCellDelete(this, selected);
1182:                     SetSelect(selected);
1183:                 }
1184:                 ZoomOutIfNoGrid();
1185:                 return nullptr;
1186:             case A_DELETE:
1187:                 if (selected.Thin()) {
1188:                     if (selected.xs)
1189:                         DelRowCol(selected.y, selected.grid-&gt;ys, selected.grid-&gt;ys, 0, -1,
1190:                                   selected.y, 0, -1);
1191:                     else
1192:                         DelRowCol(selected.x, selected.grid-&gt;xs, selected.grid-&gt;xs, 0, selected.x,
1193:                                   -1, -1, 0);
1194:                 } else if (cell &amp;&amp; selected.TextEdit()) {
1195:                     if (selected.cursor == cell-&gt;text.t.Len()) return nullptr;
1196:                     cell-&gt;AddUndo(this);
1197:                     cell-&gt;text.Delete(selected);
1198:                     canvas-&gt;Refresh();
1199:                 } else {
1200:                     selected.grid-&gt;MultiCellDelete(this, selected);
1201:                     SetSelect(selected);
1202:                 }
1203:                 ZoomOutIfNoGrid();
1204:                 return nullptr;
1205:             case A_DELETE_WORD:
1206:                 if (cell &amp;&amp; selected.TextEdit()) {
1207:                     if (selected.cursor == cell-&gt;text.t.Len()) return nullptr;
1208:                     cell-&gt;AddUndo(this);
1209:                     cell-&gt;text.DeleteWord(selected);
1210:                     canvas-&gt;Refresh();
1211:                 }
1212:                 ZoomOutIfNoGrid();
1213:                 return nullptr;
1214:             case wxID_CUT:
1215:             case wxID_COPY:
1216:             case A_COPYWI:
1217:             case A_COPYCT:
1218:                 if (selected.Thin()) return NoThin();
1219:                 if (selected.TextEdit()) {
1220:                     if (selected.cursor == selected.cursorend) return _(L&quot;No text selected.&quot;);
1221:                 }
1222:                 Copy(action);
1223:                 if (action == wxID_CUT) {
1224:                     if (!selected.TextEdit()) {
1225:                         selected.grid-&gt;cell-&gt;AddUndo(this);
1226:                         selected.grid-&gt;MultiCellDelete(this, selected);
1227:                         SetSelect(selected);
1228:                     } else if (cell) {
1229:                         cell-&gt;AddUndo(this);
1230:                         cell-&gt;text.Backspace(selected);
1231:                     }
1232:                     canvas-&gt;Refresh();
1233:                 }
1234:                 ZoomOutIfNoGrid();
1235:                 return nullptr;
1236:             case A_COPYBM:
1237:                 if (wxTheClipboard-&gt;Open()) {
1238:                     wxTheClipboard-&gt;SetData(new wxBitmapDataObject(GetSubBitmap(selected)));
1239:                     wxTheClipboard-&gt;Close();
1240:                     return _(L&quot;Bitmap copied to clipboard&quot;);
1241:                 }
1242:                 return nullptr;
1243:             case A_COLLAPSE: {
1244:                 if (selected.xs * selected.ys == 1)
1245:                     return _(L&quot;More than one cell must be selected.&quot;);
1246:                 auto fc = selected.GetFirst();
1247:                 wxString ct = &quot;&quot;;
1248:                 loopallcellssel(ci, true) if (ci != fc &amp;&amp; ci-&gt;text.t.Len()) ct += &quot; &quot; + ci-&gt;text.t;
1249:                 if (!fc-&gt;HasContent() &amp;&amp; !ct.Len()) return _(L&quot;There is no content to collapse.&quot;);
1250:                 fc-&gt;parent-&gt;AddUndo(this);
1251:                 fc-&gt;text.t += ct;
1252:                 loopallcellssel(ci, false) if (ci != fc) ci-&gt;Clear();
1253:                 Selection deletesel(selected.grid,
1254:                                     selected.x + int(selected.xs &gt; 1),  // sidestep is possible?
1255:                                     selected.y + int(selected.ys &gt; 1),
1256:                                     selected.xs - int(selected.xs &gt; 1),
1257:                                     selected.ys - int(selected.ys &gt; 1));
1258:                 selected.grid-&gt;MultiCellDeleteSub(this, deletesel);
1259:                 SetSelect(Selection(selected.grid, selected.x, selected.y, 1, 1));
1260:                 fc-&gt;ResetLayout();
1261:                 canvas-&gt;Refresh();
1262:                 return nullptr;
1263:             }
1264:             case wxID_SELECTALL:
1265:                 selected.SelAll();
1266:                 canvas-&gt;Refresh();
1267:                 return nullptr;
1268:             case A_UP:
1269:             case A_DOWN:
1270:             case A_LEFT:
1271:             case A_RIGHT: selected.Cursor(this, action, false, false); return nullptr;
1272:             case A_MUP:
1273:             case A_MDOWN:
1274:             case A_MLEFT:
1275:             case A_MRIGHT:
1276:                 selected.Cursor(this, action - A_MUP + A_UP, true, false);
1277:                 return nullptr;
1278:             case A_SUP:
1279:             case A_SDOWN:
1280:             case A_SLEFT:
1281:             case A_SRIGHT:
1282:                 selected.Cursor(this, action - A_SUP + A_UP, false, true);
1283:                 return nullptr;
1284:             case A_SCLEFT:
1285:             case A_SCRIGHT:
1286:                 if (!selected.TextEdit() &amp;&amp; action == A_SCLEFT) {
1287:                     selected.xs = selected.Thin() ? selected.x : selected.x + 1;
1288:                     selected.x = 0;
1289:                     canvas-&gt;Refresh();
1290:                     return nullptr;
1291:                 }
1292:                 if (!selected.TextEdit() &amp;&amp; action == A_SCRIGHT) {
1293:                     selected.xs = selected.grid-&gt;xs - selected.x;
1294:                     canvas-&gt;Refresh();
1295:                     return nullptr;
1296:                 }
1297:                 selected.Cursor(this, action - A_SCUP + A_UP, true, true);
1298:                 return nullptr;
1299:             case A_SCUP:
1300:             case A_SCDOWN:
1301:                 if (!selected.TextEdit() &amp;&amp; action == A_SCUP) {
1302:                     selected.ys = selected.Thin() ? selected.y : selected.y + 1;
1303:                     selected.y = 0;
1304:                     canvas-&gt;Refresh();
1305:                 }
1306:                 if (!selected.TextEdit() &amp;&amp; action == A_SCDOWN) {
1307:                     selected.ys = selected.grid-&gt;ys - selected.y;
1308:                     canvas-&gt;Refresh();
1309:                 }
1310:                 return nullptr;
1311:             case wxID_BOLD: selected.grid-&gt;SetStyle(this, selected, STYLE_BOLD); return nullptr;
1312:             case wxID_ITALIC: selected.grid-&gt;SetStyle(this, selected, STYLE_ITALIC); return nullptr;
1313:             case A_TT: selected.grid-&gt;SetStyle(this, selected, STYLE_FIXED); return nullptr;
1314:             case wxID_UNDERLINE:
1315:                 selected.grid-&gt;SetStyle(this, selected, STYLE_UNDERLINE);
1316:                 return nullptr;
1317:             case wxID_STRIKETHROUGH:
1318:                 selected.grid-&gt;SetStyle(this, selected, STYLE_STRIKETHRU);
1319:                 return nullptr;
1320:             case A_MARKDATA:
1321:             case A_MARKVARD:
1322:             case A_MARKVARU:
1323:             case A_MARKVIEWH:
1324:             case A_MARKVIEWV:
1325:             case A_MARKCODE: {
1326:                 int newcelltype;
1327:                 switch (action) {
1328:                     case A_MARKDATA: newcelltype = CT_DATA; break;
1329:                     case A_MARKVARD: newcelltype = CT_VARD; break;
1330:                     case A_MARKVARU: newcelltype = CT_VARU; break;
1331:                     case A_MARKVIEWH: newcelltype = CT_VIEWH; break;
1332:                     case A_MARKVIEWV: newcelltype = CT_VIEWV; break;
1333:                     case A_MARKCODE: newcelltype = CT_CODE; break;
1334:                 }
1335:                 selected.grid-&gt;cell-&gt;AddUndo(this);
1336:                 loopallcellssel(c, false) {
1337:                     c-&gt;celltype = (newcelltype == CT_CODE) ? sys-&gt;evaluator.InferCellType(c-&gt;text)
1338:                                                            : newcelltype;
1339:                     canvas-&gt;Refresh();
1340:                 }
1341:                 return nullptr;
1342:             }
1343:             case A_CANCELEDIT:
1344:                 if (selected.TextEdit()) break;
1345:                 if (selected.grid-&gt;cell-&gt;parent) {
1346:                     SetSelect(selected.grid-&gt;cell-&gt;parent-&gt;grid-&gt;FindCell(selected.grid-&gt;cell));
1347:                 } else {
1348:                     selected.SelAll();
1349:                 }
1350:                 ScrollOrZoom();
1351:                 return nullptr;
1352:             case A_NEWGRID:
1353:                 if (!(cell = selected.ThinExpand(this))) return OneCell();
1354:                 if (cell-&gt;grid) {
1355:                     SetSelect(Selection(cell-&gt;grid, 0, cell-&gt;grid-&gt;ys, 1, 0));
1356:                     ScrollOrZoom(true);
1357:                 } else {
1358:                     cell-&gt;AddUndo(this);
1359:                     cell-&gt;AddGrid();
1360:                     SetSelect(Selection(cell-&gt;grid, 0, 0, 1, 1));
1361:                     paintscrolltoselection = true;
1362:                     canvas-&gt;Refresh();
1363:                 }
1364:                 return nullptr;
1365:             case wxID_PASTE:
1366:                 if (!(cell = selected.ThinExpand(this))) return OneCell();
1367:                 if (wxTheClipboard-&gt;Open()) {
1368:                     if (wxTheClipboard-&gt;IsSupported(wxDF_BITMAP)) {
1369:                         wxBitmapDataObject bdo;
1370:                         wxTheClipboard-&gt;GetData(bdo);
1371:                         PasteOrDrop(bdo);
1372:                     } else if (wxTheClipboard-&gt;IsSupported(wxDF_FILENAME)) {
1373:                         wxFileDataObject fdo;
1374:                         wxTheClipboard-&gt;GetData(fdo);
1375:                         PasteOrDrop(fdo);
1376:                     } else if (wxTheClipboard-&gt;IsSupported(wxDF_TEXT) ||
1377:                                wxTheClipboard-&gt;IsSupported(wxDF_UNICODETEXT)) {
1378:                         wxTextDataObject tdo;
1379:                         wxTheClipboard-&gt;GetData(tdo);
1380:                         PasteOrDrop(tdo);
1381:                     }
1382:                     wxTheClipboard-&gt;Close();
1383:                     canvas-&gt;Refresh();
1384:                 } else if (sys-&gt;cellclipboard) {
1385:                     cell-&gt;Paste(this, sys-&gt;cellclipboard.get(), selected);
1386:                     canvas-&gt;Refresh();
1387:                 }
1388:                 return nullptr;
1389:             case A_PASTESTYLE:
1390:                 if (!sys-&gt;cellclipboard) return _(L&quot;No style to paste.&quot;);
1391:                 selected.grid-&gt;cell-&gt;AddUndo(this);
1392:                 selected.grid-&gt;SetStyles(selected, sys-&gt;cellclipboard.get());
1393:                 selected.grid-&gt;cell-&gt;ResetChildren();
1394:                 canvas-&gt;Refresh();
1395:                 return nullptr;
1396:             case A_ENTERCELL:
1397:             case A_ENTERCELL_JUMPTOEND:
1398:             case A_ENTERCELL_JUMPTOSTART:
1399:             case A_PROGRESSCELL: {
1400:                 if (!(cell = selected.ThinExpand(this, action == A_ENTERCELL_JUMPTOSTART)))
1401:                     return OneCell();
1402:                 if (selected.TextEdit()) {
1403:                     selected.Cursor(this, action == A_PROGRESSCELL ? A_RIGHT : A_DOWN, false, false,
1404:                                     true);
1405:                 } else {
1406:                     selected.EnterEdit(
1407:                         this,
1408:                         action == A_ENTERCELL_JUMPTOEND ? static_cast&lt;int&gt;(cell-&gt;text.t.Len()) : 0,
1409:                         static_cast&lt;int&gt;(cell-&gt;text.t.Len()));
1410:                     paintscrolltoselection = true;
1411:                     canvas-&gt;Refresh();
1412:                 }
1413:                 return nullptr;
1414:             }
1415:             case A_IMAGE: {
1416:                 if (!(cell = selected.ThinExpand(this))) return OneCell();
1417:                 auto filename =
1418:                     ::wxFileSelector(_(L&quot;Please select an image file:&quot;), L&quot;&quot;, L&quot;&quot;, L&quot;&quot;, L&quot;*.*&quot;,
1419:                                      wxFD_OPEN | wxFD_FILE_MUST_EXIST | wxFD_CHANGE_DIR);
1420:                 cell-&gt;AddUndo(this);
1421:                 LoadImageIntoCell(filename, cell, sys-&gt;frame-&gt;FromDIP(1.0));
1422:                 canvas-&gt;Refresh();
1423:                 return nullptr;
1424:             }
1425:             case A_IMAGER: {
1426:                 selected.grid-&gt;cell-&gt;AddUndo(this);
1427:                 selected.grid-&gt;ClearImages(selected);
1428:                 selected.grid-&gt;cell-&gt;ResetChildren();
1429:                 canvas-&gt;Refresh();
1430:                 return nullptr;
1431:             }
1432:             case A_SORTD: return Sort(true);
1433:             case A_SORT: return Sort(false);
1434:             case A_SCOLS:
1435:                 selected.y = 0;
1436:                 selected.ys = selected.grid-&gt;ys;
1437:                 canvas-&gt;Refresh();
1438:                 return nullptr;
1439:             case A_SROWS:
1440:                 selected.x = 0;
1441:                 selected.xs = selected.grid-&gt;xs;
1442:                 canvas-&gt;Refresh();
1443:                 return nullptr;
1444:             case A_BORD0:
1445:             case A_BORD1:
1446:             case A_BORD2:
1447:             case A_BORD3:
1448:             case A_BORD4:
1449:             case A_BORD5:
1450:                 selected.grid-&gt;cell-&gt;AddUndo(this);
1451:                 selected.grid-&gt;SetBorder(action - A_BORD0 + 1, selected);
1452:                 selected.grid-&gt;cell-&gt;ResetChildren();
1453:                 canvas-&gt;Refresh();
1454:                 return nullptr;
1455:             case A_TEXTGRID: return layrender(-1, true, true);
1456:             case A_V_GS: return layrender(DS_GRID, true);
1457:             case A_V_BS: return layrender(DS_BLOBSHIER, true);
1458:             case A_V_LS: return layrender(DS_BLOBLINE, true);
1459:             case A_H_GS: return layrender(DS_GRID, false);
1460:             case A_H_BS: return layrender(DS_BLOBSHIER, false);
1461:             case A_H_LS: return layrender(DS_BLOBLINE, false);
1462:             case A_GS: return layrender(DS_GRID, true, false, true);
1463:             case A_BS: return layrender(DS_BLOBSHIER, true, false, true);
1464:             case A_LS: return layrender(DS_BLOBLINE, true, false, true);
1465:             case A_WRAP: return selected.Wrap(this);
1466:             case A_RESETSIZE:
1467:             case A_RESETWIDTH:
1468:             case A_RESETSTYLE:
1469:             case A_RESETCOLOR:
1470:             case A_LASTCELLCOLOR:
1471:             case A_LASTTEXTCOLOR:
1472:             case A_LASTBORDCOLOR:
1473:             case A_LASTIMAGE:
1474:                 selected.grid-&gt;cell-&gt;AddUndo(this);
1475:                 loopallcellssel(c, true) switch (action) {
1476:                     case A_RESETSIZE: c-&gt;text.relsize = 0; break;
1477:                     case A_RESETWIDTH:
1478:                         for (int x = selected.x; x &lt; selected.x + selected.xs; x++)
1479:                             selected.grid-&gt;colwidths[x] = sys-&gt;defaultmaxcolwidth;
1480:                         selected.grid-&gt;cell-&gt;ResetLayout();
1481:                         break;
1482:                     case A_RESETSTYLE: c-&gt;text.stylebits = 0; break;
1483:                     case A_RESETCOLOR:
1484:                         if (c-&gt;IsTag(this)) {
1485:                             tags[c-&gt;text.t] = g_tagcolor_default;
1486:                         } else {
1487:                             c-&gt;textcolor = g_textcolor_default;
1488:                         }
1489:                         c-&gt;cellcolor = g_cellcolor_default;
1490:                         if (c-&gt;grid) c-&gt;grid-&gt;bordercolor = g_bordercolor_default;
1491:                         break;
1492:                     case A_LASTCELLCOLOR: c-&gt;cellcolor = sys-&gt;lastcellcolor; break;
1493:                     case A_LASTTEXTCOLOR: c-&gt;textcolor = sys-&gt;lasttextcolor; break;
1494:                     case A_LASTBORDCOLOR:
1495:                         if (c-&gt;parent &amp;&amp; c-&gt;parent-&gt;grid)
1496:                             c-&gt;parent-&gt;grid-&gt;bordercolor = sys-&gt;lastbordcolor;
1497:                         break;
1498:                     case A_LASTIMAGE:
1499:                         if (sys-&gt;lastimage) c-&gt;text.image = sys-&gt;lastimage;
1500:                         break;
1501:                 }
1502:                 selected.grid-&gt;cell-&gt;ResetChildren();
1503:                 canvas-&gt;Refresh();
1504:                 return nullptr;
1505:             case A_MINISIZE: {
1506:                 selected.grid-&gt;cell-&gt;AddUndo(this);
1507:                 CollectCellsSel(false);
1508:                 vector&lt;Cell *&gt; outer;
1509:                 outer.insert(outer.end(), itercells.begin(), itercells.end());
1510:                 for (auto o : outer) {
1511:                     if (o-&gt;grid) {
1512:                         loopcellsin(o, c) if (_i) {
1513:                             c-&gt;text.relsize = g_deftextsize - g_mintextsize() - c-&gt;Depth();
1514:                         }
1515:                     }
1516:                 }
1517:                 outer.clear();
1518:                 selected.grid-&gt;cell-&gt;ResetChildren();
1519:                 canvas-&gt;Refresh();
1520:                 return nullptr;
1521:             }
1522:             case A_FOLD:
1523:             case A_FOLDALL:
1524:             case A_UNFOLDALL:
1525:                 loopallcellssel(c, action != A_FOLD) if (c-&gt;grid) {
1526:                     c-&gt;AddUndo(this);
1527:                     c-&gt;grid-&gt;folded = action == A_FOLD ? !c-&gt;grid-&gt;folded : action == A_FOLDALL;
1528:                     c-&gt;ResetChildren();
1529:                 }
1530:                 canvas-&gt;Refresh();
1531:                 return nullptr;
1532:             case A_HOME:
1533:             case A_END:
1534:             case A_CHOME:
1535:             case A_CEND:
1536:                 if (selected.TextEdit()) break;
1537:                 selected.HomeEnd(this, action == A_HOME || action == A_CHOME);
1538:                 return nullptr;
1539:             case A_IMAGESCP:
1540:             case A_IMAGESCW:
1541:             case A_IMAGESCF: {
1542:                 std::set&lt;Image *&gt; imagestomanipulate;
1543:                 long v = 0.0;
1544:                 loopallcellssel(c, true) {
1545:                     if (c-&gt;text.image) { imagestomanipulate.insert(c-&gt;text.image); }
1546:                 }
1547:                 if (imagestomanipulate.empty()) return nullptr;
1548:                 if (action == A_IMAGESCW) {
1549:                     v = wxGetNumberFromUser(_(L&quot;Please enter the new image width:&quot;), _(L&quot;Width&quot;),
1550:                                             _(L&quot;Image Resize&quot;), 500, 10, 4000, sys-&gt;frame);
1551:                 } else {
1552:                     v = wxGetNumberFromUser(
1553:                         _(L&quot;Please enter the percentage you want the image scaled by:&quot;), L&quot;%&quot;,
1554:                         _(L&quot;Image Resize&quot;), 50, 5, 400, sys-&gt;frame);
1555:                 }
1556:                 if (v &lt; 0) return nullptr;
1557:                 for (auto image : imagestomanipulate) {
1558:                     if (action == A_IMAGESCW) {
1559:                         int pw = image-&gt;pixel_width;
1560:                         if (pw)
1561:                             image-&gt;ImageRescale(static_cast&lt;double&gt;(v) / static_cast&lt;double&gt;(pw));
1562:                     } else if (action == A_IMAGESCP) {
1563:                         image-&gt;ImageRescale(v / 100.0);
1564:                     } else {
1565:                         image-&gt;DisplayScale(v / 100.0);
1566:                     }
1567:                 }
1568:                 currentdrawroot-&gt;ResetChildren();
1569:                 currentdrawroot-&gt;ResetLayout();
1570:                 canvas-&gt;Refresh();
1571:                 return nullptr;
1572:             }
1573:             case A_IMAGESCN: {
1574:                 loopallcellssel(c, true) if (c-&gt;text.image) {
1575:                     c-&gt;text.image-&gt;ResetScale(sys-&gt;frame-&gt;FromDIP(1.0));
1576:                 }
1577:                 currentdrawroot-&gt;ResetChildren();
1578:                 currentdrawroot-&gt;ResetLayout();
1579:                 canvas-&gt;Refresh();
1580:                 return nullptr;
1581:             }
1582:             case A_IMAGESVA: {
1583:                 set&lt;Image *&gt; imagestosave;
1584:                 loopallcellssel(c, true) if (auto image = c-&gt;text.image)
1585:                     imagestosave.insert(image);
1586:                 if (imagestosave.empty()) return _(L&quot;There are no images in the selection.&quot;);
1587:                 wxString filename = ::wxFileSelector(
1588:                     _(L&quot;Choose image file to save:&quot;), L&quot;&quot;, L&quot;&quot;, L&quot;&quot;,
1589:                     _(L&quot;PNG file (*.png)|*.png|JPEG file (*.jpg)|*.jpg|All Files (*.*)|*.*&quot;),
1590:                     wxFD_SAVE | wxFD_OVERWRITE_PROMPT | wxFD_CHANGE_DIR);
1591:                 if (filename.empty()) return _(L&quot;Save cancelled.&quot;);
1592:                 auto i = 0;
1593:                 for (auto image : imagestosave) {
1594:                     wxFileName fn(filename);
1595:                     wxString finalfilename = fn.GetPathWithSep() + fn.GetName() +
1596:                                              (i == 0 ? wxString() : wxString::Format(L&quot;%d&quot;, i)) +
1597:                                              image-&gt;GetFileExtension();
1598:                     wxFFileOutputStream os(finalfilename, L&quot;w+b&quot;);
1599:                     if (!os.IsOk()) {
1600:                         wxMessageBox(
1601:                             _(L&quot;Error writing image file! (try saving under new filename).&quot;),
1602:                             finalfilename.wx_str(), wxOK, sys-&gt;frame);
1603:                         return _(L&quot;Error writing to file.&quot;);
1604:                     }
1605:                     os.Write(image-&gt;data.data(), image-&gt;data.size());
1606:                     i++;
1607:                 }
1608:                 return _(L&quot;Image(s) have been saved to disk.&quot;);
1609:             }
1610:             case A_SAVE_AS_JPEG:
1611:             case A_SAVE_AS_PNG:
1612:                 loopallcellssel(c, true) {
1613:                     auto image = c-&gt;text.image;
1614:                     if (action == A_SAVE_AS_JPEG &amp;&amp; image &amp;&amp; image-&gt;type == &apos;I&apos;) {
1615:                         auto transferimage = ConvertBufferToWxImage(image-&gt;data, wxBITMAP_TYPE_PNG);
1616:                         image-&gt;data = ConvertWxImageToBuffer(transferimage, wxBITMAP_TYPE_JPEG);
1617:                         image-&gt;type = &apos;J&apos;;
1618:                         return _(L&quot;Images in selected cells have been converted to JPEG format.&quot;);
1619:                     }
1620:                     if (action == A_SAVE_AS_PNG &amp;&amp; image &amp;&amp; image-&gt;type == &apos;J&apos;) {
1621:                         auto transferimage =
1622:                             ConvertBufferToWxImage(image-&gt;data, wxBITMAP_TYPE_JPEG);
1623:                         image-&gt;data = ConvertWxImageToBuffer(transferimage, wxBITMAP_TYPE_PNG);
1624:                         image-&gt;type = &apos;I&apos;;
1625:                         return _(L&quot;Images in selected cells have been converted to PNG format.&quot;);
1626:                     }
1627:                 }
1628:             case A_BROWSE: {
1629:                 const wxChar *returnmessage = nullptr;
1630:                 int counter = 0;
1631:                 loopallcellssel(c, false) {
1632:                     if (counter &gt;= g_max_launches) {
1633:                         returnmessage = _(L&quot;Maximum number of launches reached.&quot;);
1634:                         break;
1635:                     }
1636:                     if (!wxLaunchDefaultBrowser(c-&gt;text.ToText(0, selected, A_EXPTEXT))) {
1637:                         returnmessage = _(L&quot;The browser could not open at least one link.&quot;);
1638:                     } else {
1639:                         counter++;
1640:                     }
1641:                 }
1642:                 return returnmessage;
1643:             }
1644:             case A_BROWSEF: {
1645:                 const wxChar *returnmessage = nullptr;
1646:                 int counter = 0;
1647:                 loopallcellssel(c, false) {
1648:                     if (counter &gt;= g_max_launches) {
1649:                         returnmessage = _(L&quot;Maximum number of launches reached.&quot;);
1650:                         break;
1651:                     }
1652:                     auto f = c-&gt;text.ToText(0, selected, A_EXPTEXT);
1653:                     wxFileName fn(f);
1654:                     if (fn.IsRelative()) fn.MakeAbsolute(wxFileName(filename).GetPath());
1655:                     if (!wxLaunchDefaultApplication(fn.GetFullPath())) {
1656:                         returnmessage = _(L&quot;At least one file could not be opened.&quot;);
1657:                     } else {
1658:                         counter++;
1659:                     }
1660:                 }
1661:                 return returnmessage;
1662:             }
1663:             case A_TAGADD: {
1664:                 loopallcellssel(c, false) {
1665:                     if (!c-&gt;text.t.Len()) continue;
1666:                     tags[c-&gt;text.t] = g_tagcolor_default;
1667:                 }
1668:                 canvas-&gt;Refresh();
1669:                 return nullptr;
1670:             }
1671:             case A_TAGREMOVE: {
1672:                 loopallcellssel(c, false) tags.erase(c-&gt;text.t);
1673:                 canvas-&gt;Refresh();
1674:                 return nullptr;
1675:             }
1676:             case A_TRANSPOSE: {
1677:                 if (selected.Thin()) return NoThin();
1678:                 auto ac = selected.grid-&gt;cell;
1679:                 ac-&gt;AddUndo(this);
1680:                 if (selected.IsAll()) {
1681:                     ac-&gt;grid-&gt;Transpose();
1682:                     SetSelect(ac-&gt;parent ? ac-&gt;parent-&gt;grid-&gt;FindCell(ac) : Selection());
1683:                 } else {
1684:                     loopallcellssel(c, false) if (c-&gt;grid) c-&gt;grid-&gt;Transpose();
1685:                 }
1686:                 ac-&gt;ResetChildren();
1687:                 canvas-&gt;Refresh();
1688:                 return nullptr;
1689:             }
1690:         }
1691:         if (cell || (!cell &amp;&amp; selected.IsAll())) {
1692:             auto ac = cell ? cell : selected.grid-&gt;cell;
1693:             switch (action) {
1694:                 case A_HIFY:
1695:                     if (!ac-&gt;grid) return NoGrid();
1696:                     if (!ac-&gt;grid-&gt;IsTable())
1697:                         return _(
1698:                             L&quot;Selected grid is not a table: cells must not already have sub-grids.&quot;);
1699:                     ac-&gt;AddUndo(this);
1700:                     ac-&gt;grid-&gt;Hierarchify(this);
1701:                     ac-&gt;ResetChildren();
1702:                     selected = Selection();
1703:                     begindrag = Selection();
1704:                     canvas-&gt;Refresh();
1705:                     return nullptr;
1706:                 case A_FLATTEN: {
1707:                     if (!ac-&gt;grid) return NoGrid();
1708:                     ac-&gt;AddUndo(this);
1709:                     int maxdepth = 0, leaves = 0;
1710:                     ac-&gt;MaxDepthLeaves(0, maxdepth, leaves);
1711:                     auto g = new Grid(maxdepth, leaves);
1712:                     g-&gt;InitCells();
1713:                     ac-&gt;grid-&gt;Flatten(0, 0, g);
1714:                     DELETEP(ac-&gt;grid);
1715:                     ac-&gt;grid = g;
1716:                     g-&gt;ReParent(ac);
1717:                     ac-&gt;ResetChildren();
1718:                     selected = Selection();
1719:                     begindrag = Selection();
1720:                     canvas-&gt;Refresh();
1721:                     return nullptr;
1722:                 }
1723:             }
1724:         }
1725:         if (!cell) return OneCell();
1726:         switch (action) {
1727:             case A_NEXT: selected.Next(this, false); return nullptr;
1728:             case A_PREV: selected.Next(this, true); return nullptr;
1729:             case A_ENTERGRID:
1730:                 if (!cell-&gt;grid) Action(A_NEWGRID);
1731:                 SetSelect(Selection(cell-&gt;grid, 0, 0, 1, 1));
1732:                 ScrollOrZoom(true);
1733:                 return nullptr;
1734:             case A_LINK:
1735:             case A_LINKIMG:
1736:             case A_LINKREV:
1737:             case A_LINKIMGREV: {
1738:                 if ((action == A_LINK || action == A_LINKREV) &amp;&amp; !cell-&gt;text.t.Len())
1739:                     return _(L&quot;No text in this cell.&quot;);
1740:                 if ((action == A_LINKIMG || action == A_LINKIMGREV) &amp;&amp; !cell-&gt;text.image)
1741:                     return _(L&quot;No image in this cell.&quot;);
1742:                 bool t1 = false, t2 = false;
1743:                 auto link = root-&gt;FindLink(selected, cell, nullptr, t1, t2,
1744:                                            action == A_LINK || action == A_LINKIMG,
1745:                                            action == A_LINKIMG || action == A_LINKIMGREV);
1746:                 if (!link || !link-&gt;parent) return _(L&quot;No matching cell found!&quot;);
1747:                 SetSelect(link-&gt;parent-&gt;grid-&gt;FindCell(link));
1748:                 ScrollOrZoom(true);
1749:                 return nullptr;
1750:             }
1751:             case A_COLCELL: sys-&gt;customcolor = cell-&gt;cellcolor; return nullptr;
1752:             case A_HSWAP: {
1753:                 auto pp = cell-&gt;parent-&gt;parent;
1754:                 if (!pp) return _(L&quot;Cannot move this cell up in the hierarchy.&quot;);
1755:                 if (pp-&gt;grid-&gt;xs != 1 &amp;&amp; pp-&gt;grid-&gt;ys != 1)
1756:                     return _(L&quot;Can only move this cell into a Nx1 or 1xN grid.&quot;);
1757:                 if (cell-&gt;parent-&gt;grid-&gt;xs != 1 &amp;&amp; cell-&gt;parent-&gt;grid-&gt;ys != 1)
1758:                     return _(L&quot;Can only move this cell from a Nx1 or 1xN grid.&quot;);
1759:                 pp-&gt;AddUndo(this);
1760:                 SetSelect(pp-&gt;grid-&gt;HierarchySwap(cell-&gt;text.t));
1761:                 pp-&gt;ResetChildren();
1762:                 pp-&gt;ResetLayout();
1763:                 canvas-&gt;Refresh();
1764:                 return nullptr;
1765:             }
1766:             case A_FILTERBYCELLBG:
1767:                 loopallcells(ci) ci-&gt;text.filtered = ci-&gt;cellcolor != cell-&gt;cellcolor;
1768:                 root-&gt;ResetChildren();
1769:                 canvas-&gt;Refresh();
1770:                 return nullptr;
1771:             case A_FILTERMATCHNEXT:
1772:                 bool lastsel = true;
1773:                 Cell *next = root-&gt;FindNextFilterMatch(nullptr, selected.GetCell(), lastsel);
1774:                 if (!next) return _(L&quot;No matches for filter.&quot;);
1775:                 if (next-&gt;parent) SetSelect(next-&gt;parent-&gt;grid-&gt;FindCell(next));
1776:                 canvas-&gt;SetFocus();
1777:                 ScrollOrZoom(true);
1778:                 return nullptr;
1779:         }
1780:         if (!selected.TextEdit()) return _(L&quot;only works in cell text mode&quot;);
1781:         switch (action) {
1782:             case A_CANCELEDIT:
1783:                 if (LastUndoSameCellTextEdit(cell))
1784:                     Undo(undolist, redolist);
1785:                 else
1786:                     canvas-&gt;Refresh();
1787:                 selected.ExitEdit(this);
1788:                 return nullptr;
1789:             case A_BACKSPACE_WORD:
1790:                 if (selected.cursorend == 0) return nullptr;
1791:                 cell-&gt;AddUndo(this);
1792:                 cell-&gt;text.BackspaceWord(selected);
1793:                 canvas-&gt;Refresh();
1794:                 ZoomOutIfNoGrid();
1795:                 return nullptr;
1796:             case A_SHOME:
1797:             case A_SEND:
1798:             case A_CHOME:
1799:             case A_CEND:
1800:             case A_HOME:
1801:             case A_END: {
1802:                 switch (action) {
1803:                     case A_SHOME:  // FIXME: this functionality is really SCHOME, SHOME should be
1804:                                    // within line
1805:                         selected.cursor = 0;
1806:                         break;
1807:                     case A_SEND: selected.cursorend = static_cast&lt;int&gt;(cell-&gt;text.t.Len()); break;
1808:                     case A_CHOME: selected.cursor = selected.cursorend = 0; break;
1809:                     case A_CEND: selected.cursor = selected.cursorend = selected.MaxCursor(); break;
1810:                     case A_HOME: cell-&gt;text.HomeEnd(selected, true); break;
1811:                     case A_END: cell-&gt;text.HomeEnd(selected, false); break;
1812:                 }
1813:                 paintscrolltoselection = true;
1814:                 canvas-&gt;Refresh();
1815:                 return nullptr;
1816:             }
1817:             default: return _(L&quot;Internal error: unimplemented operation!&quot;);
1818:         }
1819:     }
1820:     const wxChar *SearchNext(bool focusmatch, bool jump, bool reverse) {
1821:         if (!root) return nullptr;  // fix crash when opening new doc
1822:         if (!sys-&gt;searchstring.Len()) return _(L&quot;No search string.&quot;);
1823:         bool lastsel = true;
1824:         Cell *next = root-&gt;FindNextSearchMatch(sys-&gt;searchstring, nullptr, selected.GetCell(),
1825:                                                lastsel, reverse);
1826:         if (!next) return _(L&quot;No matches for search.&quot;);
1827:         if (!jump) return nullptr;
1828:         SetSelect(next-&gt;parent-&gt;grid-&gt;FindCell(next));
1829:         if (focusmatch) canvas-&gt;SetFocus();
1830:         ScrollOrZoom(true);
1831:         return nullptr;
1832:     }
1833:     const wxChar *layrender(int ds, bool vert, bool toggle = false, bool noset = false) {
1834:         if (selected.Thin()) return NoThin();
1835:         selected.grid-&gt;cell-&gt;AddUndo(this);
1836:         bool v = toggle ? !selected.GetFirst()-&gt;verticaltextandgrid : vert;
1837:         if (ds &gt;= 0 &amp;&amp; selected.IsAll()) selected.grid-&gt;cell-&gt;drawstyle = ds;
1838:         selected.grid-&gt;SetGridTextLayout(ds, v, noset, selected);
1839:         selected.grid-&gt;cell-&gt;ResetChildren();
1840:         canvas-&gt;Refresh();
1841:         return nullptr;
1842:     }
1843:     void ZoomOutIfNoGrid() {
1844:         if (!WalkPath(drawpath)-&gt;grid) Zoom(-1);
1845:     }
1846:     void PasteSingleText(Cell *c, const wxString &amp;s) { c-&gt;text.Insert(this, s, selected, false); }
1847:     // Polymorphism with wxDataObjectSimple does not work on Windows; bitmap format seems to not be
1848:     // recognized.
1849:     void PasteOrDrop(const wxFileDataObject &amp;filedataobject) {
1850:         const wxArrayString &amp;filenames = filedataobject.GetFilenames();
1851:         if (filenames.size() != 1) {
1852:             sys-&gt;frame-&gt;SetStatus(_(L&quot;Can paste or drop only exactly one file.&quot;));
1853:             return;
1854:         }
1855:         Cell *cell = selected.ThinExpand(this);
1856:         wxString filename = filenames[0];
1857:         wxFFileInputStream fileinputstream(filename);
1858:         if (fileinputstream.IsOk()) {
1859:             char buffer[4];
1860:             fileinputstream.Read(buffer, 4);
1861:             if (!strncmp(buffer, &quot;TSFF&quot;, 4)) {
1862:                 ThreeChoiceDialog askuser(
1863:                     sys-&gt;frame, filename,
1864:                     _(L&quot;It seems that you are about to paste or drop a TreeSheets file. &quot;
1865:                       L&quot;What would you like to do?&quot;),
1866:                     _(L&quot;Open TreeSheets file&quot;), _(L&quot;Paste file path&quot;), _(L&quot;Cancel&quot;));
1867:                 switch (askuser.Run()) {
1868:                     case 0: sys-&gt;frame-&gt;SetStatus(sys-&gt;LoadDB(filename));
1869:                     case 2: return;
1870:                     default:
1871:                     case 1:;
1872:                 }
1873:             }
1874:         }
1875:         if (!cell) return;
1876:         cell-&gt;AddUndo(this);
1877:         if (!LoadImageIntoCell(filename, cell, sys-&gt;frame-&gt;FromDIP(1.0)))
1878:             PasteSingleText(cell, filename);
1879:     }
1880:     void PasteOrDrop(const wxTextDataObject &amp;textdataobject) {
1881:         if (textdataobject.GetText() != wxEmptyString) {
1882:             Cell *cell = selected.ThinExpand(this);
1883:             auto text = textdataobject.GetText();
1884:             if ((sys-&gt;clipboardcopy == text) &amp;&amp; sys-&gt;cellclipboard) {
1885:                 cell-&gt;Paste(this, sys-&gt;cellclipboard.get(), selected);
1886:             } else {
1887:                 const wxArrayString &amp;lines = wxStringTokenize(text, LINE_SEPARATOR);
1888:                 if (lines.size() == 1) {
1889:                     cell-&gt;AddUndo(this);
1890:                     cell-&gt;ResetLayout();
1891:                     PasteSingleText(cell, lines[0]);
1892:                 } else if (lines.size() &gt; 1) {
1893:                     cell-&gt;parent-&gt;AddUndo(this);
1894:                     cell-&gt;ResetLayout();
1895:                     DELETEP(cell-&gt;grid);
1896:                     sys-&gt;FillRows(cell-&gt;AddGrid(), lines, sys-&gt;CountCol(lines[0]), 0, 0);
1897:                     if (!cell-&gt;HasText())
1898:                         cell-&gt;grid-&gt;MergeWithParent(cell-&gt;parent-&gt;grid, selected, this);
1899:                 }
1900:             }
1901:         }
1902:     }
1903:     void PasteOrDrop(const wxBitmapDataObject &amp;bitmapdataobject) {
1904:         if (bitmapdataobject.GetBitmap().GetRefData() != wxNullBitmap.GetRefData()) {
1905:             Cell *cell = selected.ThinExpand(this);
1906:             cell-&gt;AddUndo(this);
1907:             auto image = bitmapdataobject.GetBitmap().ConvertToImage();
1908:             vector&lt;uint8_t&gt; buffer = ConvertWxImageToBuffer(image, wxBITMAP_TYPE_PNG);
1909:             SetImageBM(cell, std::move(buffer), &apos;I&apos;, sys-&gt;frame-&gt;FromDIP(1.0));
1910:             cell-&gt;Reset();
1911:         }
1912:     }
1913:     const wxChar *Sort(bool descending) {
1914:         if (selected.xs != 1 &amp;&amp; selected.ys &lt;= 1)
1915:             return _(
1916:                 L&quot;Can&apos;t sort: make a 1xN selection to indicate what column to sort on, and what rows to affect&quot;);
1917:         selected.grid-&gt;cell-&gt;AddUndo(this);
1918:         selected.grid-&gt;Sort(selected, descending);
1919:         canvas-&gt;Refresh();
1920:         return nullptr;
1921:     }
1922:     void DelRowCol(int &amp;v, int e, int gvs, int dec, int dx, int dy, int nxs, int nys) {
1923:         if (v != e) {
1924:             selected.grid-&gt;cell-&gt;AddUndo(this);
1925:             if (gvs == 1) {
1926:                 selected.grid-&gt;DelSelf(this, selected);
1927:             } else {
1928:                 selected.grid-&gt;DeleteCells(dx, dy, nxs, nys);
1929:                 v -= dec;
1930:             }
1931:             canvas-&gt;Refresh();
1932:         }
1933:     }
1934:     void CreatePath(Cell *c, auto &amp;path) {
1935:         path.clear();
1936:         while (c-&gt;parent) {
1937:             const Selection &amp;s = c-&gt;parent-&gt;grid-&gt;FindCell(c);
1938:             ASSERT(s.grid);
1939:             path.push_back(s);
1940:             c = c-&gt;parent;
1941:         }
1942:     }
1943:     Cell *WalkPath(auto &amp;path) {
1944:         Cell *c = root;
1945:         loopvrev(i, path) {
1946:             Selection &amp;s = path[i];
1947:             Grid *g = c-&gt;grid;
1948:             if (!g) return c;
1949:             ASSERT(g &amp;&amp; s.x &lt; g-&gt;xs &amp;&amp; s.y &lt; g-&gt;ys);
1950:             c = g-&gt;C(s.x, s.y);
1951:         }
1952:         return c;
1953:     }
1954:     bool LastUndoSameCellAny(Cell *c) {
1955:         return undolist.size() &amp;&amp; undolist.size() != undolistsizeatfullsave &amp;&amp;
1956:                undolist.back()-&gt;cloned_from == (uintptr_t)c;
1957:     }
1958:     bool LastUndoSameCellTextEdit(Cell *c) {
1959:         // hacky way to detect word boundaries to stop coalescing, but works, and
1960:         // not a big deal if selected is not actually related to this cell
1961:         return undolist.size() &amp;&amp; !c-&gt;grid &amp;&amp; undolist.size() != undolistsizeatfullsave &amp;&amp;
1962:                undolist.back()-&gt;sel.EqLoc(c-&gt;parent-&gt;grid-&gt;FindCell(c)) &amp;&amp;
1963:                (!c-&gt;text.t.EndsWith(&quot; &quot;) || c-&gt;text.t.Len() != selected.cursor);
1964:     }
1965:     void AddUndo(Cell *c, bool newgeneration = true) {
1966:         redolist.clear();
1967:         lastmodsinceautosave = wxGetLocalTime();
1968:         if (!modified) {
1969:             modified = true;
1970:             UpdateFileName();
1971:         }
1972:         if (LastUndoSameCellTextEdit(c)) return;
1973:         auto ui = make_unique&lt;UndoItem&gt;();
1974:         ui-&gt;clone = c-&gt;Clone(nullptr);
1975:         ui-&gt;estimated_size = c-&gt;EstimatedMemoryUse();
1976:         ui-&gt;sel = selected;
1977:         ui-&gt;cloned_from = (uintptr_t)c;
1978:         if (undolist.size()) ui-&gt;generation = undolist.back()-&gt;generation + (newgeneration ? 1 : 0);
1979:         CreatePath(c, ui-&gt;path);
1980:         if (selected.grid) CreatePath(selected.grid-&gt;cell, ui-&gt;selpath);
1981:         undolist.push_back(std::move(ui));
1982:         size_t total_usage = 0;
1983:         size_t old_list_size = undolist.size();
1984:         // Cull undolist. Always at least keeps last item.
1985:         for (auto i = static_cast&lt;int&gt;(undolist.size()) - 1; i &gt;= 0; i--) {
1986:             // Cull old items if using more than 100MB or 1000 items, whichever comes first.
1987:             // TODO: make configurable?
1988:             if (total_usage &lt; 100 * 1024 * 1024 &amp;&amp; undolist.size() - i &lt; 1000) {
1989:                 total_usage += undolist[i]-&gt;estimated_size;
1990:             } else {
1991:                 undolist.erase(undolist.begin(), undolist.begin() + i + 1);
1992:                 break;
1993:             }
1994:         }
1995:         size_t items_culled = old_list_size - undolist.size();
1996:         undolistsizeatfullsave -= items_culled;  // Allowed to go &lt; 0
1997:     }
1998:     void Undo(auto &amp;fromlist, auto &amp;tolist, bool redo = false) {
1999:         for (bool next = true; next; ) {
2000:             UndoEach(fromlist, tolist, redo);
2001:             next = (fromlist.size() &amp;&amp; tolist.size() &amp;&amp;
2002:                     fromlist.back()-&gt;generation == tolist.back()-&gt;generation)
2003:                        ? true
2004:                        : false;
2005:         }
2006:         if (selected.grid)
2007:             ScrollOrZoom();
2008:         else
2009:             canvas-&gt;Refresh();
2010:         UpdateFileName();
2011:     }
2012:     void UndoEach(auto &amp;fromlist, auto &amp;tolist, bool redo = false) {
2013:         auto beforesel = selected;
2014:         vector&lt;Selection&gt; beforepath;
2015:         if (beforesel.grid) CreatePath(beforesel.grid-&gt;cell, beforepath);
2016:         auto ui = std::move(fromlist.back());
2017:         fromlist.pop_back();
2018:         auto c = WalkPath(ui-&gt;path);
2019:         auto clone = ui-&gt;clone.release();
2020:         ui-&gt;clone.reset(c);
2021:         if (c-&gt;parent &amp;&amp; c-&gt;parent-&gt;grid) {
2022:             c-&gt;parent-&gt;grid-&gt;ReplaceCell(c, clone);
2023:             clone-&gt;parent = c-&gt;parent;
2024:         } else
2025:             root = clone;
2026:         clone-&gt;ResetLayout();
2027:         SetSelect(ui-&gt;sel);
2028:         if (selected.grid) selected.grid = WalkPath(ui-&gt;selpath)-&gt;grid;
2029:         begindrag = selected;
2030:         ui-&gt;sel = beforesel;
2031:         ui-&gt;selpath = std::move(beforepath);
2032:         tolist.push_back(std::move(ui));
2033:         if (undolistsizeatfullsave &gt; undolist.size())
2034:             undolistsizeatfullsave = -1;  // gone beyond the save point, always modified
2035:         modified = undolistsizeatfullsave != undolist.size();
2036:     }
2037:     void ColorChange(int which, int idx) {
2038:         if (!selected.grid) return;
2039:         auto col = idx == CUSTOMCOLORIDX ? sys-&gt;customcolor : celltextcolors[idx];
2040:         switch (which) {
2041:             case A_CELLCOLOR: sys-&gt;lastcellcolor = col; break;
2042:             case A_TEXTCOLOR: sys-&gt;lasttextcolor = col; break;
2043:             case A_BORDCOLOR: sys-&gt;lastbordcolor = col; break;
2044:         }
2045:         selected.grid-&gt;ColorChange(this, which, col, selected);
2046:     }
2047:     void SetImageBM(Cell *c, auto &amp;&amp;data, char type, double scale) {
2048:         c-&gt;text.image = sys-&gt;lastimage =
2049:             sys-&gt;imagelist[sys-&gt;AddImageToList(scale, std::move(data), type)].get();
2050:     }
2051:     bool LoadImageIntoCell(const wxString &amp;filename, Cell *c, double scale) {
2052:         if (filename.empty()) return false;
2053:         auto pnghandler = wxImage::FindHandler(wxBITMAP_TYPE_PNG);
2054:         auto jpghandler = wxImage::FindHandler(wxBITMAP_TYPE_JPEG);
2055:         wxImageHandler *activeHandler = nullptr;
2056:         if (pnghandler &amp;&amp; pnghandler-&gt;CanRead(filename)) {
2057:             activeHandler = pnghandler;
2058:         } else if (jpghandler &amp;&amp; jpghandler-&gt;CanRead(filename)) {
2059:             activeHandler = jpghandler;
2060:         }
2061:         if (activeHandler) {
2062:             wxFile fn(filename);
2063:             if (!fn.IsOpened()) return false;
2064:             vector&lt;uint8_t&gt; buffer(fn.Length());
2065:             fn.Read(buffer.data(), buffer.size());
2066:             SetImageBM(c, std::move(buffer), (activeHandler == pnghandler) ? &apos;I&apos; : &apos;J&apos;, scale);
2067:         } else {
2068:             wxImage image;
2069:             if (!image.LoadFile(filename)) return false;
2070:             auto buffer = ConvertWxImageToBuffer(image, wxBITMAP_TYPE_PNG);
2071:             SetImageBM(c, std::move(buffer), &apos;I&apos;, scale);
2072:         }
2073:         c-&gt;Reset();
2074:         return true;
2075:     }
2076:     void ImageChange(wxString &amp;filename, double scale) {
2077:         if (!selected.grid) return;
2078:         selected.grid-&gt;cell-&gt;AddUndo(this);
2079:         loopallcellssel(c, false) LoadImageIntoCell(filename, c, scale);
2080:         canvas-&gt;Refresh();
2081:     }
2082:     void RecreateTagMenu(wxMenu &amp;menu) {
2083:         int i = A_TAGSET;
2084:         for (auto &amp;[tag, color] : tags) { menu.Append(i++, tag); }
2085:         if (tags.size()) menu.AppendSeparator();
2086:         menu.Append(A_TAGADD, _(L&quot;&amp;Add Cell Text as Tag&quot;));
2087:         menu.Append(A_TAGREMOVE, _(L&quot;&amp;Remove Cell Text from Tags&quot;));
2088:     }
2089:     const wxChar *TagSet(int tagno) {
2090:         int i = 0;
2091:         for (auto &amp;[tag, color] : tags)
2092:             if (i++ == tagno) {
2093:                 selected.grid-&gt;cell-&gt;AddUndo(this);
2094:                 loopallcellssel(c, false) {
2095:                     c-&gt;text.Clear(this, selected);
2096:                     c-&gt;text.Insert(this, tag, selected, true);
2097:                 }
2098:                 selected.grid-&gt;cell-&gt;ResetChildren();
2099:                 selected.grid-&gt;cell-&gt;ResetLayout();
2100:                 canvas-&gt;Refresh();
2101:                 return nullptr;
2102:             }
2103:         ASSERT(0);
2104:         return nullptr;
2105:     }
2106:     void CollectCells(Cell *c) {
2107:         itercells.clear();
2108:         c-&gt;CollectCells(itercells);
2109:     }
2110:     void CollectCellsSel(bool recurse) {
2111:         itercells.clear();
2112:         if (selected.grid) selected.grid-&gt;CollectCellsSel(itercells, selected, recurse);
2113:     }
2114:     void ApplyEditFilter() {
2115:         searchfilter = false;
2116:         paintscrolltoselection = true;
2117:         editfilter = min(max(editfilter, 1), 99);
2118:         CollectCells(root);
2119:         ranges::sort(itercells, [](auto a, auto b) {
2120:             // sort in descending order
2121:             return a-&gt;text.lastedit &gt; b-&gt;text.lastedit;
2122:         });
2123:         loopv(i, itercells) itercells[i]-&gt;text.filtered = i &gt; itercells.size() * editfilter / 100;
2124:         root-&gt;ResetChildren();
2125:         canvas-&gt;Refresh();
2126:     }
2127:     void ApplyEditRangeFilter(wxDateTime &amp;rangebegin, wxDateTime &amp;rangeend) {
2128:         searchfilter = false;
2129:         paintscrolltoselection = true;
2130:         CollectCells(root);
2131:         for (auto c : itercells) {
2132:             c-&gt;text.filtered = !c-&gt;text.lastedit.IsBetween(rangebegin, rangeend);
2133:         }
2134:         root-&gt;ResetChildren();
2135:         canvas-&gt;Refresh();
2136:     }
2137:     wxDateTime ParseDateTimeString(const wxString &amp;s) {
2138:         wxDateTime dt;
2139:         wxString::const_iterator end;
2140:         if (!dt.ParseDateTime(s, &amp;end)) dt = wxInvalidDateTime;
2141:         return dt;
2142:     }
2143:     void SetSearchFilter(bool on) {
2144:         searchfilter = on;
2145:         paintscrolltoselection = true;
2146:         loopallcells(c) c-&gt;text.filtered = on &amp;&amp; !c-&gt;text.IsInSearch();
2147:         root-&gt;ResetChildren();
2148:         canvas-&gt;Refresh();
2149:     }
2150:     void ExportAllImages(const wxString &amp;filename, Cell *exportroot) {
2151:         std::set&lt;Image *&gt; exportimages;
2152:         CollectCells(exportroot);
2153:         for (auto c : itercells)
2154:             if (c-&gt;text.image) exportimages.insert(c-&gt;text.image);
2155:         wxFileName fn(filename);
2156:         auto directory = fn.GetPathWithSep();
2157:         for (auto image : exportimages)
2158:             if (!image-&gt;ExportToDirectory(directory)) break;
2159:     }
2160: };</file><file path="src/evaluator.h">  1: /*
  2:     A structure describing an operation.
  3: */
  4: struct Operation {
  5:     virtual ~Operation() {};
  6:     const char *args;
  7:     virtual unique_ptr&lt;Cell&gt; run() const { return nullptr; }
  8:     virtual double runn(double a) const { return 0; }
  9:     virtual unique_ptr&lt;Cell&gt; runl(Grid *l) const { return nullptr; }
 10:     virtual void rung(Grid *g) const {}
 11:     virtual unique_ptr&lt;Cell&gt; runc(unique_ptr&lt;Cell&gt; c) const { return nullptr; }
 12:     virtual double runnn(double a, double b) const { return 0; }
 13: };
 14: WX_DECLARE_STRING_HASH_MAP(Operation *, wxHashMapOperation);
 15: WX_DECLARE_STRING_HASH_MAP(Cell *, wxHashMapCell);
 16: /*
 17:     Provides running evaluation of a grid.
 18: */
 19: struct Evaluator {
 20:     wxHashMapOperation ops;
 21:     wxHashMapCell vars;
 22:     bool vert;
 23:     ~Evaluator() {
 24:         WX_CLEAR_HASH_MAP(wxHashMapOperation, ops);
 25:         ClearVars();
 26:     }
 27:     void ClearVars() {
 28:         WX_CLEAR_HASH_MAP(wxHashMapCell, vars);
 29:     }
 30:     #define OP(_n, _c, _args, _f)           \
 31:         {                                   \
 32:             struct _op : Operation {        \
 33:                 _op() { args = _args; };    \
 34:                 _f const override { return _c; }; \
 35:             };                              \
 36:             ops[L## #_n] = new _op();       \
 37:         }
 38:     #define OPNN(_n, _c) OP(_n, _c, &quot;nn&quot;, double runnn(double a, double b))
 39:     #define OPN(_n, _c) OP(_n, _c, &quot;n&quot;, double runn(double a))
 40:     #define OPT(_n, _c) OP(_n, _c, &quot;t&quot;, unique_ptr&lt;Cell&gt; runc(unique_ptr&lt;Cell&gt; c))
 41:     #define OPC(_n, _c) OP(_n, _c, &quot;c&quot;, unique_ptr&lt;Cell&gt; runc(unique_ptr&lt;Cell&gt; c))
 42:     #define OPL(_n, _c) OP(_n, _c, &quot;l&quot;, unique_ptr&lt;Cell&gt; runl(Grid *a))
 43:     #define OPG(_n, _c) OP(_n, _c, &quot;g&quot;, void rung(Grid *a))
 44:     void Init() {
 45:         OPNN(+, a + b);
 46:         OPNN(-, a - b);
 47:         OPNN(*, a * b);
 48:         OPNN(/, b != 0 ? a / b : 0);
 49:         OPNN(&lt;, double(a &lt; b));
 50:         OPNN(&gt;, double(a &gt; b));
 51:         OPNN(&lt;=, double(a &lt;= b));
 52:         OPNN(&gt;=, double(a &gt;= b));
 53:         OPNN(=, double(a == b));
 54:         OPNN(==, double(a == b));
 55:         OPNN(!=, double(a != b));
 56:         OPNN(&lt;&gt;, double(a != b));
 57:         OPN(inc, a + 1);
 58:         OPN(dec, a - 1);
 59:         OPN(neg, -a);
 60:         OPT(graph, (c-&gt;Graph(), std::move(c)));
 61:         OPL(sum, a-&gt;Sum())
 62:         OPG(transpose, a-&gt;Transpose())
 63:         struct _if : Operation {
 64:             _if() { args = &quot;nLL&quot;; };
 65:         };
 66:         ops[L&quot;if&quot;] = new _if();
 67:     }
 68:     int InferCellType(Text &amp;t) {
 69:         if (ops[t.t])
 70:             return CT_CODE;
 71:         else
 72:             return CT_DATA;
 73:     }
 74:     unique_ptr&lt;Cell&gt; Lookup(const wxString &amp;name) {
 75:         wxHashMapCell::iterator lookup = vars.find(name);
 76:         return (lookup != vars.end()) ? lookup-&gt;second-&gt;Clone(nullptr) : nullptr;
 77:     }
 78:     bool IsValidSymbol(wxString const &amp;symbol) const { return !symbol.IsEmpty(); }
 79:     void SetSymbol(wxString const &amp;symbol, unique_ptr&lt;Cell&gt; val) {
 80:         if (!this-&gt;IsValidSymbol(symbol)) { return; }
 81:         Cell *old = vars[symbol];
 82:         DELETEP(old);
 83:         vars[symbol] = val.release();
 84:     }
 85:     void Assign(const Cell *sym, const Cell *val) {
 86:         this-&gt;SetSymbol(sym-&gt;text.t, val-&gt;Clone(nullptr));
 87:         if (sym-&gt;grid &amp;&amp; val-&gt;grid) this-&gt;DestructuringAssign(sym-&gt;grid, val-&gt;Clone(nullptr));
 88:     }
 89:     void DestructuringAssign(Grid const *names, unique_ptr&lt;Cell&gt; val) {
 90:         Grid const *ng = names;
 91:         Grid const *vg = val-&gt;grid;
 92:         if (ng-&gt;xs == vg-&gt;xs &amp;&amp; ng-&gt;ys == vg-&gt;ys) {
 93:             loop(x, ng-&gt;xs) loop(y, ng-&gt;ys) {
 94:                 Cell *nc = ng-&gt;C(x, y);
 95:                 Cell *vc = vg-&gt;C(x, y);
 96:                 this-&gt;SetSymbol(nc-&gt;text.t, vc-&gt;Clone(nullptr));
 97:             }
 98:         }
 99:     }
100:     Operation *FindOp(wxString &amp;name) { return ops[name]; }
101:     unique_ptr&lt;Cell&gt; Execute(const Operation *op) { return op-&gt;run(); }
102:     unique_ptr&lt;Cell&gt; Execute(const Operation *op, unique_ptr&lt;Cell&gt; left) {
103:         Text &amp;t = left-&gt;text;
104:         Grid *g = left-&gt;grid;
105:         switch (op-&gt;args[0]) {
106:             case &apos;n&apos;:
107:                 if (t.t.Len()) {
108:                     t.SetNum(op-&gt;runn(t.GetNum()));
109:                     return left;
110:                 } else if (g) {
111:                     foreachcellingrid(c, g) c =
112:                         Execute(op, unique_ptr&lt;Cell&gt;(c)).release()-&gt;SetParent(left.get());
113:                 }
114:                 break;
115:             case &apos;t&apos;:
116:                 if (t.t.Len()) {
117:                     return op-&gt;runc(std::move(left));
118:                 } else if (g) {
119:                     foreachcellingrid(c, g) c =
120:                         Execute(op, unique_ptr&lt;Cell&gt;(c)).release()-&gt;SetParent(left.get());
121:                 }
122:                 break;
123:             case &apos;l&apos;:
124:                 if (g) {
125:                     if (g-&gt;xs == 1 || g-&gt;ys == 1) {
126:                         return op-&gt;runl(g);
127:                     } else {
128:                         vector&lt;unique_ptr&lt;Grid&gt;&gt; gs;
129:                         g-&gt;Split(gs, vert);
130:                         g = new Grid(vert ? gs.size() : 1, vert ? 1 : gs.size());
131:                         auto c = make_unique&lt;Cell&gt;(nullptr, left.get(), CT_DATA, g);
132:                         loopv(i, gs) {
133:                             auto v = op-&gt;runl(gs[i].get()).release();
134:                             g-&gt;C(vert ? i : 0, vert ? 0 : i) = v-&gt;SetParent(c.get());
135:                         }
136:                         return c;
137:                     }
138:                 }
139:                 break;
140:             case &apos;g&apos;:
141:                 if (g) op-&gt;rung(g);
142:                 break;
143:             case &apos;c&apos;: return op-&gt;runc(std::move(left));
144:         }
145:         return left;
146:     }
147:     unique_ptr&lt;Cell&gt; Execute(const Operation *op, unique_ptr&lt;Cell&gt; left, const Cell *_right) {
148:         auto right = _right-&gt;Eval(*this);
149:         if (!right) return left;
150:         Text &amp;t1 = left-&gt;text;
151:         Text &amp;t2 = right-&gt;text;
152:         Grid *g1 = left-&gt;grid;
153:         Grid *g2 = right-&gt;grid;
154:         switch (op-&gt;args[0]) {
155:             case &apos;n&apos;:
156:                 if (t1.t.Len() &amp;&amp; t2.t.Len()) {
157:                     t1.SetNum(op-&gt;runnn(t1.GetNum(), t2.GetNum()));
158:                 } else if (g1 &amp;&amp; g2 &amp;&amp; g1-&gt;xs == g2-&gt;xs &amp;&amp; g1-&gt;ys == g2-&gt;ys) {
159:                     Grid *g = new Grid(g1-&gt;xs, g1-&gt;ys);
160:                     auto c = make_unique&lt;Cell&gt;(nullptr, left.get(), CT_DATA, g);
161:                     loop(x, g-&gt;xs) loop(y, g-&gt;ys) {
162:                         Cell *&amp;c1 = g1-&gt;C(x, y);
163:                         Cell *&amp;c2 = g2-&gt;C(x, y);
164:                         g-&gt;C(x, y) =
165:                             Execute(op, unique_ptr&lt;Cell&gt;(c1), c2).release()-&gt;SetParent(c.get());
166:                         c1 = nullptr;
167:                     }
168:                     return c;
169:                 } else if (g1 &amp;&amp; t2.t.Len()) {
170:                     foreachcellingrid(c, g1) {
171:                         c = Execute(op, unique_ptr&lt;Cell&gt;(c), right.get())
172:                                 .release()
173:                                 -&gt;SetParent(left.get());
174:                     }
175:                 }
176:                 break;
177:         }
178:         return left;
179:     }
180:     // IF is sofar the only ternary
181:     unique_ptr&lt;Cell&gt; Execute(const Operation *op, unique_ptr&lt;Cell&gt; left, const Cell *a,
182:                              const Cell *b) {
183:         Text &amp;l = left-&gt;text;
184:         if (!l.t.Len()) return left;
185:         bool cond = l.GetNum() != 0;
186:         return (cond ? a : b)-&gt;Eval(*this);
187:     }
188:     void Eval(const Cell *root) {
189:         root-&gt;Eval(*this);
190:         ClearVars();
191:     }
192: };</file><file path="src/events.h"> 1: BEGIN_EVENT_TABLE(treesheets::TSFrame, wxFrame)
 2:   EVT_DPI_CHANGED(treesheets::TSFrame::OnDPIChanged)
 3:   EVT_SIZING(treesheets::TSFrame::OnSizing)
 4:   EVT_MENU(wxID_ANY, treesheets::TSFrame::OnMenu)
 5:   EVT_TEXT(A_SEARCH, treesheets::TSFrame::OnSearch)
 6:   EVT_TEXT_ENTER(A_SEARCH, treesheets::TSFrame::OnSearchReplaceEnter)
 7:   EVT_TEXT_ENTER(A_REPLACE, treesheets::TSFrame::OnSearchReplaceEnter)
 8:   EVT_CLOSE(treesheets::TSFrame::OnClosing)
 9:   EVT_MAXIMIZE(treesheets::TSFrame::OnMaximize)
10:   EVT_ACTIVATE_APP(treesheets::TSFrame::OnActivate)
11:   EVT_COMBOBOX(A_CELLCOLOR, treesheets::TSFrame::OnChangeColor)
12:   EVT_COMBOBOX(A_TEXTCOLOR, treesheets::TSFrame::OnChangeColor)
13:   EVT_COMBOBOX(A_BORDCOLOR, treesheets::TSFrame::OnChangeColor)
14:   EVT_COMBOBOX(A_DDIMAGE,   treesheets::TSFrame::OnDDImage)
15:   EVT_ICONIZE(treesheets::TSFrame::OnIconize)
16:   EVT_AUINOTEBOOK_PAGE_CHANGED(wxID_ANY, treesheets::TSFrame::OnTabChange)
17:   EVT_AUINOTEBOOK_PAGE_CLOSE(wxID_ANY, treesheets::TSFrame::OnTabClose)
18:   EVT_SYS_COLOUR_CHANGED(treesheets::TSFrame::OnSysColourChanged)
19: END_EVENT_TABLE()
20: BEGIN_EVENT_TABLE(treesheets::TSApp, wxApp)
21: END_EVENT_TABLE()
22: BEGIN_EVENT_TABLE(treesheets::TSCanvas, wxScrolledWindow)
23:   EVT_MOUSEWHEEL(treesheets::TSCanvas::OnMouseWheel)
24:   EVT_PAINT(treesheets::TSCanvas::OnPaint)
25:   EVT_MOTION(treesheets::TSCanvas::OnMotion)
26:   EVT_LEFT_DOWN(treesheets::TSCanvas::OnLeftDown)
27:   EVT_LEFT_UP(treesheets::TSCanvas::OnLeftUp)
28:   EVT_RIGHT_DOWN(treesheets::TSCanvas::OnRightDown)
29:   EVT_LEFT_DCLICK(treesheets::TSCanvas::OnLeftDoubleClick)
30:   EVT_CHAR(treesheets::TSCanvas::OnChar)
31:   EVT_KEY_DOWN(treesheets::TSCanvas::OnKeyDown)
32:   EVT_CONTEXT_MENU(treesheets::TSCanvas::OnContextMenuClick)
33:   EVT_SIZE(treesheets::TSCanvas::OnSize)
34:   EVT_SCROLLWIN(treesheets::TSCanvas::OnScrollWin)
35: END_EVENT_TABLE()
36: BEGIN_EVENT_TABLE(treesheets::ThreeChoiceDialog, wxDialog)
37:     EVT_BUTTON(wxID_ANY, treesheets::ThreeChoiceDialog::OnButton)
38: END_EVENT_TABLE()
39: BEGIN_EVENT_TABLE(treesheets::DateTimeRangeDialog, wxDialog)
40:     EVT_BUTTON(wxID_ANY, treesheets::DateTimeRangeDialog::OnButton)
41: END_EVENT_TABLE()</file><file path="src/genpot.bat">1: xgettext --keyword=_ --sort-output --no-location -o ../TS/translations/ts.pot tsframe.h document.h system.h wxtools.h</file><file path="src/grid.h">   1: struct Grid {
   2:     // owning cell.
   3:     Cell *cell;
   4:     // subcells
   5:     Cell **cells;
   6:     // widths for each column
   7:     vector&lt;int&gt; colwidths;
   8:     // xsize, ysize
   9:     int xs;
  10:     int ys;
  11:     int view_margin;
  12:     int view_grid_outer_spacing;
  13:     int user_grid_outer_spacing {g_usergridouterspacing_default};
  14:     int cell_margin;
  15:     int bordercolor {g_bordercolor_default};
  16:     bool horiz {false};
  17:     bool tinyborder;
  18:     bool folded {false};
  19:     Cell *&amp;C(int x, int y) const {
  20:         ASSERT(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; xs &amp;&amp; y &lt; ys);
  21:         return cells[x + y * xs];
  22:     }
  23:     #define foreachcell(c)                \
  24:         for (int y = 0; y &lt; ys; y++)      \
  25:             for (int x = 0; x &lt; xs; x++)  \
  26:                 for (bool _f = true; _f;) \
  27:                     for (Cell *&amp;c = C(x, y); _f; _f = false)
  28:     #define foreachcellrev(c)                 \
  29:         for (int y = ys - 1; y &gt;= 0; y--)     \
  30:             for (int x = xs - 1; x &gt;= 0; x--) \
  31:                 for (bool _f = true; _f;)     \
  32:                     for (Cell *&amp;c = C(x, y); _f; _f = false)
  33:     #define foreachcelly(c)           \
  34:         for (int y = 0; y &lt; ys; y++)  \
  35:             for (bool _f = true; _f;) \
  36:                 for (Cell *&amp;c = C(0, y); _f; _f = false)
  37:     #define foreachcellcolumn(c)          \
  38:         for (int x = 0; x &lt; xs; x++)      \
  39:             for (int y = 0; y &lt; ys; y++)  \
  40:                 for (bool _f = true; _f;) \
  41:                     for (Cell *&amp;c = C(x, y); _f; _f = false)
  42:     #define foreachcellinsel(c, s)                 \
  43:         for (int y = s.y; y &lt; s.y + s.ys; y++)     \
  44:             for (int x = s.x; x &lt; s.x + s.xs; x++) \
  45:                 for (bool _f = true; _f;)          \
  46:                     for (Cell *&amp;c = C(x, y); _f; _f = false)
  47:     #define foreachcellinselrev(c, s)                   \
  48:         for (int y = s.y + s.ys - 1; y &gt;= s.y; y--)     \
  49:             for (int x = s.x + s.xs - 1; x &gt;= s.x; x--) \
  50:                 for (bool _f = true; _f;)               \
  51:                     for (Cell *&amp;c = C(x, y); _f; _f = false)
  52:     #define foreachcellingrid(c, g)         \
  53:         for (int y = 0; y &lt; g-&gt;ys; y++)     \
  54:             for (int x = 0; x &lt; g-&gt;xs; x++) \
  55:                 for (bool _f = true; _f;)   \
  56:                     for (Cell *&amp;c = g-&gt;C(x, y); _f; _f = false)
  57:     Grid(int _xs, int _ys, Cell *_c = nullptr)
  58:         : xs(_xs), ys(_ys), cell(_c), cells(new Cell *[_xs * _ys]) {
  59:         foreachcell(c) c = nullptr;
  60:         InitColWidths();
  61:         SetOrient();
  62:     }
  63:     ~Grid() {
  64:         foreachcell(c) if (c) delete c;
  65:         delete[] cells;
  66:     }
  67:     void InitCells(Cell *clonestylefrom = nullptr) {
  68:         foreachcell(c) c = new Cell(cell, clonestylefrom);
  69:     }
  70:     void CloneStyleFrom(auto o) {
  71:         bordercolor = o-&gt;bordercolor;
  72:         // TODO: what others?
  73:     }
  74:     void InitColWidths() {
  75:         colwidths.clear();
  76:         colwidths.resize(xs, cell ? cell-&gt;ColWidth() : sys-&gt;defaultmaxcolwidth);
  77:     }
  78:     /* Clones g into this grid. This mutates the grid this function is called on. */
  79:     void Clone(Grid *g) {
  80:         g-&gt;bordercolor = bordercolor;
  81:         g-&gt;user_grid_outer_spacing = user_grid_outer_spacing;
  82:         g-&gt;folded = folded;
  83:         foreachcell(c) g-&gt;C(x, y) = c-&gt;Clone(g-&gt;cell).release();
  84:         loop(x, xs) g-&gt;colwidths[x] = colwidths[x];
  85:     }
  86:     unique_ptr&lt;Cell&gt; CloneSel(const Selection &amp;sel) {
  87:         auto cl = make_unique&lt;Cell&gt;(nullptr, sel.grid-&gt;cell, CT_DATA, new Grid(sel.xs, sel.ys));
  88:         foreachcellinsel(c, sel) cl-&gt;grid-&gt;C(x - sel.x, y - sel.y) = c-&gt;Clone(cl.get()).release();
  89:         loop(i, sel.xs) cl-&gt;grid-&gt;colwidths[i] = sel.grid-&gt;colwidths[i];
  90:         return cl;
  91:     }
  92:     size_t EstimatedMemoryUse() {
  93:         size_t sum = 0;
  94:         foreachcell(c) sum += c-&gt;EstimatedMemoryUse();
  95:         return sizeof(Grid) + xs * ys * sizeof(Cell *) + sum;
  96:     }
  97:     void SetOrient() {
  98:         if (xs &gt; ys) horiz = true;
  99:         if (ys &gt; xs) horiz = false;
 100:     }
 101:     bool Layout(Document *doc, wxDC &amp;dc, int depth, int &amp;sx, int &amp;sy, int startx, int starty,
 102:                 bool forcetiny) {
 103:         auto xa = new int[xs];
 104:         auto ya = new int[ys];
 105:         loop(i, xs) xa[i] = 0;
 106:         loop(i, ys) ya[i] = 0;
 107:         tinyborder = true;
 108:         foreachcell(c) {
 109:             c-&gt;LazyLayout(doc, dc, depth + 1, colwidths[x], forcetiny);
 110:             tinyborder = c-&gt;tiny &amp;&amp; tinyborder;
 111:             xa[x] = max(xa[x], c-&gt;sx);
 112:             ya[y] = max(ya[y], c-&gt;sy);
 113:         }
 114:         view_grid_outer_spacing =
 115:             tinyborder || cell-&gt;drawstyle != DS_GRID ? 0 : user_grid_outer_spacing;
 116:         view_margin = tinyborder || cell-&gt;drawstyle != DS_GRID ? 0 : g_grid_margin;
 117:         cell_margin = tinyborder ? 0 : (cell-&gt;drawstyle == DS_GRID ? 0 : g_cell_margin);
 118:         sx = (xs + 1) * g_line_width + xs * cell_margin * 2 +
 119:              2 * (view_grid_outer_spacing + view_margin) + startx;
 120:         sy = (ys + 1) * g_line_width + ys * cell_margin * 2 +
 121:              2 * (view_grid_outer_spacing + view_margin) + starty;
 122:         loop(i, xs) sx += xa[i];
 123:         loop(i, ys) sy += ya[i];
 124:         int cx = view_grid_outer_spacing + view_margin + g_line_width + cell_margin + startx;
 125:         int cy = view_grid_outer_spacing + view_margin + g_line_width + cell_margin + starty;
 126:         if (!cell-&gt;tiny) {
 127:             cx += g_margin_extra;
 128:             cy += g_margin_extra;
 129:         }
 130:         foreachcell(c) {
 131:             c-&gt;ox = cx;
 132:             c-&gt;oy = cy;
 133:             if (c-&gt;drawstyle == DS_BLOBLINE &amp;&amp; !c-&gt;grid) {
 134:                 assert(c-&gt;sy &lt;= ya[y]);
 135:                 c-&gt;ycenteroff = (ya[y] - c-&gt;sy) / 2;
 136:             }
 137:             c-&gt;sx = xa[x];
 138:             c-&gt;sy = ya[y];
 139:             cx += xa[x] + g_line_width + cell_margin * 2;
 140:             if (x == xs - 1) {
 141:                 cy += ya[y] + g_line_width + cell_margin * 2;
 142:                 cx = view_grid_outer_spacing + view_margin + g_line_width + cell_margin + startx;
 143:                 if (!cell-&gt;tiny) cx += g_margin_extra;
 144:             }
 145:         }
 146:         delete[] xa;
 147:         delete[] ya;
 148:         return tinyborder;
 149:     }
 150:     void Render(Document *doc, int bx, int by, wxDC &amp;dc, int depth, int sx, int sy, int xoff,
 151:                 int yoff) {
 152:         xoff = C(0, 0)-&gt;ox - view_margin - view_grid_outer_spacing - 1;
 153:         yoff = C(0, 0)-&gt;oy - view_margin - view_grid_outer_spacing - 1;
 154:         int maxx = C(xs - 1, 0)-&gt;ox + C(xs - 1, 0)-&gt;sx;
 155:         int maxy = C(0, ys - 1)-&gt;oy + C(0, ys - 1)-&gt;sy;
 156:         if (tinyborder || cell-&gt;drawstyle == DS_GRID) {
 157:             int ldelta = view_grid_outer_spacing != 0;
 158:             auto drawlines = [&amp;]() {
 159:                 for (int x = ldelta; x &lt;= xs - ldelta; x++) {
 160:                     int xl = (x == xs ? maxx : C(x, 0)-&gt;ox - g_line_width) + bx;
 161:                     if (xl &gt;= doc-&gt;scrollx &amp;&amp; xl &lt;= doc-&gt;maxx) loop(line, g_line_width) {
 162:                             dc.DrawLine(
 163:                                 xl + line, max(doc-&gt;scrolly, by + yoff + view_grid_outer_spacing),
 164:                                 xl + line, min(doc-&gt;maxy, by + maxy + g_line_width) + view_margin);
 165:                         }
 166:                 }
 167:                 for (int y = ldelta; y &lt;= ys - ldelta; y++) {
 168:                     int yl = (y == ys ? maxy : C(0, y)-&gt;oy - g_line_width) + by;
 169:                     if (yl &gt;= doc-&gt;scrolly &amp;&amp; yl &lt;= doc-&gt;maxy) loop(line, g_line_width) {
 170:                             dc.DrawLine(max(doc-&gt;scrollx,
 171:                                             bx + xoff + view_grid_outer_spacing + g_line_width),
 172:                                         yl + line, min(doc-&gt;maxx, bx + maxx) + view_margin,
 173:                                         yl + line);
 174:                         }
 175:                 }
 176:             };
 177:             if (!sys-&gt;fastrender &amp;&amp; view_grid_outer_spacing &amp;&amp; cell-&gt;cellcolor != 0xFFFFFF) {
 178:                 dc.SetPen(sys-&gt;darkmode ? *wxBLACK_PEN : *wxWHITE_PEN);
 179:                 drawlines();
 180:             }
 181:             // dotted lines result in very expensive drawline calls
 182:             dc.SetPen(view_grid_outer_spacing &amp;&amp; !sys-&gt;fastrender ? sys-&gt;pen_gridlines
 183:                                                                   : sys-&gt;pen_tinygridlines);
 184:             drawlines();
 185:         }
 186:         foreachcell(c) {
 187:             int cx = bx + c-&gt;ox;
 188:             int cy = by + c-&gt;oy;
 189:             if (cx &lt; doc-&gt;maxx &amp;&amp; cx + c-&gt;sx &gt; doc-&gt;scrollx &amp;&amp; cy &lt; doc-&gt;maxy &amp;&amp;
 190:                 cy + c-&gt;sy &gt; doc-&gt;scrolly) {
 191:                 c-&gt;Render(doc, cx, cy, dc, depth + 1, (x == 0) * view_margin,
 192:                           (x == xs - 1) * view_margin, (y == 0) * view_margin,
 193:                           (y == ys - 1) * view_margin, colwidths[x], cell_margin);
 194:             }
 195:         }
 196:         if (cell-&gt;drawstyle == DS_BLOBLINE &amp;&amp; !tinyborder &amp;&amp; cell-&gt;HasHeader() &amp;&amp; !cell-&gt;tiny) {
 197:             const int arcsize = 8;
 198:             int srcy = by + cell-&gt;ycenteroff +
 199:                        (cell-&gt;verticaltextandgrid ? cell-&gt;tys + 2 : cell-&gt;tys / 2) + g_margin_extra;
 200:             // fixme: the 8 is chosen to fit the smallest text size, not very portable
 201:             int srcx = bx + (cell-&gt;verticaltextandgrid ? 8 : cell-&gt;txs + 4) + g_margin_extra;
 202:             int destyfirst = -1, destylast = -1;
 203:             dc.SetPen(*wxGREY_PEN);
 204:             foreachcelly(c) if (c-&gt;HasContent() &amp;&amp; !c-&gt;tiny) {
 205:                 int desty = c-&gt;ycenteroff + by + c-&gt;oy + c-&gt;tys / 2 + g_margin_extra;
 206:                 int destx = bx + c-&gt;ox - 2 + g_margin_extra;
 207:                 bool visible = srcx &lt; doc-&gt;maxx &amp;&amp; destx &gt; doc-&gt;scrollx &amp;&amp;
 208:                                desty - arcsize &lt; doc-&gt;maxy &amp;&amp; desty + arcsize &gt; doc-&gt;scrolly;
 209:                 if (abs(srcy - desty) &lt; arcsize &amp;&amp; !cell-&gt;verticaltextandgrid) {
 210:                     if (destyfirst &lt; 0) destyfirst = desty;
 211:                     destylast = desty;
 212:                     if (visible) dc.DrawLine(srcx, desty, destx, desty);
 213:                 } else {
 214:                     if (desty &lt; srcy) {
 215:                         if (destyfirst &lt; 0) destyfirst = desty + arcsize;
 216:                         destylast = desty + arcsize;
 217:                         if (visible) dc.DrawBitmap(sys-&gt;frame-&gt;line_nw, srcx, desty, true);
 218:                     } else {
 219:                         destylast = desty - arcsize;
 220:                         if (visible)
 221:                             dc.DrawBitmap(sys-&gt;frame-&gt;line_sw, srcx, desty - arcsize, true);
 222:                         desty--;
 223:                     }
 224:                     if (visible) dc.DrawLine(srcx + arcsize, desty, destx, desty);
 225:                 }
 226:             }
 227:             if (cell-&gt;verticaltextandgrid) {
 228:                 if (destylast &gt; 0) dc.DrawLine(srcx, srcy, srcx, destylast);
 229:             } else {
 230:                 if (destyfirst &gt;= 0 &amp;&amp; destylast &gt;= 0 &amp;&amp; destyfirst &lt; destylast) {
 231:                     destyfirst = min(destyfirst, srcy);
 232:                     destylast = max(destylast, srcy);
 233:                     dc.DrawLine(srcx, destyfirst, srcx, destylast);
 234:                 }
 235:             }
 236:         }
 237:         if (view_grid_outer_spacing &amp;&amp; cell-&gt;drawstyle == DS_GRID) {
 238:             dc.SetBrush(*wxTRANSPARENT_BRUSH);
 239:             dc.SetPen(wxPen(wxColour(LightColor(bordercolor))));
 240:             loop(i, view_grid_outer_spacing - 1) {
 241:                 dc.DrawRoundedRectangle(
 242:                     bx + xoff + view_grid_outer_spacing - i,
 243:                     by + yoff + view_grid_outer_spacing - i,
 244:                     maxx - xoff - view_grid_outer_spacing + 1 + i * 2 + view_margin,
 245:                     maxy - yoff - view_grid_outer_spacing + 1 + i * 2 + view_margin,
 246:                     sys-&gt;roundness + i);
 247:             }
 248:         }
 249:     }
 250:     void FindXY(Document *doc, int px, int py, wxDC &amp;dc) {
 251:         foreachcell(c) {
 252:             int bx = px - c-&gt;ox;
 253:             int by = py - c-&gt;oy;
 254:             if (bx &gt;= 0 &amp;&amp; by &gt;= -g_line_width - g_selmargin &amp;&amp; bx &lt; c-&gt;sx &amp;&amp; by &lt; g_selmargin) {
 255:                 doc-&gt;hover = Selection(this, x, y, 1, 0);
 256:                 return;
 257:             }
 258:             if (bx &gt;= 0 &amp;&amp; by &gt;= c-&gt;sy - g_selmargin &amp;&amp; bx &lt; c-&gt;sx &amp;&amp;
 259:                 by &lt; c-&gt;sy + g_line_width + g_selmargin) {
 260:                 doc-&gt;hover = Selection(this, x, y + 1, 1, 0);
 261:                 return;
 262:             }
 263:             if (bx &gt;= -g_line_width - g_selmargin &amp;&amp; by &gt;= 0 &amp;&amp; bx &lt; g_selmargin &amp;&amp; by &lt; c-&gt;sy) {
 264:                 doc-&gt;hover = Selection(this, x, y, 0, 1);
 265:                 return;
 266:             }
 267:             if (bx &gt;= c-&gt;sx - g_selmargin &amp;&amp; by &gt;= 0 &amp;&amp; bx &lt; c-&gt;sx + g_line_width + g_selmargin &amp;&amp;
 268:                 by &lt; c-&gt;sy) {
 269:                 doc-&gt;hover = Selection(this, x + 1, y, 0, 1);
 270:                 return;
 271:             }
 272:             if (c-&gt;IsInside(bx, by)) {
 273:                 if (c-&gt;GridShown(doc)) c-&gt;grid-&gt;FindXY(doc, bx, by, dc);
 274:                 if (doc-&gt;hover.grid) return;
 275:                 doc-&gt;hover = Selection(this, x, y, 1, 1);
 276:                 if (c-&gt;HasText()) {
 277:                     c-&gt;text.FindCursor(doc, bx, by - c-&gt;ycenteroff, dc, doc-&gt;hover, colwidths[x]);
 278:                 }
 279:                 return;
 280:             }
 281:         }
 282:     }
 283:     Cell *FindLink(const Selection &amp;sel, Cell *link, Cell *best, bool &amp;lastthis, bool &amp;stylematch,
 284:                    bool forward, bool image) {
 285:         if (forward) {
 286:             foreachcell(c) best =
 287:                 c-&gt;FindLink(sel, link, best, lastthis, stylematch, forward, image);
 288:         } else {
 289:             foreachcellrev(c) best =
 290:                 c-&gt;FindLink(sel, link, best, lastthis, stylematch, forward, image);
 291:         }
 292:         return best;
 293:     }
 294:     Cell *FindNextSearchMatch(const wxString &amp;search, Cell *best, Cell *selected,
 295:                               bool &amp;lastwasselected, bool reverse) {
 296:         if (reverse) {
 297:             foreachcellrev(c) best =
 298:                 c-&gt;FindNextSearchMatch(search, best, selected, lastwasselected, reverse);
 299:         } else {
 300:             foreachcell(c) best =
 301:                 c-&gt;FindNextSearchMatch(search, best, selected, lastwasselected, reverse);
 302:         }
 303:         return best;
 304:     }
 305:     Cell *FindNextFilterMatch(Cell *best, Cell *selected, bool &amp;lastwasselected) {
 306:         foreachcell(c) best = c-&gt;FindNextFilterMatch(best, selected, lastwasselected);
 307:         return best;
 308:     }
 309:     void FindReplaceAll(const wxString &amp;s, const wxString &amp;ls) {
 310:         foreachcell(c) c-&gt;FindReplaceAll(s, ls);
 311:     }
 312:     void ReplaceCell(Cell *o, Cell *n) { foreachcell(c) if (c == o) c = n; }
 313:     Selection FindCell(Cell *o) {
 314:         foreachcell(c) if (c == o) return Selection(this, x, y, 1, 1);
 315:         return Selection();
 316:     }
 317:     Selection SelectAll() { return Selection(this, 0, 0, xs, ys); }
 318:     void ImageRefCount(bool includefolded) {
 319:         if (includefolded || !folded) foreachcell(c) c-&gt;ImageRefCount(includefolded);
 320:     }
 321:     void DrawCursor(Document *doc, wxDC &amp;dc, Selection &amp;sel, bool full, uint color) {
 322:         if (auto c = sel.GetCell(); c &amp;&amp; !c-&gt;tiny &amp;&amp; (c-&gt;HasText() || !c-&gt;grid))
 323:             c-&gt;text.DrawCursor(doc, dc, sel, full, color, colwidths[sel.x]);
 324:     }
 325:     void DrawInsert(Document *doc, wxDC &amp;dc, Selection &amp;sel, uint colour) {
 326:         dc.SetPen(sys-&gt;pen_thinselect);
 327:         if (!sel.xs) {
 328:             auto c = C(sel.x - (sel.x == xs), sel.y);
 329:             int x = c-&gt;GetX(doc) + (c-&gt;sx + g_line_width + cell_margin) * (sel.x == xs) -
 330:                     g_line_width - cell_margin;
 331:             loop(line, g_line_width)
 332:                 dc.DrawLine(x + line, max(cell-&gt;GetY(doc), doc-&gt;scrolly), x + line,
 333:                             min(cell-&gt;GetY(doc) + cell-&gt;sy, doc-&gt;maxy));
 334:             DrawRectangle(dc, colour, x - 1, c-&gt;GetY(doc), g_line_width + 2, c-&gt;sy);
 335:         } else {
 336:             auto c = C(sel.x, sel.y - (sel.y == ys));
 337:             int y = c-&gt;GetY(doc) + (c-&gt;sy + g_line_width + cell_margin) * (sel.y == ys) -
 338:                     g_line_width - cell_margin;
 339:             loop(line, g_line_width)
 340:                 dc.DrawLine(max(cell-&gt;GetX(doc), doc-&gt;scrollx), y + line,
 341:                             min(cell-&gt;GetX(doc) + cell-&gt;sx, doc-&gt;maxx), y + line);
 342:             DrawRectangle(dc, colour, c-&gt;GetX(doc), y - 1, c-&gt;sx, g_line_width + 2);
 343:         }
 344:     }
 345:     wxRect GetRect(Document *doc, const Selection &amp;sel, bool minimal = false) {
 346:         if (sel.Thin()) {
 347:             if (sel.xs) {
 348:                 if (sel.y &lt; ys) {
 349:                     auto tl = C(sel.x, sel.y);
 350:                     return wxRect(tl-&gt;GetX(doc), tl-&gt;GetY(doc), tl-&gt;sx, 0);
 351:                 } else {
 352:                     auto br = C(sel.x, ys - 1);
 353:                     return wxRect(br-&gt;GetX(doc), br-&gt;GetY(doc) + br-&gt;sy, br-&gt;sx, 0);
 354:                 }
 355:             } else {
 356:                 if (sel.x &lt; xs) {
 357:                     auto tl = C(sel.x, sel.y);
 358:                     return wxRect(tl-&gt;GetX(doc), tl-&gt;GetY(doc), 0, tl-&gt;sy);
 359:                 } else {
 360:                     auto br = C(xs - 1, sel.y);
 361:                     return wxRect(br-&gt;GetX(doc) + br-&gt;sx, br-&gt;GetY(doc), 0, br-&gt;sy);
 362:                 }
 363:             }
 364:         } else {
 365:             auto tl = C(sel.x, sel.y);
 366:             auto br = C(sel.x + sel.xs - 1, sel.y + sel.ys - 1);
 367:             wxRect r(tl-&gt;GetX(doc) - cell_margin, tl-&gt;GetY(doc) - cell_margin,
 368:                      br-&gt;GetX(doc) + br-&gt;sx - tl-&gt;GetX(doc) + cell_margin * 2,
 369:                      br-&gt;GetY(doc) + br-&gt;sy - tl-&gt;GetY(doc) + cell_margin * 2);
 370:             if (minimal &amp;&amp; tl == br) r.width -= tl-&gt;sx - tl-&gt;minx;
 371:             return r;
 372:         }
 373:     }
 374:     void DrawSelect(Document *doc, wxDC &amp;dc, Selection &amp;sel) {
 375:         if (sel.Thin()) {
 376:             DrawInsert(doc, dc, sel, 0);
 377:         } else {
 378:             dc.SetBrush(sys-&gt;darkmode ? *wxWHITE_BRUSH : *wxBLACK_BRUSH);
 379:             dc.SetPen(sys-&gt;darkmode ? *wxWHITE_PEN : *wxBLACK_PEN);
 380:             wxRect g = GetRect(doc, sel);
 381:             int lw = g_line_width;
 382:             int te = sel.TextEdit();
 383:             dc.DrawRectangle(g.x - 1 - lw, g.y - 1 - lw, g.width + 2 + 2 * lw, 2 + lw - te);
 384:             dc.DrawRectangle(g.x - 1 - lw, g.y - 1 + g.height + te, g.width + 2 + 2 * lw - 5,
 385:                              2 + lw - te);
 386:             dc.DrawRectangle(g.x - 1 - lw, g.y + 1 - te, 2 + lw - te, g.height - 2 + 2 * te);
 387:             dc.DrawRectangle(g.x - 1 + g.width + te, g.y + 1 - te, 2 + lw - te,
 388:                              g.height - 2 + 2 * te - 2 - te);
 389:             dc.DrawRectangle(g.x + g.width, g.y + g.height - 2, lw + 2, lw + 4);
 390:             dc.DrawRectangle(g.x + g.width - lw - 1, g.y + g.height - 2 + 2 * te, lw + 1,
 391:                              lw + 4 - 2 * te);
 392:             if (sel.TextEdit()) {
 393:                 DrawCursor(doc, dc, sel, true, sys-&gt;cursorcolor);
 394:             } else {
 395:                 HintIMELocation(doc, g.x, g.y, g_deftextsize * 1.333, 0);
 396:             }
 397:         }
 398:     }
 399:     void DeleteCells(int dx, int dy, int nxs, int nys) {
 400:         auto **ncells = new Cell *[(xs + nxs) * (ys + nys)];
 401:         auto **ncp = ncells;
 402:         foreachcell(c) if (x == dx || y == dy) DELETEP(c) else *ncp++ = c;
 403:         delete[] cells;
 404:         cells = ncells;
 405:         xs += nxs;
 406:         ys += nys;
 407:         if (dx &gt;= 0) colwidths.erase(colwidths.begin() + dx);
 408:         SetOrient();
 409:     }
 410:     void MultiCellDelete(Document *doc, Selection &amp;sel) {
 411:         cell-&gt;AddUndo(doc);
 412:         MultiCellDeleteSub(doc, sel);
 413:         doc-&gt;canvas-&gt;Refresh();
 414:     }
 415:     void MultiCellDeleteSub(Document *doc, Selection &amp;sel) {
 416:         foreachcellinsel(c, sel) c-&gt;Clear();
 417:         bool delhoriz = true, delvert = true;
 418:         foreachcell(c) {
 419:             if (c-&gt;HasContent()) {
 420:                 if (y &gt;= sel.y &amp;&amp; y &lt; sel.y + sel.ys) delhoriz = false;
 421:                 if (x &gt;= sel.x &amp;&amp; x &lt; sel.x + sel.xs) delvert = false;
 422:             }
 423:         }
 424:         if (delhoriz &amp;&amp; (!delvert || sel.xs &gt;= sel.ys)) {
 425:             if (sel.ys == ys) {
 426:                 DelSelf(doc, sel);
 427:             } else {
 428:                 loop(i, sel.ys) DeleteCells(-1, sel.y, 0, -1);
 429:                 sel.ys = 0;
 430:                 sel.xs = 1;
 431:             }
 432:         } else if (delvert) {
 433:             if (sel.xs == xs) {
 434:                 DelSelf(doc, sel);
 435:             } else {
 436:                 loop(i, sel.xs) DeleteCells(sel.x, -1, -1, 0);
 437:                 sel.xs = 0;
 438:                 sel.ys = 1;
 439:             }
 440:         } else {
 441:             auto c = sel.GetCell();
 442:             if (c) sel.EnterEdit(doc);
 443:         }
 444:     }
 445:     void DelSelf(Document *doc, Selection &amp;s) {
 446:         if (!doc-&gt;drawpath.empty() &amp;&amp; doc-&gt;drawpath.back().grid == this) {
 447:             doc-&gt;drawpath.pop_back();
 448:             doc-&gt;currentdrawroot = doc-&gt;WalkPath(doc-&gt;drawpath);
 449:         }
 450:         if (!cell-&gt;parent) return;  // FIXME: deletion of root cell, what would be better?
 451:         s = cell-&gt;parent-&gt;grid-&gt;FindCell(cell);
 452:         auto &amp;pthis = cell-&gt;grid;
 453:         DELETEP(pthis);
 454:     }
 455:     void InsertCells(int dx, int dy, int nxs, int nys, Cell *nc = nullptr) {
 456:         assert(((dx &lt; 0) == (nxs == 0)) &amp;&amp; ((dy &lt; 0) == (nys == 0)));
 457:         assert(nxs + nys == 1);
 458:         Cell **ocells = cells;
 459:         cells = new Cell *[(xs + nxs) * (ys + nys)];
 460:         xs += nxs;
 461:         ys += nys;
 462:         Cell **ncp = ocells;
 463:         SetOrient();
 464:         foreachcell(c) if (x == dx || y == dy) {
 465:             if (nc)
 466:                 c = nc;
 467:             else {
 468:                 Cell *colcell = ocells[(nxs ? max(0, min(dx - 1, xs - nxs - 1)) : x) +
 469:                                        (nxs ? y : max(0, min(dy - 1, ys - nys - 1))) * (xs - nxs)];
 470:                 c = new Cell(cell, colcell);
 471:                 c-&gt;text.relsize = colcell-&gt;text.relsize;
 472:             }
 473:         }
 474:         else c = *ncp++;
 475:         delete[] ocells;
 476:         if (dx &gt;= 0) colwidths.insert(colwidths.begin() + dx, cell-&gt;ColWidth());
 477:     }
 478:     void Save(wxDataOutputStream &amp;dos, Cell *ocs) const {
 479:         dos.Write32(xs);
 480:         dos.Write32(ys);
 481:         dos.Write32(bordercolor);
 482:         dos.Write32(user_grid_outer_spacing);
 483:         dos.Write8(cell-&gt;verticaltextandgrid);
 484:         dos.Write8(folded);
 485:         loop(x, xs) dos.Write32(colwidths[x]);
 486:         foreachcell(c) c-&gt;Save(dos, ocs);
 487:     }
 488:     bool LoadContents(wxDataInputStream &amp;dis, int &amp;numcells, int &amp;textbytes, Cell *&amp;ics) {
 489:         if (sys-&gt;versionlastloaded &gt;= 10) {
 490:             bordercolor = dis.Read32() &amp; 0xFFFFFF;
 491:             user_grid_outer_spacing = dis.Read32();
 492:             if (sys-&gt;versionlastloaded &gt;= 11) {
 493:                 cell-&gt;verticaltextandgrid = dis.Read8() != 0;
 494:                 if (sys-&gt;versionlastloaded &gt;= 13) {
 495:                     if (sys-&gt;versionlastloaded &gt;= 16) {
 496:                         folded = dis.Read8() != 0;
 497:                         if (folded &amp;&amp; sys-&gt;versionlastloaded &lt;= 17) {
 498:                             // Before v18, folding would use the image slot. So if this cell
 499:                             // contains an image, clear it.
 500:                             cell-&gt;text.image = nullptr;
 501:                         }
 502:                     }
 503:                     loop(x, xs) colwidths[x] = dis.Read32();
 504:                 }
 505:             }
 506:         }
 507:         foreachcell(
 508:             c) if (!(c = Cell::LoadWhich(dis, cell, numcells, textbytes, ics))) return false;
 509:         return true;
 510:     }
 511:     void Formatter(wxString &amp;r, int format, int indent, const wxChar *xml, const wxChar *html,
 512:                    const wxChar *htmlb) {
 513:         if (format == A_EXPXML) {
 514:             r.Append(L&apos; &apos;, indent);
 515:             r.Append(xml);
 516:         } else if (format == A_EXPHTMLT || format == A_EXPHTMLTI || format == A_EXPHTMLTE) {
 517:             r.Append(L&apos; &apos;, indent);
 518:             r.Append(html);
 519:         } else if (format == A_EXPHTMLB &amp;&amp; *htmlb) {
 520:             r.Append(L&apos; &apos;, indent);
 521:             r.Append(htmlb);
 522:         }
 523:     }
 524:     wxString ToText(int indent, const Selection &amp;sel, int format, Document *doc, bool inheritstyle,
 525:                     Cell *root) {
 526:         return ConvertToText(SelectAll(), indent + 2, format, doc, inheritstyle, root);
 527:     };
 528:     wxString ConvertToText(const Selection &amp;sel, int indent, int format, Document *doc,
 529:                            bool inheritstyle, Cell *root) {
 530:         wxString r;
 531:         const int root_grid_spacing = 2;  // Can&apos;t be adjusted in editor, so use a default.
 532:         const int font_size = 14 - indent / 2;
 533:         const int grid_border_width =
 534:             cell == doc-&gt;root ? root_grid_spacing : user_grid_outer_spacing - 1;
 535:         wxString xmlstr(L&quot;&lt;grid&quot;);
 536:         if (folded) xmlstr.Append(wxString::Format(L&quot; folded=\&quot;%d\&quot;&quot;, folded));
 537:         if (bordercolor != g_bordercolor_default) {
 538:             xmlstr.Append(wxString::Format(L&quot; bordercolor=\&quot;0x%06X\&quot;&quot;, bordercolor));
 539:         }
 540:         if (user_grid_outer_spacing != g_usergridouterspacing_default) {
 541:             xmlstr.Append(wxString::Format(L&quot; outerspacing=\&quot;%d\&quot;&quot;, user_grid_outer_spacing));
 542:         }
 543:         xmlstr.Append(L&quot;&gt;\n&quot;);
 544:         Formatter(r, format, indent, xmlstr,
 545:                   wxString::Format(L&quot;&lt;table style=\&quot;border-width: %dpt; font-size: %dpt;\&quot;&gt;\n&quot;,
 546:                                    grid_border_width, font_size)
 547:                       .wc_str(),
 548:                   wxString::Format(L&quot;&lt;ul style=\&quot;font-size: %dpt;\&quot;&gt;\n&quot;, font_size).wc_str());
 549:         foreachcellinsel(c, sel) {
 550:             if (x == sel.x) Formatter(r, format, indent, L&quot;&lt;row&gt;\n&quot;, L&quot;&lt;tr&gt;\n&quot;, L&quot;&quot;);
 551:             r.Append(c-&gt;ToText(indent, sel, format, doc, inheritstyle, root));
 552:             if (format == A_EXPCSV) r.Append(x == sel.x + sel.xs - 1 ? &apos;\n&apos; : &apos;,&apos;);
 553:             if (x == sel.x + sel.xs - 1) Formatter(r, format, indent, L&quot;&lt;/row&gt;\n&quot;, L&quot;&lt;/tr&gt;\n&quot;, L&quot;&quot;);
 554:         }
 555:         Formatter(r, format, indent, L&quot;&lt;/grid&gt;\n&quot;, L&quot;&lt;/table&gt;\n&quot;, L&quot;&lt;/ul&gt;\n&quot;);
 556:         return r;
 557:     }
 558:     void RelSize(int dir, int zoomdepth) { foreachcell(c) c-&gt;RelSize(dir, zoomdepth); }
 559:     void RelSize(int dir, const Selection &amp;sel, int zoomdepth) {
 560:         foreachcellinsel(c, sel) c-&gt;RelSize(dir, zoomdepth);
 561:     }
 562:     void SetBorder(int width, const Selection &amp;sel) {
 563:         foreachcellinsel(c, sel) c-&gt;SetBorder(width);
 564:     }
 565:     int MinRelsize(int rs) {
 566:         foreachcell(c) {
 567:             int crs = c-&gt;MinRelsize();
 568:             rs = min(rs, crs);
 569:         }
 570:         return rs;
 571:     }
 572:     void ResetChildren() {
 573:         cell-&gt;Reset();
 574:         foreachcell(c) c-&gt;ResetChildren();
 575:     }
 576:     void Move(int dx, int dy, const Selection &amp;sel) {
 577:         if (dx &lt; 0 || dy &lt; 0)
 578:             foreachcellinsel(c, sel) swap_(c, C((x + dx + xs) % xs, (y + dy + ys) % ys));
 579:         else
 580:             foreachcellinselrev(c, sel) swap_(c, C((x + dx + xs) % xs, (y + dy + ys) % ys));
 581:     }
 582:     void Add(Cell *c) {
 583:         if (horiz)
 584:             InsertCells(xs, -1, 1, 0, c);
 585:         else
 586:             InsertCells(-1, ys, 0, 1, c);
 587:         c-&gt;parent = cell;
 588:     }
 589:     void MergeWithParent(Grid *p, Selection &amp;sel, Document *doc) {
 590:         cell-&gt;grid = nullptr;
 591:         foreachcell(c) {
 592:             if (x + sel.x &gt;= p-&gt;xs) p-&gt;InsertCells(p-&gt;xs, -1, 1, 0);
 593:             if (y + sel.y &gt;= p-&gt;ys) p-&gt;InsertCells(-1, p-&gt;ys, 0, 1);
 594:             auto pc = p-&gt;C(x + sel.x, y + sel.y);
 595:             if (pc-&gt;HasContent()) {
 596:                 if (x) p-&gt;InsertCells(sel.x + x, -1, 1, 0);
 597:                 pc = p-&gt;C(x + sel.x, y + sel.y);
 598:                 if (pc-&gt;HasContent()) {
 599:                     if (y) p-&gt;InsertCells(-1, sel.y + y, 0, 1);
 600:                     pc = p-&gt;C(x + sel.x, y + sel.y);
 601:                 }
 602:             }
 603:             delete pc;
 604:             p-&gt;C(x + sel.x, y + sel.y) = c;
 605:             c-&gt;parent = p-&gt;cell;
 606:             c = nullptr;
 607:         }
 608:         sel.grid = p;
 609:         sel.xs += xs - 1;
 610:         sel.ys += ys - 1;
 611:         sel.ExitEdit(doc);
 612:         delete this;
 613:     }
 614:     void SetStyle(Document *doc, const Selection &amp;sel, int sb) {
 615:         cell-&gt;AddUndo(doc);
 616:         cell-&gt;ResetChildren();
 617:         foreachcellinsel(c, sel) {
 618:             c-&gt;text.stylebits ^= sb;
 619:             c-&gt;text.WasEdited();
 620:         }
 621:         doc-&gt;canvas-&gt;Refresh();
 622:     }
 623:     void ColorChange(Document *doc, int which, uint color, const Selection &amp;sel) {
 624:         cell-&gt;AddUndo(doc);
 625:         cell-&gt;ResetChildren();
 626:         foreachcellinsel(c, sel) c-&gt;ColorChange(doc, which, color);
 627:         doc-&gt;canvas-&gt;Refresh();
 628:     }
 629:     void ReplaceStr(Document *doc, const wxString &amp;s, const wxString &amp;ls, const Selection &amp;sel) {
 630:         cell-&gt;AddUndo(doc);
 631:         cell-&gt;ResetChildren();
 632:         foreachcellinsel(c, sel) c-&gt;text.ReplaceStr(s, ls);
 633:         doc-&gt;canvas-&gt;Refresh();
 634:     }
 635:     void CSVImport(const wxArrayString &amp;as, wxString sep) {
 636:         int cy = 0;
 637:         loop(y, as.size()) {
 638:             auto s = as[y];
 639:             wxString word;
 640:             for (int x = 0; s[0]; x++) {
 641:                 if (s[0] == &apos;\&quot;&apos;) {
 642:                     word = L&quot;&quot;;
 643:                     for (int i = 1;; i++) {
 644:                         if (!s[i]) {
 645:                             if (y &lt; static_cast&lt;int&gt;(as.size()) - 1) {
 646:                                 s = as[++y];
 647:                                 i = 0;
 648:                             } else {
 649:                                 s = L&quot;&quot;;
 650:                                 break;
 651:                             }
 652:                         } else if (s[i] == &apos;\&quot;&apos;) {
 653:                             if (s[i + 1] == &apos;\&quot;&apos;)
 654:                                 word += s[++i];
 655:                             else {
 656:                                 s = s.size() == i + 1 ? wxString(L&quot;&quot;) : s.Mid(i + 2);
 657:                                 break;
 658:                             }
 659:                         } else
 660:                             word += s[i];
 661:                     }
 662:                 } else {
 663:                     int pos = s.Find(sep);
 664:                     if (pos &lt; 0) {
 665:                         word = s;
 666:                         s = L&quot;&quot;;
 667:                     } else {
 668:                         word = s.Left(pos);
 669:                         s = s.Mid(pos + 1);
 670:                     }
 671:                 }
 672:                 if (x &gt;= xs) InsertCells(x, -1, 1, 0);
 673:                 auto c = C(x, cy);
 674:                 c-&gt;text.t = word;
 675:             }
 676:             cy++;
 677:         }
 678:         ys = cy;  // throws memory away, but doesn&apos;t matter
 679:     }
 680:     unique_ptr&lt;Cell&gt; EvalGridCell(auto &amp;ev, Cell *&amp;c, auto acc, int &amp;x, int &amp;y, bool &amp;alldata,
 681:                                   bool vert) {
 682:         int ct = c-&gt;celltype;  // Type of subcell being evaluated
 683:         // Update alldata condition (variable reads act like data)
 684:         alldata = alldata &amp;&amp; (ct == CT_DATA || ct == CT_VARU);
 685:         ev.vert = vert;  // Inform evaluatour of vert status. (?)
 686:         switch (ct) {
 687:             // Var assign
 688:             case CT_VARD: {
 689:                 if (vert) return acc;  // (Reject vertical assignments)
 690:                 // If we have no data, lets see if we can generate something useful from the
 691:                 // subgrid.
 692:                 if (!acc-&gt;grid &amp;&amp; acc-&gt;text.t.IsEmpty()) {
 693:                     acc = c-&gt;Eval(ev);
 694:                     if (!acc) { return nullptr; }
 695:                 }
 696:                 // Assign the current data temporary to the text
 697:                 ev.Assign(c, acc.get());
 698:                 // Pass the original data onwards
 699:                 return acc;
 700:             }
 701:             // View
 702:             case CT_VIEWV:
 703:             case CT_VIEWH:
 704:                 if (vert ? ct == CT_VIEWH : ct == CT_VIEWV) { return c-&gt;Clone(nullptr); }
 705:                 delete c;
 706:                 c = acc ? acc-&gt;Clone(cell).release() : new Cell(cell);
 707:                 c-&gt;celltype = ct;
 708:                 return acc;
 709:             // Operation
 710:             case CT_CODE: {
 711:                 auto op = ev.FindOp(c-&gt;text.t);
 712:                 switch (op ? strlen(op-&gt;args) : -1) {
 713:                     default: return nullptr;
 714:                     case 0: return ev.Execute(op);
 715:                     case 1: return acc ? ev.Execute(op, std::move(acc)) : nullptr;
 716:                     case 2:
 717:                         if (vert) {
 718:                             if (acc &amp;&amp; y + 1 &lt; ys) {
 719:                                 return ev.Execute(op, std::move(acc), C(x, ++y));
 720:                             } else {
 721:                                 return nullptr;
 722:                             }
 723:                         } else {
 724:                             if (acc &amp;&amp; x + 1 &lt; xs) {
 725:                                 return ev.Execute(op, std::move(acc), C(++x, y));
 726:                             } else {
 727:                                 return nullptr;
 728:                             }
 729:                         }
 730:                     case 3:
 731:                         if (vert) {
 732:                             if (acc &amp;&amp; y + 2 &lt; ys) {
 733:                                 y += 2;
 734:                                 return ev.Execute(op, std::move(acc), C(x, y - 1), C(x, y));
 735:                             } else {
 736:                                 return nullptr;
 737:                             }
 738:                         } else {
 739:                             if (acc &amp;&amp; x + 2 &lt; xs) {
 740:                                 x += 2;
 741:                                 return ev.Execute(op, std::move(acc), C(x - 1, y), C(x, y));
 742:                             } else {
 743:                                 return nullptr;
 744:                             }
 745:                         }
 746:                 }
 747:             }
 748:             // Var read, Data
 749:             default: return c-&gt;Eval(ev);
 750:         }
 751:     }
 752:     unique_ptr&lt;Cell&gt; Eval(auto &amp;ev) {
 753:         unique_ptr&lt;Cell&gt; acc;  // Actual/Accumulating data temporary
 754:         bool alldata = true;   // Is the grid all data?
 755:         // Do left to right processing
 756:         if (xs &gt; 1 || ys == 1) foreachcell(c) {
 757:                 if (x == 0) acc.reset();
 758:                 acc = EvalGridCell(ev, c, std::move(acc), x, y, alldata, false);
 759:             }
 760:         // Do top to bottom processing
 761:         if (ys &gt; 1) foreachcellcolumn(c) {
 762:                 if (y == 0) acc.reset();
 763:                 acc = EvalGridCell(ev, c, std::move(acc), x, y, alldata, true);
 764:             }
 765:         // If all data is true then we can exit now.
 766:         if (alldata) {
 767:             auto result = cell-&gt;Clone(nullptr);  // Potential result if all data.
 768:             foreachcellingrid(c, result-&gt;grid) {
 769:                 auto temp = c-&gt;Eval(ev);
 770:                 DELETEP(c);
 771:                 c = temp.release();
 772:             }
 773:             return result;
 774:         }
 775:         return acc;
 776:     }
 777:     void Split(auto &amp;gs, bool vert) {
 778:         loop(i, vert ? xs : ys) gs.push_back(make_unique&lt;Grid&gt;(vert ? 1 : xs, vert ? ys : 1));
 779:         foreachcell(c) {
 780:             auto g = gs[vert ? x : y].get();
 781:             g-&gt;cells[vert ? y : x] = c-&gt;SetParent(g-&gt;cell);
 782:             c = nullptr;
 783:         }
 784:     }
 785:     unique_ptr&lt;Cell&gt; Sum() {
 786:         double total = 0;
 787:         foreachcell(c) {
 788:             if (c-&gt;HasText()) total += c-&gt;text.GetNum();
 789:         }
 790:         auto c = make_unique&lt;Cell&gt;();
 791:         c-&gt;text.SetNum(total);
 792:         return c;
 793:     }
 794:     void Transpose() {
 795:         auto **tr = new Cell *[xs * ys];
 796:         foreachcell(c) tr[y + x * ys] = c;
 797:         delete[] cells;
 798:         cells = tr;
 799:         swap_(xs, ys);
 800:         SetOrient();
 801:         InitColWidths();
 802:     }
 803:     static int sortfunc(const Cell **a, const Cell **b) {
 804:         loop(i, sys-&gt;sortxs) {
 805:             int off = (i + sys-&gt;sortcolumn) % sys-&gt;sortxs;
 806:             int cmp = (*(a + off))-&gt;text.t.CmpNoCase((*(b + off))-&gt;text.t);
 807:             if (cmp) return sys-&gt;sortdescending ? -cmp : cmp;
 808:         }
 809:         return 0;
 810:     }
 811:     void Sort(Selection &amp;sel, bool descending) {
 812:         sys-&gt;sortcolumn = sel.x;
 813:         sys-&gt;sortxs = xs;
 814:         sys-&gt;sortdescending = descending;
 815:         qsort(cells + sel.y * xs, sel.ys, sizeof(Cell *) * xs,
 816:               (int(__cdecl *)(const void *, const void *))sortfunc);
 817:     }
 818:     Cell *FindExact(const wxString &amp;s) {
 819:         foreachcell(c) {
 820:             auto f = c-&gt;FindExact(s);
 821:             if (f) return f;
 822:         }
 823:         return nullptr;
 824:     }
 825:     Selection HierarchySwap(wxString tag) {
 826:         Cell *selcell = nullptr;
 827:         bool done = false;
 828:     lookformore:
 829:         foreachcell(c) if (c-&gt;grid &amp;&amp; !done) {
 830:             auto f = c-&gt;grid-&gt;FindExact(tag);
 831:             if (f) {
 832:                 // add all parent tags as extra hierarchy inside the cell
 833:                 for (auto p = f-&gt;parent; p != cell; p = p-&gt;parent) {
 834:                     // Special case check: if parents have same name, this would cause infinite
 835:                     // swapping.
 836:                     if (p-&gt;text.t == tag) done = true;
 837:                     auto t = new Cell(f, p);
 838:                     t-&gt;text = p-&gt;text;
 839:                     t-&gt;text.cell = t;
 840:                     t-&gt;grid = f-&gt;grid;
 841:                     if (t-&gt;grid) t-&gt;grid-&gt;ReParent(t);
 842:                     f-&gt;grid = new Grid(1, 1);
 843:                     f-&gt;grid-&gt;cell = f;
 844:                     *f-&gt;grid-&gt;cells = t;
 845:                 }
 846:                 // remove cell from parent, recursively if parent becomes empty
 847:                 for (auto r = f; r &amp;&amp; r != cell; r = r-&gt;parent-&gt;grid-&gt;DeleteTagParent(r, cell, f));
 848:                 // merge newly constructed hierarchy at this level
 849:                 if (!*cells) {
 850:                     *cells = f;
 851:                     f-&gt;parent = cell;
 852:                     selcell = f;
 853:                 } else {
 854:                     MergeTagCell(f, selcell);
 855:                 }
 856:                 goto lookformore;
 857:             }
 858:         }
 859:         ASSERT(selcell);
 860:         return FindCell(selcell);
 861:     }
 862:     void ReParent(auto p) {
 863:         cell = p;
 864:         foreachcell(c) c-&gt;parent = p;
 865:     }
 866:     Cell *DeleteTagParent(Cell *tag, Cell *basecell, Cell *found) {
 867:         ReplaceCell(tag, nullptr);
 868:         if (xs * ys == 1) {
 869:             if (cell != basecell) {
 870:                 cell-&gt;grid = nullptr;
 871:                 delete this;
 872:             }
 873:             auto next = tag-&gt;parent;
 874:             if (tag != found) delete tag;
 875:             return next;
 876:         } else
 877:             foreachcell(c) if (c == nullptr) {
 878:                 if (ys &gt; 1)
 879:                     DeleteCells(-1, y, 0, -1);
 880:                 else
 881:                     DeleteCells(x, -1, -1, 0);
 882:                 return nullptr;
 883:             }
 884:         ASSERT(0);
 885:         return nullptr;
 886:     }
 887:     void MergeTagCell(Cell *f, Cell *&amp;selcell) {
 888:         foreachcell(c) if (c-&gt;text.t == f-&gt;text.t) {
 889:             if (!selcell) selcell = c;
 890:             if (f-&gt;grid) {
 891:                 if (c-&gt;grid) {
 892:                     f-&gt;grid-&gt;MergeTagAll(c);
 893:                 } else {
 894:                     c-&gt;grid = f-&gt;grid;
 895:                     c-&gt;grid-&gt;ReParent(c);
 896:                     f-&gt;grid = nullptr;
 897:                 }
 898:                 delete f;
 899:             }
 900:             return;
 901:         }
 902:         if (!selcell) selcell = f;
 903:         Add(f);
 904:     }
 905:     void MergeTagAll(Cell *into) {
 906:         foreachcell(c) {
 907:             into-&gt;grid-&gt;MergeTagCell(c, into /*dummy*/);
 908:             c = nullptr;
 909:         }
 910:     }
 911:     void SetGridTextLayout(int ds, bool vert, bool noset, const Selection &amp;sel) {
 912:         foreachcellinsel(c, sel) c-&gt;SetGridTextLayout(ds, vert, noset);
 913:     }
 914:     bool IsTable() {
 915:         foreachcell(c) if (c-&gt;grid) return false;
 916:         return true;
 917:     }
 918:     void Hierarchify(Document *doc) {
 919:         loop(y, ys) {
 920:             unique_ptr&lt;Cell&gt; rest;
 921:             if (xs &gt; 1) {
 922:                 Selection s(this, 1, y, xs - 1, 1);
 923:                 rest = CloneSel(s);
 924:             }
 925:             auto c = C(0, y);
 926:             loop(prevy, y) {
 927:                 if (auto prev = C(0, prevy); prev-&gt;text.t == c-&gt;text.t) {
 928:                     if (rest) {
 929:                         ASSERT(prev-&gt;grid);
 930:                         prev-&gt;grid-&gt;MergeRow(rest-&gt;grid);
 931:                         rest.reset();
 932:                     }
 933:                     Selection s(this, 0, y, xs, 1);
 934:                     MultiCellDeleteSub(doc, s);
 935:                     y--;
 936:                     goto done;
 937:                 }
 938:             }
 939:             if (rest) {
 940:                 swap_(c-&gt;grid, rest-&gt;grid);
 941:                 c-&gt;grid-&gt;ReParent(c);
 942:             }
 943:         done:;
 944:         }
 945:         Selection s(this, 1, 0, xs - 1, ys);
 946:         MultiCellDeleteSub(doc, s);
 947:         foreachcell(c) if (c-&gt;grid &amp;&amp; c-&gt;grid-&gt;xs &gt; 1) c-&gt;grid-&gt;Hierarchify(doc);
 948:     }
 949:     void MergeRow(Grid *tm) {
 950:         ASSERT(xs == tm-&gt;xs &amp;&amp; tm-&gt;ys == 1);
 951:         InsertCells(-1, ys, 0, 1, nullptr);
 952:         loop(x, xs) {
 953:             swap_(C(x, ys - 1), tm-&gt;C(x, 0));
 954:             C(x, ys - 1)-&gt;parent = cell;
 955:         }
 956:     }
 957:     void MaxDepthLeaves(int curdepth, int &amp;maxdepth, int &amp;leaves) {
 958:         foreachcell(c) c-&gt;MaxDepthLeaves(curdepth, maxdepth, leaves);
 959:     }
 960:     int Flatten(int curdepth, int cury, Grid *g) {
 961:         foreachcell(c) if (c-&gt;grid) { cury = c-&gt;grid-&gt;Flatten(curdepth + 1, cury, g); }
 962:         else {
 963:             auto ic = c;
 964:             for (int i = curdepth; i &gt;= 0; i--) {
 965:                 auto dest = g-&gt;C(i, cury);
 966:                 dest-&gt;text = ic-&gt;text;
 967:                 dest-&gt;text.cell = dest;
 968:                 ic = ic-&gt;parent;
 969:             }
 970:             cury++;
 971:         }
 972:         return cury;
 973:     }
 974:     void ResizeColWidths(int dir, const Selection &amp;sel, bool hierarchical) {
 975:         for (int x = sel.x; x &lt; sel.x + sel.xs; x++) {
 976:             colwidths[x] += dir * 5;
 977:             if (colwidths[x] &lt; 5) colwidths[x] = 5;
 978:             loop(y, ys) {
 979:                 auto c = C(x, y);
 980:                 if (c-&gt;grid &amp;&amp; hierarchical)
 981:                     c-&gt;grid-&gt;ResizeColWidths(dir, c-&gt;grid-&gt;SelectAll(), hierarchical);
 982:             }
 983:         }
 984:     }
 985:     int GetColWidth(Cell *ct) {
 986:         foreachcell(c) {
 987:             if (c == ct) return colwidths[x];
 988:         }
 989:         return 0;
 990:     }
 991:     void SetColWidth(Cell *ct, int w) {
 992:         foreachcell(c) {
 993:             if (c == ct) {
 994:                 colwidths[x] = w;
 995:                 return;
 996:             }
 997:         }
 998:     }
 999:     void CollectCells(auto &amp;itercells) { foreachcell(c) c-&gt;CollectCells(itercells); }
1000:     void CollectCellsSel(auto &amp;itercells, const Selection &amp;sel, bool recurse) {
1001:         foreachcellinsel(c, sel) c-&gt;CollectCells(itercells, recurse);
1002:     }
1003:     void SetStyles(const Selection &amp;sel, Cell *o) {
1004:         foreachcellinsel(c, sel) {
1005:             c-&gt;cellcolor = o-&gt;cellcolor;
1006:             c-&gt;textcolor = o-&gt;textcolor;
1007:             c-&gt;text.stylebits = o-&gt;text.stylebits;
1008:             c-&gt;text.image = o-&gt;text.image;
1009:         }
1010:     }
1011:     void ClearImages(const Selection &amp;sel) { foreachcellinsel(c, sel) c-&gt;text.image = nullptr; }
1012: };</file><file path="src/image.h"> 1: struct Image {
 2:     vector&lt;uint8_t&gt; data;
 3:     char type;
 4:     wxBitmap bm_display;
 5:     int trefc {0};
 6:     int savedindex {-1};
 7:     uint64_t hash {0};
 8:     // This indicates a relative scale, where 1.0 means bitmap pixels match display pixels on
 9:     // a low res 96 dpi display. On a high dpi screen it will look scaled up. Higher values
10:     // look better on most screens.
11:     // This is all relative to GetContentScalingFactor.
12:     double display_scale;
13:     int pixel_width {0};
14:     Image(auto _hash, auto _sc, auto &amp;&amp;_data, auto _type)
15:         : hash(_hash), display_scale(_sc), data(std::move(_data)), type(_type) {}
16:     void ImageRescale(double scale) {
17:         auto &amp;[it, mime] = imagetypes.at(type);
18:         auto im = ConvertBufferToWxImage(data, it);
19:         im.Rescale(im.GetWidth() * scale, im.GetHeight() * scale);
20:         data = ConvertWxImageToBuffer(im, it);
21:         hash = CalculateHash(data);
22:         bm_display = wxNullBitmap;
23:     }
24:     void DisplayScale(double scale) {
25:         display_scale /= scale;
26:         bm_display = wxNullBitmap;
27:     }
28:     void ResetScale(double scale) {
29:         display_scale = scale;
30:         bm_display = wxNullBitmap;
31:     }
32:     wxBitmap &amp;Display() {
33:         // This might run in multiple threads in parallel
34:         // so this function must not touch any global resources
35:         // and callees must be thread-safe.
36:         if (!bm_display.IsOk()) {
37:             auto &amp;[it, mime] = imagetypes.at(type);
38:             auto bm = ConvertBufferToWxBitmap(data, it);
39:             pixel_width = bm.GetWidth();
40:             ScaleBitmap(bm, sys-&gt;frame-&gt;FromDIP(1.0) / display_scale, bm_display);
41:         }
42:         return bm_display;
43:     }
44:     bool ExportToDirectory(const wxString &amp;directory) {
45:         wxString targetname = directory + wxString::Format(&quot;%llu&quot;, hash) + GetFileExtension();
46:         wxFFileOutputStream os(targetname, L&quot;w+b&quot;);
47:         if (!os.IsOk()) {
48:             wxMessageBox(_(L&quot;Error writing image file!&quot;), targetname.wx_str(), wxOK, sys-&gt;frame);
49:             return false;
50:         }
51:         os.Write(data.data(), data.size());
52:         return true;
53:     }
54:     const wxChar *GetFileExtension() {
55:         switch (type) {
56:             case &apos;J&apos;: return L&quot;.jpg&quot;;
57:             case &apos;I&apos;:
58:             default: return L&quot;.png&quot;;
59:         }
60:     }
61: };</file><file path="src/lobster_impl.cpp">  1: #include &quot;lobster/stdafx.h&quot;
  2: #include &quot;script_interface.h&quot;
  3: #include &quot;lobster/compiler.h&quot;
  4: using namespace lobster;
  5: namespace script {
  6: ScriptInterface *si = nullptr;
  7: void AddTreeSheets(NativeRegistry &amp;nfr) {
  8: nfr(&quot;goto_root&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,
  9:     &quot;makes the root of the document the current cell. this is the default at the start &quot;
 10:     &quot;of any script, so this function is only needed to return there.&quot;,
 11:     [](StackPtr &amp;, VM &amp;) {
 12:         si-&gt;GoToRoot();
 13:         return NilVal();
 14:     });
 15: nfr(&quot;goto_view&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;makes what the user has zoomed into the current cell&quot;,
 16:     [](StackPtr &amp;, VM &amp;) {
 17:         si-&gt;GoToView();
 18:         return NilVal();
 19:     });
 20: nfr(&quot;has_selection&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;whether there is a selection&quot;,
 21:     [](StackPtr &amp;, VM &amp;) { return Value(si-&gt;HasSelection()); });
 22: nfr(&quot;goto_selection&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;,
 23:     &quot;makes the current cell the one selected, or the first of a selection&quot;,
 24:     [](StackPtr &amp;, VM &amp;) {
 25:         si-&gt;GoToSelection();
 26:         return NilVal();
 27:     });
 28: nfr(&quot;has_parent&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;whether the current cell has a parent (is the root cell)&quot;,
 29:     [](StackPtr &amp;, VM &amp;) { return Value(si-&gt;HasParent()); });
 30: nfr(&quot;goto_parent&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;makes the current cell the parent of the current cell, if any&quot;,
 31:     [](StackPtr &amp;, VM &amp;) {
 32:         si-&gt;GoToParent();
 33:         return NilVal();
 34:     });
 35: nfr(&quot;num_children&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;,
 36:     &quot;returns the total number of children of the current cell (rows * columns). &quot;
 37:     &quot;returns 0 if this cell doesn&apos;t have a sub-grid at all.&quot;,
 38:     [](StackPtr &amp;, VM &amp;) { return Value(si-&gt;NumChildren()); });
 39: nfr(&quot;num_columns_rows&quot;, &quot;&quot;, &quot;&quot;, &quot;I}:2&quot;,
 40:     &quot;returns the number of columns and rows in the current cell&quot;,
 41:     [](StackPtr &amp;sp, VM &amp;) { PushVec(sp, int2(si-&gt;NumColumnsRows())); });
 42: nfr(&quot;selection&quot;, &quot;&quot;, &quot;&quot;, &quot;I}:2I}:2&quot;,
 43:     &quot;returns the (xs,ys) and (x,y) of the current selection, or zeroes if none&quot;,
 44:     [](StackPtr &amp;sp, VM &amp;) {
 45:         auto b = si-&gt;SelectionBox();
 46:         PushVec(sp, int2(b.second));
 47:         PushVec(sp, int2(b.first));
 48:     });
 49: nfr(&quot;goto_child&quot;, &quot;n&quot;, &quot;I&quot;, &quot;&quot;, &quot;makes the current cell the nth child of the current cell&quot;,
 50:     [](StackPtr &amp;, VM &amp;, Value n) {
 51:         si-&gt;GoToChild(n.intval());
 52:         return NilVal();
 53:     });
 54: nfr(&quot;goto_column_row&quot;, &quot;col,row&quot;, &quot;II&quot;, &quot;&quot;, &quot;makes the current cell the child at col / row&quot;,
 55:     [](StackPtr &amp;, VM &amp;, Value x, Value y) {
 56:         si-&gt;GoToColumnRow(x.intval(), y.intval());
 57:         return NilVal();
 58:     });
 59: nfr(&quot;get_text&quot;, &quot;&quot;, &quot;&quot;, &quot;S&quot;, &quot;gets the text of the current cell.&quot;,
 60:     [](StackPtr &amp;, VM &amp;vm) { return Value(vm.NewString(si-&gt;GetText())); });
 61: nfr(&quot;set_text&quot;, &quot;text&quot;, &quot;S&quot;, &quot;&quot;, &quot;sets the text of the current cell&quot;,
 62:     [](StackPtr &amp;, VM &amp;, Value s) {
 63:         si-&gt;SetText(s.sval()-&gt;strv());
 64:         return NilVal();
 65:     });
 66: nfr(&quot;create_grid&quot;, &quot;cols,rows&quot;, &quot;II&quot;, &quot;&quot;,
 67:     &quot;creates a grid in the current cell if there is not one yet&quot;,
 68:     [](StackPtr &amp;, VM &amp;, Value x, Value y) {
 69:         si-&gt;CreateGrid(x.intval(), y.intval());
 70:         return NilVal();
 71:     });
 72: nfr(&quot;insert_column&quot;, &quot;c&quot;, &quot;I&quot;, &quot;&quot;, &quot;inserts a column before column c in an existing grid&quot;,
 73:     [](StackPtr &amp;, VM &amp;, Value x) {
 74:         si-&gt;InsertColumn(x.intval());
 75:         return NilVal();
 76:     });
 77: nfr(&quot;insert_row&quot;, &quot;r&quot;, &quot;I&quot;, &quot;&quot;, &quot;inserts a row before row r in an existing grid&quot;,
 78:     [](StackPtr &amp;, VM &amp;, Value x) {
 79:         si-&gt;InsertRow(x.intval());
 80:         return NilVal();
 81:     });
 82: nfr(&quot;delete&quot;, &quot;position,size&quot;, &quot;I}:2I}:2&quot;, &quot;&quot;,
 83:     &quot;clears the cells denoted by position/size. also removes columns/rows if they become &quot;
 84:     &quot;completely empty, or the entire grid.&quot;,
 85:     [](StackPtr &amp;sp, VM &amp;) {
 86:         auto s = PopVec&lt;int2&gt;(sp);
 87:         auto p = PopVec&lt;int2&gt;(sp);
 88:         si-&gt;Delete(p.x, p.y, s.x, s.y);
 89:     });
 90: nfr(&quot;set_background_color&quot;, &quot;color&quot;, &quot;F}:4&quot;, &quot;&quot;, &quot;sets the background color of the current cell&quot;,
 91:     [](StackPtr &amp;sp, VM &amp;) {
 92:         auto col = PopVec&lt;float3&gt;(sp);
 93:         si-&gt;SetBackgroundColor(*(uint32_t *)quantizec(col, 0.0f).data());
 94:     });
 95: nfr(&quot;set_text_color&quot;, &quot;color&quot;, &quot;F}:4&quot;, &quot;&quot;, &quot;sets the text color of the current cell&quot;,
 96:     [](StackPtr &amp;sp, VM &amp;) {
 97:         auto col = PopVec&lt;float3&gt;(sp);
 98:         si-&gt;SetTextColor(*(uint32_t *)quantizec(col, 0.0f).data());
 99:     });
100: nfr(&quot;set_text_filtered&quot;, &quot;filtered&quot;, &quot;B&quot;, &quot;&quot;, &quot;sets the text filtered of the current cell&quot;,
101:     [](StackPtr &amp;, VM &amp;, Value filtered) {
102:         si-&gt;SetTextFiltered(filtered.True());
103:         return NilVal();
104:     });
105: nfr(&quot;is_text_filtered&quot;, &quot;&quot;, &quot;&quot;, &quot;B&quot;, &quot;whether the text of the current cell is filtered&quot;,
106:     [](StackPtr &amp;, VM &amp;) { return Value(si-&gt;IsTextFiltered()); });
107: nfr(&quot;set_border_color&quot;, &quot;color&quot;, &quot;F}:4&quot;, &quot;&quot;, &quot;sets the border color of the current grid&quot;,
108:     [](StackPtr &amp;sp, VM &amp;) {
109:         auto col = PopVec&lt;float3&gt;(sp);
110:         si-&gt;SetBorderColor(*(uint32_t *)quantizec(col, 0.0f).data());
111:     });
112: nfr(&quot;get_relative_size&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;returns the relative text size of the current cell&quot;,
113:     [](StackPtr &amp;, VM &amp;) { return Value(si-&gt;GetRelativeSize()); });
114: nfr(&quot;set_relative_size&quot;, &quot;size&quot;, &quot;I&quot;, &quot;&quot;,
115:     &quot;sets the relative size (0 is normal, -1 is smaller etc.) of the current cell&quot;,
116:     [](StackPtr &amp;, VM &amp;, Value s) {
117:         si-&gt;SetRelativeSize(geom::clamp(s.intval(), -10, 10));
118:         return NilVal();
119:     });
120: nfr(&quot;set_style_bits&quot;, &quot;stylebits&quot;, &quot;I&quot;, &quot;&quot;,
121:     &quot;sets one or more styles (bold = 1, italic = 2, fixed = 4, underline = 8,&quot;
122:     &quot; strikethru = 16) on the current cell&quot;,
123:     [](StackPtr &amp;, VM &amp;, Value s) {
124:         si-&gt;SetStyle(s.intval());
125:         return NilVal();
126:     });
127: nfr(&quot;get_style_bits&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;returns the stylebits of the current cell&quot;,
128:     [](StackPtr &amp;, VM &amp;) { return Value(si-&gt;GetStyle()); });
129: nfr(&quot;set_status_message&quot;, &quot;message&quot;, &quot;S&quot;, &quot;&quot;, &quot;sets the status message in TreeSheets&quot;,
130:     [](StackPtr &amp;, VM &amp;, Value s) {
131:         si-&gt;SetStatusMessage(s.sval()-&gt;strv());
132:         return NilVal();
133:     });
134: nfr(&quot;get_filename_from_user&quot;, &quot;is_save&quot;, &quot;I&quot;, &quot;S&quot;,
135:     &quot;gets a filename using a file dialog. empty string if cancelled.&quot;,
136:     [](StackPtr &amp;, VM &amp;vm, Value is_save) {
137:         return Value(vm.NewString(si-&gt;GetFileNameFromUser(is_save.True())));
138:     });
139: nfr(&quot;get_filename&quot;, &quot;&quot;, &quot;&quot;, &quot;S&quot;, &quot;gets the current documents file name&quot;,
140:     [](StackPtr &amp;, VM &amp;vm) { return Value(vm.NewString(si-&gt;GetFileName())); });
141: nfr(&quot;load_document&quot;, &quot;filename&quot;, &quot;S&quot;, &quot;B&quot;,
142:     &quot;loads a document, and makes it the active one. returns false if failed.&quot;,
143:     [](StackPtr &amp;, VM &amp;, Value filename) {
144:         return Value(si-&gt;LoadDocument(filename.sval()-&gt;data()));
145:     });
146: nfr(&quot;set_window_size&quot;, &quot;width,height&quot;, &quot;II&quot;, &quot;&quot;, &quot;resizes the window&quot;,
147:     [](StackPtr &amp;, VM &amp;, Value w, Value h) {
148:         si-&gt;SetWindowSize(w.intval(), h.intval());
149:         return NilVal();
150:     });
151: nfr(&quot;get_last_edit&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;,
152:     &quot;gets the timestamp of the last edit in milliseconds since the Unix/C epoch&quot;,
153:     [](StackPtr &amp;, VM &amp;) { return Value(si-&gt;GetLastEdit()); });
154: nfr(&quot;get_current_time&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;,
155:     &quot;gets the current timestamp in milliseconds since the Unix/C epoch&quot;, [](StackPtr &amp;, VM &amp;) {
156:         auto now = std::chrono::system_clock::now();
157:         auto duration = now.time_since_epoch();
158:         auto milliseconds = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count();
159:         return Value(milliseconds);
160:     });
161: nfr(&quot;is_tag&quot;, &quot;&quot;, &quot;&quot;, &quot;B&quot;, &quot;whether the current cell text is a tag&quot;,
162:     [](StackPtr &amp;, VM &amp;) {
163:         return Value(si-&gt;IsTag());
164:     });
165: nfr(&quot;get_column_width&quot;, &quot;&quot;, &quot;&quot;, &quot;I&quot;, &quot;get the column width of the current cell&quot;,
166:     [](StackPtr &amp;, VM &amp;) {
167:         return Value(si-&gt;GetColWidth());
168:     });
169: nfr(&quot;set_column_width&quot;, &quot;width&quot;, &quot;I&quot;, &quot;&quot;, &quot;set the column width of the current cell&quot;,
170:     [](StackPtr &amp;, VM &amp;, Value w) {
171:         si-&gt;SetColWidth(w.intval());
172:         return NilVal();
173:     });
174: }
175: NativeRegistry natreg;  // FIXME: global.
176: string InitLobster(ScriptInterface *_si, const char *exefilepath, const char *auxfilepath,
177:                    bool from_bundle, FileLoader sl) {
178:     si = _si;
179:     min_output_level = OUTPUT_PROGRAM;
180:     string err;
181:     try {
182:         InitPlatform(exefilepath, auxfilepath, from_bundle, sl);
183:         RegisterBuiltin(natreg, &quot;ts&quot;, &quot;treesheets&quot;, AddTreeSheets);
184:         RegisterCoreLanguageBuiltins(natreg);
185:     } catch (string &amp;s) { err = s; }
186:     return err;
187: }
188: string RunLobster(std::string_view filename, std::string_view code, bool dump_builtins) {
189:     string err;
190:     try {
191:         string bytecode;
192:         string codegen;
193:         Compile(natreg, filename, code, bytecode, nullptr, nullptr, false, RUNTIME_ASSERT, nullptr,
194:                 1, false, true, codegen, false, filename);
195:         auto ret = RunTCC(natreg, bytecode, filename, nullptr, {}, false, err, RUNTIME_ASSERT, true,
196:                           false, codegen);
197:     } catch (string &amp;s) {
198:         err = s;
199:     }
200:     return err;
201: }
202: void TSDumpBuiltinDoc() { DumpBuiltinDoc(natreg, true); }
203: }  // namespace script
204: namespace lobster {
205: FileLoader EnginePreInit(NativeRegistry &amp;nfr) {
206:     // nfr.DoneRegistering();
207:     return DefaultLoadFile;
208: }
209: }  // namespace lobster
210: extern &quot;C&quot; void GLFrame(StackPtr, VM &amp;) {}
211: string BreakPoint(lobster::VM &amp;vm, string_view reason) { return {}; }</file><file path="src/main.cpp">  1: #include &quot;stdafx.h&quot;
  2: static const auto TS_VERSION = 24;
  3: static const auto g_grid_margin = 1;
  4: static const auto g_cell_margin = 2;
  5: static const auto g_margin_extra = 2;  // TODO, could make this configurable: 0/2/4/6
  6: static const auto g_usergridouterspacing_default = 3;
  7: static const auto g_line_width = 1;
  8: static const auto g_selmargin = 2;
  9: static const auto g_scrollratecursor = 240;  // FIXME: must be configurable
 10: static const auto g_scrollratewheel = 2;  // relative to 1 step on a fixed wheel usually being 120
 11: static const auto g_max_launches = 20;
 12: static const auto g_deftextsize_default = 12;
 13: static const auto g_mintextsize_delta = 8;
 14: static const auto g_maxtextsize_delta = 32;
 15: static const auto BLINK_TIME = 400;
 16: static const auto CUSTOMCOLORIDX = 0;
 17: static const auto TS_SELECTION_MASK = 0x80;
 18: static const auto g_bordercolor_default = 0xA0A0A0;
 19: static const auto g_cellcolor_default = 0xFFFFFFU;
 20: static const auto g_textcolor_default = 0x000000U;
 21: static const auto g_tagcolor_default = 0xFF0000;
 22: static const std::array&lt;uint, 42&gt; celltextcolors = {
 23:     0xFFFFFF,  // CUSTOM COLOR!
 24:     0xFFFFFF, 0x000000, 0x202020, 0x404040, 0x606060, 0x808080, 0xA0A0A0, 0xC0C0C0, 0xD0D0D0,
 25:     0xE0E0E0, 0xE8E8E8, 0x000080, 0x0000FF, 0x8080FF, 0xC0C0FF, 0xC0C0E0, 0x008000, 0x00FF00,
 26:     0x80FF80, 0xC0FFC0, 0xC0E0C0, 0x800000, 0xFF0000, 0xFF8080, 0xFFC0C0, 0xE0C0C0, 0x800080,
 27:     0xFF00FF, 0xFF80FF, 0xFFC0FF, 0xE0C0E0, 0x008080, 0x00FFFF, 0x80FFFF, 0xC0FFFF, 0xC0E0E0,
 28:     0x808000, 0xFFFF00, 0xFFFF80, 0xFFFFC0, 0xE0E0C0,
 29: };
 30: static const std::map&lt;char, pair&lt;wxBitmapType, wxString&gt;&gt; imagetypes = {
 31:     {&apos;I&apos;, {wxBITMAP_TYPE_PNG, &quot;image/png&quot;}}, {&apos;J&apos;, {wxBITMAP_TYPE_JPEG, &quot;image/jpeg&quot;}}};
 32: static auto g_deftextsize = g_deftextsize_default;
 33: static int g_mintextsize() { return g_deftextsize - g_mintextsize_delta; }
 34: static int g_maxtextsize() { return g_deftextsize + g_maxtextsize_delta; }
 35: enum { TS_TEXT = 0, TS_GRID = 1, TS_BOTH = 2, TS_NEITHER = 3 };
 36: enum {
 37:     A_SAVEALL = 500,
 38:     A_COLLAPSE,
 39:     A_NEWGRID,
 40:     A_CLRVIEW,
 41:     A_MARKDATA,
 42:     A_MARKVIEWH,
 43:     A_MARKVIEWV,
 44:     A_MARKCODE,
 45:     A_IMAGE,
 46:     A_EXPIMAGE,
 47:     A_EXPXML,
 48:     A_EXPHTMLT,
 49:     A_EXPHTMLTI,
 50:     A_EXPHTMLTE,
 51:     A_EXPHTMLO,
 52:     A_EXPHTMLB,
 53:     A_EXPTEXT,
 54:     A_ZOOMIN,
 55:     A_ZOOMOUT,
 56:     A_TRANSPOSE,
 57:     A_DELETE,
 58:     A_BACKSPACE,
 59:     A_DELETE_WORD,
 60:     A_BACKSPACE_WORD,
 61:     A_LEFT,
 62:     A_RIGHT,
 63:     A_UP,
 64:     A_DOWN,
 65:     A_MLEFT,
 66:     A_MRIGHT,
 67:     A_MUP,
 68:     A_MDOWN,
 69:     A_SLEFT,
 70:     A_SRIGHT,
 71:     A_SUP,
 72:     A_SDOWN,
 73:     A_ALEFT,
 74:     A_ARIGHT,
 75:     A_AUP,
 76:     A_ADOWN,
 77:     A_SCLEFT,
 78:     A_SCRIGHT,
 79:     A_SCUP,
 80:     A_SCDOWN,
 81:     A_IMPXML,
 82:     A_IMPXMLA,
 83:     A_IMPTXTI,
 84:     A_IMPTXTC,
 85:     A_IMPTXTS,
 86:     A_IMPTXTT,
 87:     A_TUTORIALWEBPAGE,
 88:     #ifdef ENABLE_LOBSTER
 89:         A_SCRIPTREFERENCE,
 90:     #endif
 91:     A_MARKVARD,
 92:     A_MARKVARU,
 93:     A_SHOWSBAR,
 94:     A_SHOWTBAR,
 95:     A_LEFTTABS,
 96:     A_TRADSCROLL,
 97:     A_HOME,
 98:     A_END,
 99:     A_CHOME,
100:     A_CEND,
101:     A_PAGESETUP,
102:     A_PRINTSCALE,
103:     A_NEXT,
104:     A_PREV,
105:     A_TT,
106:     A_SEARCH,
107:     A_CASESENSITIVESEARCH,
108:     A_CLEARSEARCH,
109:     A_CLEARREPLACE,
110:     A_REPLACE,
111:     A_REPLACEONCE,
112:     A_REPLACEONCEJ,
113:     A_REPLACEALL,
114:     A_CANCELEDIT,
115:     A_BROWSE,
116:     A_ENTERCELL,
117:     A_ENTERCELL_JUMPTOSTART,
118:     A_ENTERCELL_JUMPTOEND,
119:     A_PROGRESSCELL,  // see
120:                      // https://github.com/aardappel/treesheets/issues/139#issuecomment-544167524
121:     A_CELLCOLOR,
122:     A_TEXTCOLOR,
123:     A_BORDCOLOR,
124:     A_INCSIZE,
125:     A_DECSIZE,
126:     A_INCWIDTH,
127:     A_DECWIDTH,
128:     A_ENTERGRID,
129:     A_LINK,
130:     A_LINKREV,
131:     A_LINKIMG,
132:     A_LINKIMGREV,
133:     A_SEARCHNEXT,
134:     A_SEARCHPREV,
135:     A_CUSTCOL,
136:     A_COLCELL,
137:     A_SORT,
138:     A_MAKEBAKS,
139:     A_TOTRAY,
140:     A_AUTOSAVE,
141:     A_FULLSCREEN,
142:     A_SCALED,
143:     A_SCOLS,
144:     A_SROWS,
145:     A_SHOME,
146:     A_SEND,
147:     A_BORD0,
148:     A_BORD1,
149:     A_BORD2,
150:     A_BORD3,
151:     A_BORD4,
152:     A_BORD5,
153:     A_HSWAP,
154:     A_TEXTGRID,
155:     A_TAGADD,
156:     A_TAGREMOVE,
157:     A_WRAP,
158:     A_HIFY,
159:     A_FLATTEN,
160:     A_BROWSEF,
161:     A_ROUND0,
162:     A_ROUND1,
163:     A_ROUND2,
164:     A_ROUND3,
165:     A_ROUND4,
166:     A_ROUND5,
167:     A_ROUND6,
168:     A_FILTER5,
169:     A_FILTER10,
170:     A_FILTER20,
171:     A_FILTER50,
172:     A_FILTERM,
173:     A_FILTERL,
174:     A_FILTERS,
175:     A_FILTEROFF,
176:     A_FILTERBYCELLBG,
177:     A_FILTERMATCHNEXT,
178:     A_FILTERRANGE,
179:     A_FILTERDIALOG,
180:     A_FASTRENDER,
181:     A_INVERTRENDER,
182:     A_EXPCSV,
183:     A_PASTESTYLE,
184:     A_PREVFILE,
185:     A_NEXTFILE,
186:     A_IMAGER,
187:     A_INCWIDTHNH,
188:     A_DECWIDTHNH,
189:     A_ZOOMSCR,
190:     A_V_GS,
191:     A_V_BS,
192:     A_V_LS,
193:     A_H_GS,
194:     A_H_BS,
195:     A_H_LS,
196:     A_GS,
197:     A_BS,
198:     A_LS,
199:     A_RESETSIZE,
200:     A_RESETWIDTH,
201:     A_RESETSTYLE,
202:     A_RESETCOLOR,
203:     A_LASTCELLCOLOR,
204:     A_LASTTEXTCOLOR,
205:     A_LASTBORDCOLOR,
206:     A_LASTIMAGE,
207:     A_OPENCELLCOLOR,
208:     A_OPENTEXTCOLOR,
209:     A_OPENBORDCOLOR,
210:     A_OPENIMGDROPDOWN,
211:     A_DDIMAGE,
212:     A_MINCLOSE,
213:     A_SINGLETRAY,
214:     A_CENTERED,
215:     A_SORTD,
216:     A_FOLD,
217:     A_FOLDALL,
218:     A_UNFOLDALL,
219:     A_IMAGESCP,
220:     A_IMAGESCW,
221:     A_IMAGESCF,
222:     A_IMAGESCN,
223:     A_IMAGESVA,
224:     A_SAVE_AS_JPEG,
225:     A_SAVE_AS_PNG,
226:     A_HELP_OP_REF,
227:     A_FSWATCH,
228:     A_DEFBGCOL,
229:     A_DEFCURCOL,
230:     A_RESETPERSPECTIVE,
231:     A_THINSELC,
232:     A_COPYCT,
233:     A_COPYBM,
234:     A_COPYWI,
235:     A_MINISIZE,
236:     A_CUSTKEY,
237:     A_SETLANG,
238:     A_AUTOEXPORT_HTML_NONE,
239:     A_AUTOEXPORT_HTML_WITH_IMAGES,
240:     A_AUTOEXPORT_HTML_WITHOUT_IMAGES,
241:     A_DRAGANDDROP,
242:     A_DEFAULTMAXCOLWIDTH,
243:     #ifdef ENABLE_LOBSTER
244:         A_ADDSCRIPT,
245:         A_DETSCRIPT,
246:     #endif
247:     A_SET_FIXED_FONT,
248:     A_NOP,
249:     A_TAGSET = 1000,  // and all values from here on
250:     #ifdef ENABLE_LOBSTER
251:         A_SCRIPT = 2000,  // and all values from here on
252:     #endif
253:     A_MAXACTION = 3000
254: };
255: enum {
256:     STYLE_BOLD = 1,
257:     STYLE_ITALIC = 2,
258:     STYLE_FIXED = 4,
259:     STYLE_UNDERLINE = 8,
260:     STYLE_STRIKETHRU = 16
261: };
262: enum { TEXT_SPACE = 3, TEXT_SEP = 2, TEXT_CHAR = 1 };
263: #ifdef ENABLE_LOBSTER
264:     // script_interface.h is both used by TreeSheets and lobster-impl
265:     // and uses data types that are already defined by lobster.
266:     // Define these data types separately on the TreeSheets side here
267:     // to avoid redefinitions.
268:     struct string_view_nt {
269:         string_view sv;
270:         string_view_nt(const string &amp;s) : sv(s) {}
271:         explicit string_view_nt(const char *s) : sv(s) {}
272:         explicit string_view_nt(string_view osv) : sv(osv) { check_null_terminated(); }
273:         void check_null_terminated() const { assert(!sv.data()[sv.size()]); }
274:         size_t size() const { return sv.size(); }
275:         const char *data() const { return sv.data(); }
276:         const char *c_str() const {
277:             check_null_terminated();  // Catch appends to parent buffer since construction.
278:             return sv.data();
279:         }
280:     };
281:     using FileLoader = int64_t (*)(string_view_nt absfilename, std::string *dest, int64_t start,
282:                                    int64_t len);
283:     #include &quot;script_interface.h&quot;
284:     using namespace script;
285: #endif
286: struct treesheets {
287:     #ifdef ENABLE_LOBSTER
288:         struct TreeSheetsScriptImpl;
289:     #endif
290:     struct Image;
291:     struct Text;
292:     struct Cell;
293:     struct Grid;
294:     struct Selection;
295:     struct Document;
296:     struct Evaluator;
297:     struct System;
298:     struct TSCanvas;
299:     struct TSFrame;
300:     struct TSApp;
301:     static System *sys;
302:     #ifdef ENABLE_LOBSTER
303:         #include &quot;treesheets_impl.h&quot;
304:     #endif
305:     #include &quot;image.h&quot;
306:     #include &quot;text.h&quot;
307:     #include &quot;cell.h&quot;
308:     #include &quot;grid.h&quot;
309:     #include &quot;selection.h&quot;
310:     #include &quot;document.h&quot;
311:     #include &quot;evaluator.h&quot;
312:     #include &quot;system.h&quot;
313:     #include &quot;wxtools.h&quot;
314:     #include &quot;tscanvas.h&quot;
315:     #include &quot;tsframe.h&quot;
316:     #include &quot;tsapp.h&quot;
317: };
318: treesheets::System *treesheets::sys = nullptr;
319: #ifdef ENABLE_LOBSTER
320:     treesheets::TreeSheetsScriptImpl treesheets::tssi;
321: #endif
322: IMPLEMENT_APP(treesheets::TSApp)
323: #include &quot;events.h&quot;</file><file path="src/pot_update.sh">1: #!/bin/sh
2: xgettext -j --keyword=_ --sort-output --no-location -o ../TS/translations/ts.pot tsframe.h document.h system.h wxtools.h</file><file path="src/script_interface.h"> 1: namespace script {
 2: typedef std::pair&lt;int, int&gt; icoord;
 3: typedef std::pair&lt;icoord, icoord&gt; ibox;
 4: struct ScriptInterface {
 5:     virtual bool LoadDocument(const char *filename) = 0;
 6:     virtual void GoToRoot() = 0;
 7:     virtual void GoToView() = 0;
 8:     virtual bool HasSelection() = 0;
 9:     virtual void GoToSelection() = 0;
10:     virtual bool HasParent() = 0;
11:     virtual void GoToParent() = 0;
12:     virtual int NumChildren() = 0;
13:     virtual icoord NumColumnsRows() = 0;
14:     virtual ibox SelectionBox() = 0;
15:     virtual void GoToChild(int n) = 0;
16:     virtual void GoToColumnRow(int x, int y) = 0;
17:     virtual std::string GetText() = 0;
18:     virtual void SetText(std::string_view t) = 0;
19:     virtual void CreateGrid(int x, int n) = 0;
20:     virtual void InsertColumn(int x) = 0;
21:     virtual void InsertRow(int y) = 0;
22:     virtual void Delete(int x, int y, int xs, int ys) = 0;
23:     virtual void SetBackgroundColor(uint32_t col) = 0;
24:     virtual void SetTextColor(uint32_t col) = 0;
25:     virtual void SetTextFiltered(bool filtered) = 0;
26:     virtual bool IsTextFiltered() = 0;
27:     virtual void SetBorderColor(uint32_t col) = 0;
28:     virtual int GetRelativeSize() = 0;
29:     virtual void SetRelativeSize(int s) = 0;
30:     virtual void SetStyle(int s) = 0;
31:     virtual int GetStyle() = 0;
32:     virtual int GetColWidth() = 0;
33:     virtual void SetColWidth(int w) = 0;
34:     virtual void SetStatusMessage(std::string_view message) = 0;
35:     virtual void SetWindowSize(int width, int height) = 0;
36:     virtual std::string GetFileNameFromUser(bool is_save) = 0;
37:     virtual std::string GetFileName() = 0;
38:     virtual int64_t GetLastEdit() = 0;
39:     virtual bool IsTag() = 0;
40:     virtual ~ScriptInterface() {};
41: };
42: extern std::string InitLobster(ScriptInterface *_si, const char *exefilepath,
43:                                const char *auxfilepath, bool from_bundle, FileLoader sl);
44: extern std::string RunLobster(std::string_view filename, std::string_view code, bool dump_builtins);
45: extern void TSDumpBuiltinDoc();
46: }  // namespace script</file><file path="src/selection.h">  1: class Selection {
  2:     bool textedit {false};
  3:     public:
  4:     Grid *grid;
  5:     int x;
  6:     int y;
  7:     int xs;
  8:     int ys;
  9:     int cursor {0};
 10:     int cursorend {0};
 11:     int firstdx {0};
 12:     int firstdy {0};
 13:     Selection(Grid *_grid = nullptr, int _x = 0, int _y = 0, int _xs = 0, int _ys = 0)
 14:         : grid(_grid), x(_x), y(_y), xs(_xs), ys(_ys) {}
 15:     void SelAll() {
 16:         if (textedit) {
 17:             cursor = 0;
 18:             cursorend = MaxCursor();
 19:         } else {
 20:             x = y = 0;
 21:             xs = grid-&gt;xs;
 22:             ys = grid-&gt;ys;
 23:         }
 24:     }
 25:     Cell *GetCell() const { return grid &amp;&amp; xs == 1 &amp;&amp; ys == 1 ? grid-&gt;C(x, y) : nullptr; }
 26:     Cell *GetFirst() const { return grid &amp;&amp; xs &gt;= 1 &amp;&amp; ys &gt;= 1 ? grid-&gt;C(x, y) : nullptr; }
 27:     bool EqLoc(const Selection &amp;s) {
 28:         return grid == s.grid &amp;&amp; x == s.x &amp;&amp; y == s.y &amp;&amp; xs == s.xs &amp;&amp; ys == s.ys;
 29:     }
 30:     bool operator==(Selection &amp;s) {
 31:         return EqLoc(s) &amp;&amp; cursor == s.cursor &amp;&amp; cursorend == s.cursorend;
 32:     }
 33:     bool Thin() const { return !(xs * ys); }
 34:     bool IsAll() const { return xs == grid-&gt;xs &amp;&amp; ys == grid-&gt;ys; }
 35:     void SetCursorEdit(Document *doc, bool edit) {
 36:         wxCursor c(edit ? wxCURSOR_IBEAM : wxCURSOR_ARROW);
 37:         #ifdef WIN32
 38:         // this changes the cursor instantly, but gets overridden by the local window cursor
 39:         ::SetCursor((HCURSOR)c.GetHCURSOR());
 40:         #endif
 41:         // this doesn&apos;t change the cursor immediately, only on mousemove:
 42:         doc-&gt;canvas-&gt;SetCursor(c);
 43:         firstdx = firstdy = 0;
 44:     }
 45:     bool TextEdit() { return textedit; }
 46:     void EnterEditOnly(Document *doc) {
 47:         textedit = true;
 48:         SetCursorEdit(doc, true);
 49:     }
 50:     void EnterEdit(Document *doc, int cursor = 0, int cursorend = 0) {
 51:         EnterEditOnly(doc);
 52:         this-&gt;cursor = cursor;
 53:         this-&gt;cursorend = cursorend;
 54:     }
 55:     void ExitEdit(Document *doc) {
 56:         textedit = false;
 57:         cursor = cursorend = 0;
 58:         SetCursorEdit(doc, false);
 59:     }
 60:     bool IsInside(Selection &amp;o) {
 61:         if (!o.grid || !grid) return false;
 62:         if (grid != o.grid)
 63:             return grid-&gt;cell-&gt;parent &amp;&amp; grid-&gt;cell-&gt;parent-&gt;grid-&gt;FindCell(grid-&gt;cell).IsInside(o);
 64:         return x &gt;= o.x &amp;&amp; y &gt;= o.y &amp;&amp; x + xs &lt;= o.x + o.xs &amp;&amp; y + ys &lt;= o.y + o.ys;
 65:     }
 66:     void Merge(const Selection &amp;a, const Selection &amp;b) {
 67:         textedit = false;
 68:         if (a.grid == b.grid) {
 69:             if (a.GetCell() == b.GetCell() &amp;&amp; a.GetCell() &amp;&amp; (a.textedit || b.textedit)) {
 70:                 if (a.cursor != a.cursorend) {
 71:                     Selection c = b;
 72:                     a.GetCell()-&gt;text.SelectWord(c);
 73:                     cursor = min(a.cursor, c.cursor);
 74:                     cursorend = max(a.cursorend, c.cursorend);
 75:                 } else {
 76:                     cursor = min(a.cursor, b.cursor);
 77:                     cursorend = max(a.cursor, b.cursor);
 78:                 }
 79:                 textedit = true;
 80:             } else {
 81:                 cursor = cursorend = 0;
 82:             }
 83:         } else {
 84:             auto at = a.GetCell();
 85:             auto bt = b.GetCell();
 86:             int ad = at-&gt;Depth();
 87:             int bd = bt-&gt;Depth();
 88:             int i = 0;
 89:             while (i &lt; ad &amp;&amp; i &lt; bd &amp;&amp; at-&gt;Parent(ad - i) == bt-&gt;Parent(bd - i)) i++;
 90:             auto g = at-&gt;Parent(ad - i + 1)-&gt;grid;
 91:             Merge(g-&gt;FindCell(at-&gt;Parent(ad - i)), g-&gt;FindCell(bt-&gt;Parent(bd - i)));
 92:             return;
 93:         }
 94:         grid = a.grid;
 95:         x = min(a.x, b.x);
 96:         y = min(a.y, b.y);
 97:         xs = abs(a.x - b.x) + 1;
 98:         ys = abs(a.y - b.y) + 1;
 99:     }
100:     int MaxCursor() { return int(GetCell()-&gt;text.t.Len()); }
101:     inline bool IsWordSep(wxChar ch) {
102:         // represents: !&quot;#$%&amp;&apos;()*+,-./    :;&lt;=&gt;?@    [\]^    {|}~    `
103:         return 32 &lt; ch &amp;&amp; ch &lt; 48 || 57 &lt; ch &amp;&amp; ch &lt; 65 || 90 &lt; ch &amp;&amp; ch &lt; 95 ||
104:                122 &lt; ch &amp;&amp; ch &lt; 127 || ch == 96;
105:     }
106:     inline int CharType(wxChar ch) {
107:         if (wxIsspace(ch)) return TEXT_SPACE;
108:         if (IsWordSep(ch)) return TEXT_SEP;
109:         return TEXT_CHAR;
110:     }
111:     void Dir(Document *doc, bool ctrl, bool shift, int dx, int dy, int &amp;v, int &amp;vs, int &amp;ovs,
112:              bool notboundaryperp, bool notboundarypar, bool exitedit) {
113:         if (ctrl &amp;&amp; !textedit) {
114:             grid-&gt;cell-&gt;AddUndo(doc);
115:             grid-&gt;Move(dx, dy, *this);
116:             x = (x + dx + grid-&gt;xs) % grid-&gt;xs;
117:             y = (y + dy + grid-&gt;ys) % grid-&gt;ys;
118:             if (x + xs &gt; grid-&gt;xs || y + ys &gt; grid-&gt;ys) grid = nullptr;
119:             // FIXME: this is null in the case of a whole column selection, and doesn&apos;t do the right
120:             // thing.
121:             if (grid) grid-&gt;cell-&gt;ResetChildren();
122:             doc-&gt;paintscrolltoselection = true;
123:             doc-&gt;canvas-&gt;Refresh();
124:         } else {
125:             if (ctrl &amp;&amp; dx)  // implies textedit
126:             {
127:                 if (cursor == cursorend) firstdx = dx;
128:                 int &amp;curs = firstdx &lt; 0 ? cursor : cursorend;
129:                 int c = curs + dx;
130:                 wxChar ch;
131:                 if (c &gt;= 0 &amp;&amp; c &lt;= MaxCursor()) {
132:                     ch = GetCell()-&gt;text.t[min(c, curs)];
133:                     // TEXT_SPACE &gt; TEXT_SEP &gt; TEXT_CHAR &gt; 0.
134:                     // Accepts smaller or equal type when positive, only equal when negative.
135:                     // in regex terms (space/sep/char = s/p/c): match (s+p*|s+c*|p+c*|c+)
136:                     int allowed = CharType(ch);
137:                     curs = c;
138:                     for (;;) {
139:                         c += dx;
140:                         if (c &lt; 0 || c &gt; MaxCursor()) break;
141:                         ch = GetCell()-&gt;text.t[min(c, curs)];
142:                         int chtype = CharType(ch);
143:                         // type increase when positive or type change when negative =&gt; break
144:                         if (chtype &gt; allowed &amp;&amp; chtype != -allowed) break;
145:                         curs = c;
146:                         // type decrease when positive =&gt; negate
147:                         if (chtype &lt; allowed) allowed = -chtype;
148:                     }
149:                 }
150:                 if (shift) {
151:                     if (cursorend &lt; cursor) swap_(cursorend, cursor);
152:                 } else
153:                     cursorend = cursor = curs;
154:             } else if (shift) {
155:                 if (textedit) {
156:                     if (cursor == cursorend) firstdx = dx;
157:                     (firstdx &lt; 0 ? cursor : cursorend) += dx;
158:                     if (cursor &lt; 0) cursor = 0;
159:                     if (cursorend &gt; MaxCursor()) cursorend = MaxCursor();
160:                 } else {
161:                     if (!xs) firstdx = 0;  // redundant: just in case someone else changed it
162:                     if (!ys) firstdy = 0;
163:                     if (!firstdx) firstdx = dx;
164:                     if (!firstdy) firstdy = dy;
165:                     if (firstdx &lt; 0) {
166:                         x += dx;
167:                         xs += -dx;
168:                     } else
169:                         xs += dx;
170:                     if (firstdy &lt; 0) {
171:                         y += dy;
172:                         ys += -dy;
173:                     } else
174:                         ys += dy;
175:                     if (x &lt; 0) {
176:                         x = 0;
177:                         xs--;
178:                     }
179:                     if (y &lt; 0) {
180:                         y = 0;
181:                         ys--;
182:                     }
183:                     if (x + xs &gt; grid-&gt;xs) xs--;
184:                     if (y + ys &gt; grid-&gt;ys) ys--;
185:                     if (!xs) firstdx = 0;
186:                     if (!ys) firstdy = 0;
187:                     if (!xs &amp;&amp; !ys) grid = nullptr;
188:                 }
189:             } else {
190:                 if (vs) {
191:                     if (ovs)  // (multi) cell selection
192:                     {
193:                         bool intracell = true;
194:                         if (textedit &amp;&amp; !exitedit &amp;&amp; GetCell()) {
195:                             if (dy) {
196:                                 cursorend = cursor;
197:                                 auto &amp;text = GetCell()-&gt;text;
198:                                 int maxcolwidth = GetCell()-&gt;parent-&gt;grid-&gt;colwidths[x];
199:                                 int i = 0;
200:                                 int laststart, lastlen;
201:                                 int nextoffset = -1;
202:                                 for (int l = 0;; l++) {
203:                                     int start = i;
204:                                     auto ls = text.GetLine(i, maxcolwidth);
205:                                     auto len = static_cast&lt;int&gt;(ls.Len());
206:                                     int end = start + len;
207:                                     if (len &amp;&amp; nextoffset &gt;= 0) {
208:                                         cursor = cursorend =
209:                                             start + (nextoffset &gt; len ? len : nextoffset);
210:                                         intracell = false;
211:                                         break;
212:                                     }
213:                                     if (cursor &gt;= start &amp;&amp; cursor &lt;= end) {
214:                                         if (dy &lt; 0) {
215:                                             if (l != 0) {
216:                                                 cursor = cursorend =
217:                                                     laststart + (cursor - start &gt; lastlen
218:                                                                      ? lastlen
219:                                                                      : cursor - start);
220:                                                 intracell = false;
221:                                             }
222:                                             break;
223:                                         } else {
224:                                             nextoffset = cursor - start;
225:                                         }
226:                                     }
227:                                     laststart = start;
228:                                     lastlen = len;
229:                                     if (!len) break;
230:                                 }
231:                             } else {
232:                                 intracell = false;
233:                                 if (cursor != cursorend) {
234:                                     if (dx &lt; 0)
235:                                         cursorend = cursor;
236:                                     else
237:                                         cursor = cursorend;
238:                                 } else {
239:                                     if ((dx &lt; 0 &amp;&amp; cursor) || (dx &gt; 0 &amp;&amp; MaxCursor() &gt; cursor))
240:                                         cursorend = cursor += dx;
241:                                 }
242:                             }
243:                         }
244:                         if (intracell) {
245:                             if (sys-&gt;thinselc) {
246:                                 if (dx + dy &gt; 0) v += vs;
247:                                 vs = 0;  // make it a thin selection, in direction
248:                                 ovs = 1;
249:                             } else {
250:                                 if (x + dx &gt;= 0 &amp;&amp; x + dx + xs &lt;= grid-&gt;xs &amp;&amp; y + dy &gt;= 0 &amp;&amp;
251:                                     y + dy + ys &lt;= grid-&gt;ys) {
252:                                     x += dx;
253:                                     y += dy;
254:                                 }
255:                             }
256:                             ExitEdit(doc);
257:                         }
258:                     } else if (notboundarypar)  // thin selection, moving in parallel direction
259:                     {
260:                         v += dx + dy;
261:                     }
262:                 } else if (notboundaryperp)  // thin selection, moving in perpendicular direction
263:                 {
264:                     if (dx + dy &lt; 0) v--;
265:                     vs = 1;  // make it a cell selection
266:                 } else {     // selection cycle, jump to the opposite side of the grid
267:                     if (y + dy &gt; grid-&gt;ys) {
268:                         y = 0;
269:                         vs = 1;
270:                     } else if (y + dy &lt; 0) {
271:                         y = grid-&gt;ys - 1;
272:                         vs = 1;
273:                     } else if (x + dx &gt; grid-&gt;xs) {
274:                         x = 0;
275:                         vs = 1;
276:                     } else if (x + dx &lt; 0) {
277:                         x = grid-&gt;xs - 1;
278:                         vs = 1;
279:                     }
280:                 };
281:             }
282:             doc-&gt;paintscrolltoselection = true;
283:             doc-&gt;canvas-&gt;Refresh();
284:         };
285:     }
286:     void Cursor(Document *doc, int action, bool ctrl, bool shift, bool exitedit = false) {
287:         switch (action) {
288:             case A_UP: Dir(doc, ctrl, shift, 0, -1, y, ys, xs, y != 0, y != 0, exitedit); break;
289:             case A_DOWN:
290:                 Dir(doc, ctrl, shift, 0, 1, y, ys, xs, y &lt; grid-&gt;ys, y &lt; grid-&gt;ys - 1, exitedit);
291:                 break;
292:             case A_LEFT: Dir(doc, ctrl, shift, -1, 0, x, xs, ys, x != 0, x != 0, exitedit); break;
293:             case A_RIGHT:
294:                 Dir(doc, ctrl, shift, 1, 0, x, xs, ys, x &lt; grid-&gt;xs, x &lt; grid-&gt;xs - 1, exitedit);
295:                 break;
296:         }
297:         sys-&gt;frame-&gt;UpdateStatus(doc-&gt;selected);
298:     }
299:     void Next(Document *doc, bool backwards) {
300:         ExitEdit(doc);
301:         if (backwards) {
302:             if (x &gt; 0)
303:                 x--;
304:             else if (y &gt; 0) {
305:                 y--;
306:                 x = grid-&gt;xs - 1;
307:             } else {
308:                 x = grid-&gt;xs - 1;
309:                 y = grid-&gt;ys - 1;
310:             }
311:         } else {
312:             if (x &lt; grid-&gt;xs - 1)
313:                 x++;
314:             else if (y &lt; grid-&gt;ys - 1) {
315:                 y++;
316:                 x = 0;
317:             } else
318:                 x = y = 0;
319:         }
320:         EnterEdit(doc, 0, MaxCursor());
321:         doc-&gt;paintscrolltoselection = true;
322:         doc-&gt;canvas-&gt;Refresh();
323:     }
324:     const wxChar *Wrap(Document *doc) {
325:         if (Thin()) return doc-&gt;NoThin();
326:         grid-&gt;cell-&gt;AddUndo(doc);
327:         auto np = grid-&gt;CloneSel(*this).release();
328:         grid-&gt;C(x, y)-&gt;text.t = &quot;.&quot;;  // avoid this cell getting deleted
329:         if (xs &gt; 1) {
330:             Selection s(grid, x + 1, y, xs - 1, ys);
331:             grid-&gt;MultiCellDeleteSub(doc, s);
332:         }
333:         if (ys &gt; 1) {
334:             Selection s(grid, x, y + 1, 1, ys - 1);
335:             grid-&gt;MultiCellDeleteSub(doc, s);
336:         }
337:         auto old = grid-&gt;C(x, y);
338:         np-&gt;text.relsize = old-&gt;text.relsize;
339:         np-&gt;CloneStyleFrom(old);
340:         grid-&gt;ReplaceCell(old, np);
341:         np-&gt;parent = grid-&gt;cell;
342:         delete old;
343:         xs = ys = 1;
344:         EnterEdit(doc, MaxCursor(), MaxCursor());
345:         doc-&gt;canvas-&gt;Refresh();
346:         return nullptr;
347:     }
348:     Cell *ThinExpand(Document *doc, bool jumptofirst = false) {
349:         if (Thin()) {
350:             if (xs) {
351:                 grid-&gt;cell-&gt;AddUndo(doc);
352:                 grid-&gt;InsertCells(-1, y, 0, 1);
353:                 ys = 1;
354:                 if (jumptofirst) x = 0;
355:             } else {
356:                 grid-&gt;cell-&gt;AddUndo(doc);
357:                 grid-&gt;InsertCells(x, -1, 1, 0);
358:                 xs = 1;
359:                 if (jumptofirst) y = 0;
360:             }
361:         }
362:         return GetCell();
363:     }
364:     void HomeEnd(Document *doc, bool ishome) {
365:         xs = ys = 1;
366:         if (ishome)
367:             x = y = 0;
368:         else {
369:             x = grid-&gt;xs - 1;
370:             y = grid-&gt;ys - 1;
371:         }
372:         doc-&gt;paintscrolltoselection = true;
373:         doc-&gt;canvas-&gt;Refresh();
374:     }
375: };</file><file path="src/stdafx.cpp">1: #include &quot;stdafx.h&quot;</file><file path="src/stdafx.h"> 1: #pragma once
 2: #ifdef _WIN32
 3:     #define _CRT_SECURE_NO_WARNINGS
 4:     #define _SCL_SECURE_NO_WARNINGS
 5: #endif
 6: #include &lt;ctype.h&gt;
 7: #include &lt;wx/aboutdlg.h&gt;
 8: #include &lt;wx/clipbrd.h&gt;
 9: #include &lt;wx/confbase.h&gt;
10: #include &lt;wx/config.h&gt;
11: #include &lt;wx/datstrm.h&gt;
12: #include &lt;wx/dcbuffer.h&gt;
13: #include &lt;wx/dir.h&gt;
14: #include &lt;wx/dnd.h&gt;
15: #include &lt;wx/fileconf.h&gt;
16: #include &lt;wx/numdlg.h&gt;
17: #include &lt;wx/tokenzr.h&gt;
18: #include &lt;wx/txtstrm.h&gt;
19: #include &lt;wx/wfstream.h&gt;
20: #include &lt;wx/wx.h&gt;
21: #include &lt;wx/zstream.h&gt;
22: #ifdef _WIN32
23:     #include &lt;WinUser.h&gt;
24:     #include &lt;imm.h&gt;
25:     #ifdef _MSC_VER
26:         #pragma comment(lib, &quot;imm32&quot;)
27:     #endif
28:     #include &lt;wx/msw/dc.h&gt;
29:     #include &lt;wx/msw/regconf.h&gt;
30: #endif
31: #include &lt;wx/aui/aui.h&gt;
32: #include &lt;wx/base64.h&gt;
33: #include &lt;wx/bmpbndl.h&gt;
34: #include &lt;wx/colordlg.h&gt;
35: #include &lt;wx/datectrl.h&gt;
36: #include &lt;wx/display.h&gt;
37: #include &lt;wx/docview.h&gt;
38: #include &lt;wx/filename.h&gt;
39: #include &lt;wx/fontdlg.h&gt;
40: #include &lt;wx/fswatcher.h&gt;
41: #include &lt;wx/ipc.h&gt;
42: #include &lt;wx/mstream.h&gt;
43: #include &lt;wx/notebook.h&gt;
44: #include &lt;wx/odcombo.h&gt;
45: #include &lt;wx/print.h&gt;
46: #include &lt;wx/printdlg.h&gt;
47: #include &lt;wx/sizer.h&gt;
48: #include &lt;wx/snglinst.h&gt;
49: #include &lt;wx/srchctrl.h&gt;
50: #include &lt;wx/stdpaths.h&gt;
51: #include &lt;wx/sysopt.h&gt;
52: #include &lt;wx/taskbar.h&gt;
53: #include &lt;wx/timectrl.h&gt;
54: #include &lt;wx/translation.h&gt;
55: #include &lt;wx/uilocale.h&gt;
56: #include &lt;wx/xml/xml.h&gt;
57: #include &lt;algorithm&gt;
58: #include &lt;array&gt;
59: #include &lt;clocale&gt;
60: #include &lt;condition_variable&gt;
61: #include &lt;filesystem&gt;
62: #include &lt;functional&gt;
63: #include &lt;future&gt;
64: #include &lt;locale&gt;
65: #include &lt;map&gt;
66: #include &lt;memory&gt;
67: #include &lt;mutex&gt;
68: #include &lt;new&gt;
69: #include &lt;queue&gt;
70: #include &lt;set&gt;
71: #include &lt;sstream&gt;
72: #include &lt;stdexcept&gt;
73: #include &lt;string&gt;
74: #include &lt;string_view&gt;
75: #include &lt;thread&gt;
76: #include &lt;utility&gt;
77: #include &lt;vector&gt;
78: #include &quot;threadpool.h&quot;
79: #include &quot;tools.h&quot;
80: #ifdef __WXMAC__
81:     #include &lt;mach-o/dyld.h&gt;
82: #endif
83: using namespace std;</file><file path="src/system.h">  1: struct System {
  2:     TSFrame *frame;
  3:     wxString defaultfont {
  4:         #ifdef WIN32
  5:             L&quot;Lucida Sans Unicode&quot;
  6:         #else
  7:             L&quot;Verdana&quot;
  8:         #endif
  9:     };
 10:     wxString defaultfixedfont {L&quot;Courier New&quot;};
 11:     wxString defaultlang {wxEmptyString};
 12:     wxString searchstring;
 13:     unique_ptr&lt;wxConfigBase&gt; cfg;
 14:     Evaluator evaluator;
 15:     wxString clipboardcopy;
 16:     unique_ptr&lt;Cell&gt; cellclipboard;
 17:     vector&lt;unique_ptr&lt;Image&gt;&gt; imagelist;
 18:     vector&lt;int&gt; loadimageids;
 19:     uchar versionlastloaded {0};
 20:     wxLongLong fakelasteditonload;
 21:     wxPen pen_tinytext {wxColour(0x808080ul)};
 22:     wxPen pen_gridborder {wxColour(0xb5a6a4)};
 23:     wxPen pen_tinygridlines {wxColour(0xf2dcd8)};
 24:     wxPen pen_gridlines {wxColour(0xe5b7b0)};
 25:     wxPen pen_thinselect {*wxLIGHT_GREY};
 26:     int roundness {3};
 27:     int defaultmaxcolwidth {80};
 28:     bool makebaks {true};
 29:     bool totray {false};
 30:     bool autosave {true};
 31:     bool zoomscroll {false};
 32:     bool thinselc {true};
 33:     bool minclose {false};
 34:     bool singletray {false};
 35:     bool centered {true};
 36:     bool fswatch {true};
 37:     int autohtmlexport {0};
 38:     bool casesensitivesearch {true};
 39:     bool darkennonmatchingcells {false};
 40:     bool fastrender {true};
 41:     bool showtoolbar {true};
 42:     bool showstatusbar {true};
 43:     bool followdarkmode {false};
 44:     bool darkmode {false};
 45:     int sortcolumn;
 46:     int sortxs;
 47:     int sortdescending;
 48:     std::set&lt;wxString&gt; watchedpaths;
 49:     bool insidefiledialog {false};
 50:     struct TimerStruct : wxTimer {
 51:         void Notify() {
 52:             sys-&gt;SaveCheck();
 53:             sys-&gt;cfg-&gt;Flush();
 54:         }
 55:     } every_second_timer;
 56:     uint lastcellcolor {0xFFFFFF};
 57:     uint lasttextcolor {0};
 58:     uint lastbordcolor {0xA0A0A0};
 59:     Image *lastimage {nullptr};
 60:     int customcolor {0xFFFFFF};
 61:     int cursorcolor {0x00FF00};
 62:     System(bool portable)
 63:         : cfg(portable ? (wxConfigBase *)new wxFileConfig(
 64:                              L&quot;&quot;, wxT(&quot;&quot;), wxGetCwd() + wxT(&quot;/TreeSheets.ini&quot;), wxT(&quot;&quot;), 0)
 65:                        : (wxConfigBase *)new wxConfig(L&quot;TreeSheets&quot;)) {
 66:         static const wxDash glpattern[] = {1, 3};
 67:         pen_gridlines.SetDashes(2, glpattern);
 68:         pen_gridlines.SetStyle(wxPENSTYLE_USER_DASH);
 69:         static const wxDash tspattern[] = {2, 4};
 70:         pen_thinselect.SetDashes(2, tspattern);
 71:         pen_thinselect.SetStyle(wxPENSTYLE_USER_DASH);
 72:         roundness = static_cast&lt;int&gt;(cfg-&gt;Read(L&quot;roundness&quot;, roundness));
 73:         autohtmlexport = static_cast&lt;int&gt;(cfg-&gt;Read(L&quot;autohtmlexport&quot;, autohtmlexport));
 74:         defaultfont = cfg-&gt;Read(L&quot;defaultfont&quot;, defaultfont);
 75:         defaultfixedfont = cfg-&gt;Read(L&quot;defaultfixedfont&quot;, defaultfixedfont);
 76:         defaultlang = cfg-&gt;Read(L&quot;defaultlang&quot;, defaultlang);
 77:         cfg-&gt;Read(L&quot;defaultmaxcolwidth&quot;, &amp;defaultmaxcolwidth, defaultmaxcolwidth);
 78:         cfg-&gt;Read(L&quot;makebaks&quot;, &amp;makebaks, makebaks);
 79:         cfg-&gt;Read(L&quot;totray&quot;, &amp;totray, totray);
 80:         cfg-&gt;Read(L&quot;zoomscroll&quot;, &amp;zoomscroll, zoomscroll);
 81:         cfg-&gt;Read(L&quot;thinselc&quot;, &amp;thinselc, thinselc);
 82:         cfg-&gt;Read(L&quot;autosave&quot;, &amp;autosave, autosave);
 83:         cfg-&gt;Read(L&quot;fastrender&quot;, &amp;fastrender, fastrender);
 84:         cfg-&gt;Read(L&quot;followdarkmode&quot;, &amp;followdarkmode, followdarkmode);
 85:         cfg-&gt;Read(L&quot;minclose&quot;, &amp;minclose, minclose);
 86:         cfg-&gt;Read(L&quot;singletray&quot;, &amp;singletray, singletray);
 87:         cfg-&gt;Read(L&quot;centered&quot;, &amp;centered, centered);
 88:         cfg-&gt;Read(L&quot;fswatch&quot;, &amp;fswatch, fswatch);
 89:         cfg-&gt;Read(L&quot;casesensitivesearch&quot;, &amp;casesensitivesearch, casesensitivesearch);
 90:         cfg-&gt;Read(L&quot;defaultfontsize&quot;, &amp;g_deftextsize, g_deftextsize);
 91:         cfg-&gt;Read(L&quot;customcolor&quot;, &amp;customcolor, customcolor);
 92:         cfg-&gt;Read(L&quot;cursorcolor&quot;, &amp;cursorcolor, cursorcolor);
 93:         cfg-&gt;Read(L&quot;showtoolbar&quot;, &amp;showtoolbar, showtoolbar);
 94:         cfg-&gt;Read(L&quot;showstatusbar&quot;, &amp;showstatusbar, showstatusbar);
 95:         // fsw.Connect(wxID_ANY, wxID_ANY, wxEVT_FSWATCHER,
 96:         // wxFileSystemWatcherEventHandler(System::OnFileChanged));
 97:         darkmode = followdarkmode &amp;&amp; wxSystemSettings::GetAppearance().IsDark();
 98:     }
 99:     auto NewTabDoc(bool append = false) {
100:         auto doc = new Document();
101:         frame-&gt;NewTab(doc, append);
102:         return doc;
103:     }
104:     void TabChange(Document *newdoc) {
105:         // SetSelect(hover = Selection());
106:         newdoc-&gt;canvas-&gt;SetFocus();
107:         newdoc-&gt;UpdateFileName();
108:     }
109:     void Init(const wxString &amp;filename) {
110:         evaluator.Init();
111:         auto numfiles = static_cast&lt;int&gt;(cfg-&gt;Read(L&quot;numopenfiles&quot;, static_cast&lt;long&gt;(0)));
112:         loop(i, numfiles) {
113:             wxString filename;
114:             cfg-&gt;Read(wxString::Format(L&quot;lastopenfile_%d&quot;, i), &amp;filename);
115:             LoadDB(filename);
116:         }
117:         if (filename.Len()) LoadDB(filename);
118:         if (!frame-&gt;notebook-&gt;GetPageCount()) LoadTutorial();
119:         if (!frame-&gt;notebook-&gt;GetPageCount()) InitDB(10);
120:         // Refresh();
121:         every_second_timer.Start(1000);
122:     }
123:     void LoadTutorial() {
124:         auto trans = wxTranslations::Get();
125:         auto language = trans ? trans-&gt;GetBestTranslation(L&quot;ts&quot;) : wxString(L&quot;&quot;);
126:         if (language.Len() == 5 &amp;&amp;
127:             !LoadDB(frame-&gt;app-&gt;GetDocPath(L&quot;examples/tutorial-&quot; + language + &quot;.cts&quot;))[0]) {
128:             return;
129:         }
130:         language.Truncate(2);
131:         if (language.Len() == 2 &amp;&amp;
132:             !LoadDB(frame-&gt;app-&gt;GetDocPath(L&quot;examples/tutorial-&quot; + language + &quot;.cts&quot;))[0]) {
133:             return;
134:         }
135:         LoadDB(frame-&gt;app-&gt;GetDocPath(L&quot;examples/tutorial.cts&quot;));
136:     }
137:     void LoadOpRef() { LoadDB(frame-&gt;app-&gt;GetDocPath(L&quot;examples/operation-reference.cts&quot;)); }
138:     Cell *&amp;InitDB(int sizex, int sizey = 0) {
139:         auto c = new Cell(nullptr, nullptr, CT_DATA, new Grid(sizex, sizey ? sizey : sizex));
140:         c-&gt;cellcolor = 0xCCDCE2;
141:         c-&gt;grid-&gt;InitCells();
142:         auto doc = NewTabDoc();
143:         doc-&gt;InitWith(c, L&quot;&quot;, nullptr, 1, 1);
144:         return doc-&gt;root;
145:     }
146:     wxString BakName(const wxString &amp;filename) { return ExtName(filename, L&quot;.bak&quot;); }
147:     wxString TmpName(const wxString &amp;filename) { return ExtName(filename, L&quot;.tmp&quot;); }
148:     wxString ExtName(const wxString &amp;filename, auto ext) {
149:         wxFileName fn(filename);
150:         return fn.GetPathWithSep() + fn.GetName() + ext;
151:     }
152:     const wxChar *LoadDB(const wxString &amp;filename, bool fromreload = false) {
153:         auto fn = filename;
154:         auto loadedfromtmp = false;
155:         if (!fromreload) {
156:             if (frame-&gt;GetTabByFileName(filename)) return L&quot;&quot;;  //&quot;this file is already loaded&quot;;
157:             if (::wxFileExists(TmpName(filename))) {
158:                 if (::wxMessageBox(
159:                         _(L&quot;A temporary autosave file exists, would you like to load it instead?&quot;),
160:                         _(L&quot;Autosave load&quot;), wxYES_NO, frame) == wxYES) {
161:                     fn = TmpName(filename);
162:                     loadedfromtmp = true;
163:                 }
164:             }
165:         }
166:         Document *doc = nullptr;
167:         auto anyimagesfailed = false;
168:         auto start_loading_time = wxGetLocalTimeMillis();
169:         int zoomlevel = 0;
170:         {  // limit destructors
171:             wxBusyCursor wait;
172:             Cell *ics = nullptr;
173:             wxFFileInputStream fis(fn);
174:             wxDataInputStream dis(fis);
175:             if (!fis.IsOk()) {
176:                 for (int i = 0, n = frame-&gt;filehistory.GetCount(); i &lt; n; i++) {
177:                     if (frame-&gt;filehistory.GetHistoryFile(i) == filename)
178:                         frame-&gt;filehistory.RemoveFileFromHistory(i);
179:                 }
180:                 return _(L&quot;Cannot open file.&quot;);
181:             }
182:             char buf[4];
183:             fis.Read(buf, 4);
184:             if (strncmp(buf, &quot;TSFF&quot;, 4)) return _(L&quot;Not a TreeSheets file.&quot;);
185:             fis.Read(&amp;versionlastloaded, 1);
186:             if (versionlastloaded &gt; TS_VERSION) return _(L&quot;File of newer version.&quot;);
187:             auto xs = versionlastloaded &gt;= 21 ? dis.Read8() : 1;
188:             auto ys = versionlastloaded &gt;= 21 ? dis.Read8() : 1;
189:             zoomlevel = versionlastloaded &gt;= 23 ? dis.Read8() : 0;
190:             fakelasteditonload = wxDateTime::Now().GetValue();
191:             loadimageids.clear();
192:             for (;;) {
193:                 fis.Read(buf, 1);
194:                 switch (*buf) {
195:                     case &apos;I&apos;:
196:                     case &apos;J&apos;: {
197:                         char iti = *buf;
198:                         if (!imagetypes.contains(iti))
199:                             return _(L&quot;Found an image type that is not defined in this program.&quot;);
200:                         if (versionlastloaded &lt; 9) dis.ReadString();
201:                         auto sc = versionlastloaded &gt;= 19 ? dis.ReadDouble() : 1.0;
202:                         vector&lt;uint8_t&gt; image_data;
203:                         if (versionlastloaded &gt;= 22) {
204:                             auto imagelen = (size_t)dis.Read64();
205:                             image_data.resize(imagelen);
206:                             fis.Read(image_data.data(), imagelen);
207:                         } else {
208:                             off_t beforeimage = fis.TellI();
209:                             if (iti == &apos;I&apos;) {
210:                                 uchar header[8];
211:                                 fis.Read(header, 8);
212:                                 uchar expected[] = {0x89, &apos;P&apos;, &apos;N&apos;, &apos;G&apos;, &apos;\r&apos;, &apos;\n&apos;, 0x1A, &apos;\n&apos;};
213:                                 if (memcmp(header, expected, 8)) return _(L&quot;Corrupt PNG header.&quot;);
214:                                 dis.BigEndianOrdered(true);
215:                                 for (;;) {  // Skip all chunks.
216:                                     wxInt32 len = dis.Read32();
217:                                     char fourcc[4];
218:                                     fis.Read(fourcc, 4);
219:                                     fis.SeekI(len, wxFromCurrent);  // skip data
220:                                     dis.Read32();                   // skip CRC
221:                                     if (memcmp(fourcc, &quot;IEND&quot;, 4) == 0) break;
222:                                 }
223:                             } else if (iti == &apos;J&apos;) {
224:                                 wxImage im;
225:                                 im.LoadFile(fis);
226:                                 if (!im.IsOk()) { return _(L&quot;JPEG file is corrupted!&quot;); }
227:                             }
228:                             off_t afterimage = fis.TellI();
229:                             fis.SeekI(beforeimage);
230:                             auto sz = afterimage - beforeimage;
231:                             image_data.resize(sz);
232:                             fis.Read(image_data.data(), sz);
233:                             fis.SeekI(afterimage);
234:                         }
235:                         if (!fis.IsOk()) image_data.clear();
236:                         loadimageids.push_back(AddImageToList(sc, std::move(image_data), iti));
237:                         break;
238:                     }
239:                     case &apos;D&apos;: {
240:                         wxZlibInputStream zis(fis);
241:                         if (!zis.IsOk()) return _(L&quot;Cannot decompress file.&quot;);
242:                         wxDataInputStream dis(zis);
243:                         auto numcells = 0, textbytes = 0;
244:                         auto root = Cell::LoadWhich(dis, nullptr, numcells, textbytes, ics);
245:                         if (!root) return _(L&quot;File corrupted!&quot;);
246:                         doc = NewTabDoc(true);
247:                         if (loadedfromtmp) {
248:                             doc-&gt;undolistsizeatfullsave =
249:                                 -1;  // if not, user will lose tmp without warning when he closes
250:                             doc-&gt;modified = true;
251:                         }
252:                         doc-&gt;InitWith(root, filename, ics, xs, ys);
253:                         if (versionlastloaded &gt;= 11) {
254:                             for (;;) {
255:                                 auto tag = dis.ReadString();
256:                                 if (!tag.Len()) break;
257:                                 doc-&gt;tags[tag] =
258:                                     versionlastloaded &gt;= 24 ? dis.Read32() : g_tagcolor_default;
259:                             }
260:                         }
261:                         auto end_loading_time = wxGetLocalTimeMillis();
262:                         frame-&gt;SetStatus(
263:                             wxString::Format(
264:                                 _(L&quot;Loaded %s (%d cells, %d characters) in %lld milliseconds.&quot;),
265:                                 filename.c_str(), numcells, textbytes,
266:                                 end_loading_time - start_loading_time)
267:                                 .c_str());
268:                         goto done;
269:                     }
270:                     default: return _(L&quot;Corrupt block header.&quot;);
271:                 }
272:             }
273:         }
274:     done:
275:         doc-&gt;RefreshImageRefCount(false);
276:         {
277:             ThreadPool pool(std::thread::hardware_concurrency());
278:             for (const auto &amp;image : sys-&gt;imagelist) {
279:                 pool.enqueue(
280:                     [](auto img) {
281:                         if (img-&gt;trefc) img-&gt;Display();
282:                     },
283:                     image.get());
284:             }
285:         }  // wait until all tasks are finished
286:         FileUsed(filename, doc);
287:         doc-&gt;Zoom(zoomlevel, true);
288:         if (anyimagesfailed)
289:             wxMessageBox(_(L&quot;PNG decode failed on some images in this document\nThey have been replaced by red squares.&quot;),
290:                          _(L&quot;PNG decoder failure&quot;), wxOK, frame);
291:         return L&quot;&quot;;
292:     }
293:     void FileUsed(const wxString &amp;filename, Document *doc) {
294:         frame-&gt;filehistory.AddFileToHistory(filename);
295:         if (fswatch) {
296:             doc-&gt;lastmodificationtime = wxFileName(filename).GetModificationTime();
297:             const auto &amp;directorypath = wxFileName(filename).GetPath(wxPATH_GET_VOLUME | wxPATH_GET_SEPARATOR);
298:             if (watchedpaths.insert(directorypath).second) {
299:                 frame-&gt;watcher-&gt;Add(wxFileName(directorypath), wxFSW_EVENT_ALL);
300:             }
301:         }
302:     }
303:     const wxChar *Open(const wxString &amp;filename) {
304:         if (!filename.empty()) {
305:             auto msg = LoadDB(filename);
306:             assert(msg);
307:             if (*msg) wxMessageBox(msg, filename.wx_str(), wxOK, frame);
308:             return msg;
309:         }
310:         return _(L&quot;Open file cancelled.&quot;);
311:     }
312:     void RememberOpenFiles() {
313:         auto namedfiles = 0;
314:         loop(i, frame-&gt;notebook-&gt;GetPageCount()) {
315:             auto canvas = static_cast&lt;TSCanvas *&gt;(frame-&gt;notebook-&gt;GetPage(i));
316:             if (canvas-&gt;doc-&gt;filename.Len()) {
317:                 cfg-&gt;Write(wxString::Format(L&quot;lastopenfile_%d&quot;, namedfiles), canvas-&gt;doc-&gt;filename);
318:                 namedfiles++;
319:             }
320:         }
321:         cfg-&gt;Write(L&quot;numopenfiles&quot;, namedfiles);
322:         cfg-&gt;Flush();
323:     }
324:     void SaveCheck() {
325:         loop(i, frame-&gt;notebook-&gt;GetPageCount()) {
326:             static_cast&lt;TSCanvas *&gt;(frame-&gt;notebook-&gt;GetPage(i))
327:                 -&gt;doc-&gt;AutoSave(!frame-&gt;IsActive(), i);
328:         }
329:     }
330:     void SaveAll() {
331:         loop(i, frame-&gt;notebook-&gt;GetPageCount()) {
332:             frame-&gt;GetCurrentTab()-&gt;doc-&gt;Save(false);
333:             frame-&gt;CycleTabs(1);
334:         }
335:     }
336:     const wxChar *Import(const wxString &amp;filename, int action) {
337:         if (!filename.empty()) {
338:             wxBusyCursor wait;
339:             switch (action) {
340:                 case A_IMPXML:
341:                 case A_IMPXMLA: {
342:                     wxXmlDocument doc;
343:                     if (!doc.Load(filename)) goto problem;
344:                     Cell *&amp;root = InitDB(1);
345:                     Cell *c = *root-&gt;grid-&gt;cells;
346:                     FillXML(c, doc.GetRoot(), action == A_IMPXMLA);
347:                     if (!c-&gt;HasText() &amp;&amp; c-&gt;grid) {
348:                         *root-&gt;grid-&gt;cells = nullptr;
349:                         delete root;
350:                         root = c;
351:                         c-&gt;parent = nullptr;
352:                     }
353:                     break;
354:                 }
355:                 case A_IMPTXTI:
356:                 case A_IMPTXTC:
357:                 case A_IMPTXTS:
358:                 case A_IMPTXTT: {
359:                     wxFFile file(filename);
360:                     if (!file.IsOpened()) goto problem;
361:                     wxString content;
362:                     if (!file.ReadAll(&amp;content)) goto problem;
363:                     const auto &amp;lines = wxStringTokenize(content, LINE_SEPARATOR);
364:                     if (lines.size()) switch (action) {
365:                             case A_IMPTXTI: {
366:                                 Cell *root = InitDB(1);
367:                                 FillRows(root-&gt;grid, lines, CountCol(lines[0]), 0, 0);
368:                             }; break;
369:                             case A_IMPTXTC:
370:                                 InitDB(1, static_cast&lt;int&gt;(lines.size()))
371:                                     -&gt;grid-&gt;CSVImport(lines, L&apos;,&apos;);
372:                                 break;
373:                             case A_IMPTXTS:
374:                                 InitDB(1, static_cast&lt;int&gt;(lines.size()))
375:                                     -&gt;grid-&gt;CSVImport(lines, L&apos;;&apos;);
376:                                 break;
377:                             case A_IMPTXTT:
378:                                 InitDB(1, static_cast&lt;int&gt;(lines.size()))
379:                                     -&gt;grid-&gt;CSVImport(lines, L&apos;\t&apos;);
380:                                 break;
381:                         }
382:                     break;
383:                 }
384:             }
385:             Document *doc = frame-&gt;GetCurrentTab()-&gt;doc;
386:             doc-&gt;modified = true;
387:             doc-&gt;UpdateFileName();
388:             doc-&gt;selected = Selection();
389:             doc-&gt;begindrag = Selection();
390:             doc-&gt;canvas-&gt;Refresh();
391:         }
392:         return nullptr;
393:     problem:
394:         wxMessageBox(_(L&quot;couldn&apos;t import file!&quot;), filename, wxOK, frame);
395:         return _(L&quot;File load error.&quot;);
396:     }
397:     int GetXMLNodes(wxXmlNode *node, auto &amp;nodes, vector&lt;wxXmlAttribute *&gt; *attributes = nullptr,
398:                     bool attributestoo = false) {
399:         for (auto child = node-&gt;GetChildren(); child; child = child-&gt;GetNext()) {
400:             if (child-&gt;GetType() == wxXML_ELEMENT_NODE) nodes.push_back(child);
401:         }
402:         if (attributestoo &amp;&amp; attributes)
403:             for (auto attribute = node-&gt;GetAttributes(); attribute;
404:                  attribute = attribute-&gt;GetNext()) {
405:                 attributes-&gt;push_back(attribute);
406:             }
407:         return nodes.size() + (attributes ? attributes-&gt;size() : 0);
408:     }
409:     void FillXML(Cell *c, wxXmlNode *node, bool attributestoo) {
410:         const auto &amp;words = wxStringTokenize(
411:             node-&gt;GetType() == wxXML_ELEMENT_NODE ? node-&gt;GetNodeContent() : node-&gt;GetContent());
412:         loop(i, words.GetCount()) {
413:             if (c-&gt;text.t.Len()) c-&gt;text.t.Append(L&apos; &apos;);
414:             c-&gt;text.t.Append(words[i]);
415:         }
416:         if (node-&gt;GetName() == L&quot;cell&quot;) {
417:             c-&gt;text.relsize = -wxAtoi(node-&gt;GetAttribute(L&quot;relsize&quot;, L&quot;0&quot;));
418:             c-&gt;text.stylebits = wxAtoi(node-&gt;GetAttribute(L&quot;stylebits&quot;, L&quot;0&quot;));
419:             c-&gt;cellcolor =
420:                 std::stoi(node-&gt;GetAttribute(L&quot;colorbg&quot;, L&quot;0xFFFFFF&quot;).ToStdString(), nullptr, 0);
421:             c-&gt;textcolor =
422:                 std::stoi(node-&gt;GetAttribute(L&quot;colorfg&quot;, L&quot;0x000000&quot;).ToStdString(), nullptr, 0);
423:             c-&gt;celltype = wxAtoi(node-&gt;GetAttribute(L&quot;type&quot;, L&quot;0&quot;));
424:         }
425:         vector&lt;wxXmlNode *&gt; nodes;
426:         vector&lt;wxXmlAttribute *&gt; attributes;
427:         auto numrows = GetXMLNodes(node, nodes, &amp;attributes, attributestoo);
428:         if (!numrows) return;
429:         if (nodes.size() == 1 &amp;&amp; (!c-&gt;text.t.Len() || nodes[0]-&gt;IsWhitespaceOnly()) &amp;&amp;
430:             nodes[0]-&gt;GetName() != L&quot;row&quot;) {
431:             FillXML(c, nodes[0], attributestoo);
432:         } else {
433:             auto allrow = node-&gt;GetName() == L&quot;grid&quot;;
434:             for (auto node : nodes)
435:                 if (node-&gt;GetName() != L&quot;row&quot;) {
436:                     allrow = false;
437:                     break;
438:                 }
439:             if (allrow) {
440:                 int desiredxs;
441:                 loopv(i, nodes) {
442:                     vector&lt;wxXmlNode *&gt; ins;
443:                     auto xs = GetXMLNodes(nodes[i], ins);
444:                     if (!i) {
445:                         desiredxs = xs ? xs : 1;
446:                         c-&gt;AddGrid(desiredxs, nodes.size());
447:                         SetGridSettingsFromXML(c, node);
448:                     }
449:                     loop(j, desiredxs) if (ins.size() &gt; j)
450:                         FillXML(c-&gt;grid-&gt;C(j, i), ins[j], attributestoo);
451:                 }
452:             } else {
453:                 c-&gt;AddGrid(1, numrows);
454:                 SetGridSettingsFromXML(c, node);
455:                 loopv(i, attributes) c-&gt;grid-&gt;C(0, i)-&gt;text.t = attributes[i]-&gt;GetValue();
456:                 loopv(i, nodes)
457:                     FillXML(c-&gt;grid-&gt;C(0, i + attributes.size()), nodes[i], attributestoo);
458:             }
459:         }
460:     }
461:     void SetGridSettingsFromXML(Cell *c, wxXmlNode *node) {
462:         c-&gt;grid-&gt;folded = wxAtoi(node-&gt;GetAttribute(L&quot;folded&quot;, L&quot;0&quot;));
463:         c-&gt;grid-&gt;bordercolor = std::stoi(
464:             node-&gt;GetAttribute(L&quot;bordercolor&quot;, wxString() &lt;&lt; g_bordercolor_default).ToStdString(),
465:             nullptr, 0);
466:         c-&gt;grid-&gt;user_grid_outer_spacing = wxAtoi(
467:             node-&gt;GetAttribute(L&quot;outerspacing&quot;, wxString() &lt;&lt; g_usergridouterspacing_default));
468:     }
469:     int CountCol(const auto &amp;s) {
470:         auto col = 0;
471:         while (s[col] == &apos; &apos; || s[col] == &apos;\t&apos;) col++;
472:         return col;
473:     }
474:     int FillRows(Grid *g, const wxArrayString &amp;as, int column, int startrow, int starty) {
475:         auto y = starty;
476:         for (int i = startrow, n = as.size(); i &lt; n; i++) {
477:             auto s = as[i];
478:             auto col = CountCol(s);
479:             if (col &lt; column &amp;&amp; startrow != 0) return i;
480:             if (col &gt; column) {
481:                 auto c = g-&gt;C(0, y - 1);
482:                 auto sg = c-&gt;grid;
483:                 i = FillRows(sg ? sg : c-&gt;AddGrid(), as, col, i, sg ? sg-&gt;ys : 0) - 1;
484:             } else {
485:                 if (g-&gt;ys &lt;= y) g-&gt;InsertCells(-1, y, 0, 1);
486:                 auto &amp;t = g-&gt;C(0, y)-&gt;text;
487:                 t.t = s.Trim(false);
488:                 y++;
489:             }
490:         }
491:         return static_cast&lt;int&gt;(as.size());
492:     }
493:     int AddImageToList(double scale, auto &amp;&amp;data, char type) {
494:         auto hash = CalculateHash(data);
495:         loopv(i, imagelist) {
496:             if (imagelist[i]-&gt;hash == hash &amp;&amp; imagelist[i]-&gt;type == type) return i;
497:         }
498:         imagelist.push_back(make_unique&lt;Image&gt;(hash, scale, std::move(data), type));
499:         return imagelist.size() - 1;
500:     }
501:     void ImageSize(wxBitmap *bm, int &amp;xs, int &amp;ys) {
502:         if (!bm) return;
503:         xs = bm-&gt;GetWidth();
504:         ys = bm-&gt;GetHeight();
505:     }
506:     void ImageDraw(wxBitmap *bm, wxDC &amp;dc, int x, int y) { dc.DrawBitmap(*bm, x, y); }
507: };</file><file path="src/text.h">  1: struct Text {
  2:     Cell *cell {nullptr};
  3:     Image *image {nullptr};
  4:     wxString t {wxEmptyString};
  5:     int relsize {0};
  6:     int stylebits {0};
  7:     int extent {0};
  8:     wxDateTime lastedit;
  9:     bool filtered {false};
 10:     void WasEdited() { lastedit = wxDateTime::Now(); }
 11:     Text() { WasEdited(); }
 12:     wxBitmap *DisplayImage() {
 13:         return cell-&gt;grid &amp;&amp; cell-&gt;grid-&gt;folded ? &amp;sys-&gt;frame-&gt;foldicon
 14:                                                 : (image ? &amp;image-&gt;Display() : nullptr);
 15:     }
 16:     size_t EstimatedMemoryUse() {
 17:         ASSERT(wxUSE_UNICODE);
 18:         return sizeof(Text) + t.Length() * sizeof(wchar_t);
 19:     }
 20:     double GetNum() {
 21:         std::wstringstream ss(t.ToStdWstring());
 22:         double r;
 23:         ss &gt;&gt; r;
 24:         return r;
 25:     }
 26:     void SetNum(double d) {
 27:         std::wstringstream ss;
 28:         ss &lt;&lt; std::fixed;
 29:         // We&apos;re going to use at most 19 digits after &apos;.&apos;. Add small value round remainder.
 30:         size_t max_significant = 10;
 31:         d += 0.00000000005;
 32:         ss &lt;&lt; d;
 33:         auto s = ss.str();
 34:         // First trim whatever lies beyond the precision to avoid garbage digits.
 35:         max_significant += 2;  // &quot;0.&quot;
 36:         if (s[0] == &apos;-&apos;) max_significant++;
 37:         if (s.length() &gt; max_significant) s.erase(max_significant);
 38:         // Now strip unnecessary trailing zeroes.
 39:         while (s.back() == &apos;0&apos;) s.pop_back();
 40:         // If there were only zeroes, remove &apos;.&apos;.
 41:         if (s.back() == &apos;.&apos;) s.pop_back();
 42:         t = s;
 43:     }
 44:     wxString htmlify(wxString &amp;str) {
 45:         wxString r;
 46:         for (auto cref : str) {
 47:             switch (wxChar c = cref.GetValue()) {
 48:                 case &apos;&amp;&apos;: r += L&quot;&amp;amp;&quot;; break;
 49:                 case &apos;&lt;&apos;: r += L&quot;&amp;lt;&quot;; break;
 50:                 case &apos;&gt;&apos;: r += L&quot;&amp;gt;&quot;; break;
 51:                 default: r += c;
 52:             }
 53:         }
 54:         return r;
 55:     }
 56:     wxString ToText(int indent, const Selection &amp;s, int format) {
 57:         wxString str = s.cursor != s.cursorend ? t.Mid(s.cursor, s.cursorend - s.cursor) : t;
 58:         if (format == A_EXPXML || format == A_EXPHTMLT || format == A_EXPHTMLTI ||
 59:             format == A_EXPHTMLTE || format == A_EXPHTMLO || format == A_EXPHTMLB)
 60:             str = htmlify(str);
 61:         if (format == A_EXPHTMLTI &amp;&amp; image)
 62:             str.Prepend(L&quot;&lt;img src=\&quot;data:&quot; + imagetypes.at(image-&gt;type).second + &quot;;base64,&quot; +
 63:                         wxBase64Encode(image-&gt;data.data(), image-&gt;data.size()) + &quot;\&quot; /&gt;&quot;);
 64:         else if (format == A_EXPHTMLTE &amp;&amp; image) {
 65:             wxString relsize = wxString::Format(
 66:                 &quot;%d%%&quot;, static_cast&lt;int&gt;(100.0 * sys-&gt;frame-&gt;FromDIP(1.0) / image-&gt;display_scale));
 67:             str.Prepend(L&quot;&lt;img src=\&quot;&quot; + wxString::Format(&quot;%llu&quot;, image-&gt;hash) +
 68:                         image-&gt;GetFileExtension() + L&quot;\&quot; width=\&quot;&quot; + relsize + L&quot;\&quot; height=\&quot;&quot; +
 69:                         relsize + L&quot;\&quot; /&gt;&quot;);
 70:         }
 71:         return str;
 72:     };
 73:     auto MinRelsize(int rs) { return min(relsize, rs); }
 74:     auto RelSize(int dir, int zoomdepth) {
 75:         relsize = max(min(relsize + dir, g_deftextsize - g_mintextsize() + zoomdepth),
 76:                       g_deftextsize - g_maxtextsize() - zoomdepth);
 77:     }
 78:     auto IsWord(wxChar c) { return wxIsalnum(c) || wxStrchr(L&quot;_\&quot;\&apos;()&quot;, c) || wxIspunct(c); }
 79:     auto GetLinePart(int &amp;currentpos, int breakpos, int limitpos) {
 80:         auto startpos = currentpos;
 81:         currentpos = breakpos;
 82:         for (auto j = t.begin() + startpos; (j != t.end()) &amp;&amp; !wxIsspace(*j) &amp;&amp; !IsWord(*j); j++) {
 83:             currentpos++;
 84:             breakpos++;
 85:         }
 86:         // gobble up any trailing punctuation
 87:         if (currentpos != startpos &amp;&amp; currentpos &lt; limitpos &amp;&amp;
 88:             (t[currentpos] == &apos;\&quot;&apos; || t[currentpos] == &apos;\&apos;&apos;)) {
 89:             currentpos++;
 90:             breakpos++;
 91:         }  // special case: if punctuation followed by quote, quote is meant to be part of word
 92:         for (auto k = t.begin() + currentpos; (k != t.end()) &amp;&amp; wxIsspace(*k); k++) {
 93:             // gobble spaces, but do not copy them
 94:             currentpos++;
 95:             if (currentpos == limitpos)
 96:                 breakpos = currentpos;  // happens with a space at the last line, user is most
 97:                                         // likely about to type another word, so
 98:             // need to show space. Alternatively could check if the cursor is actually on this spot.
 99:             // Simply
100:             // showing a blank new line would not be a good idea, unless the cursor is here for
101:             // sure, and
102:             // even then, placing the cursor there again after deselect may be hard.
103:         }
104:         ASSERT(startpos != currentpos);
105:         return t.Mid(startpos, breakpos - startpos);
106:     }
107:     wxString GetLine(auto &amp;i, auto maxcolwidth) {
108:         auto l = static_cast&lt;int&gt;(t.Len());
109:         if (i &gt;= l) return wxEmptyString;
110:         if (!i &amp;&amp; l &lt;= maxcolwidth) {
111:             i = l;
112:             return t;
113:         }  // subsumed by the case below, but this case happens 90% of the time, so more optimal
114:         if (l - i &lt;= maxcolwidth) return GetLinePart(i, l, l);
115:         for (auto p = i + maxcolwidth; p &gt;= i; p--)
116:             if (!IsWord(t[p])) return GetLinePart(i, p, l);
117:         // A single word is &gt; maxcolwidth. We split it up anyway.
118:         // This happens with long urls and e.g. Japanese text without spaces.
119:         // Should really do proper unicode linebreaking instead (see libunibreak),
120:         // but for now this is better than the old code below which allowed for arbitrary long
121:         // words.
122:         return GetLinePart(i, min(i + maxcolwidth, l), l);
123:         // for(int p = i+maxcolwidth; p&lt;l;  p++) if (!IsWord(t[p])) return GetLinePart(i, p, l);  //
124:         // we arrive here only
125:         // if a single word is too big for maxcolwidth, so simply return that word
126:         // return GetLinePart(i, l, l);     // big word was the last one
127:     }
128:     void TextSize(wxDC &amp;dc, int &amp;sx, int &amp;sy, int tiny, int &amp;leftoffset, int maxcolwidth) {
129:         sx = sy = 0;
130:         auto i = 0;
131:         for (;;) {
132:             auto curl = GetLine(i, maxcolwidth);
133:             if (!curl.Len()) break;
134:             int x, y;
135:             if (tiny) {
136:                 x = static_cast&lt;int&gt;(curl.Len());
137:                 y = 1;
138:             } else
139:                 dc.GetTextExtent(curl, &amp;x, &amp;y);
140:             sx = max(x, sx);
141:             sy += y;
142:             leftoffset = y;
143:         }
144:         if (!tiny) sx += 4;
145:     }
146:     bool IsInSearch() {
147:         return sys-&gt;searchstring.Len() &amp;&amp;
148:                (sys-&gt;casesensitivesearch ? t.Find(sys-&gt;searchstring)
149:                                          : t.Lower().Find(sys-&gt;searchstring)) &gt;= 0;
150:     }
151:     int Render(Document *doc, int bx, int by, int depth, wxDC &amp;dc, int &amp;leftoffset,
152:                int maxcolwidth) {
153:         auto ixs = 0, iys = 0;
154:         if (!cell-&gt;tiny) sys-&gt;ImageSize(DisplayImage(), ixs, iys);
155:         if (ixs &amp;&amp; iys) {
156:             sys-&gt;ImageDraw(DisplayImage(), dc, bx + 1 + g_margin_extra,
157:                            by + (cell-&gt;tys - iys) / 2 + g_margin_extra);
158:             ixs += 2;
159:             iys += 2;
160:         }
161:         if (t.empty()) return iys;
162:         doc-&gt;PickFont(dc, depth, relsize, stylebits);
163:         auto h = cell-&gt;tiny ? 1 : dc.GetCharHeight();
164:         leftoffset = h;
165:         auto i = 0;
166:         auto lines = 0;
167:         auto searchfound = IsInSearch();
168:         auto istag = cell-&gt;IsTag(doc);
169:         if (cell-&gt;tiny) {
170:             if (searchfound)
171:                 dc.SetPen(*wxRED_PEN);
172:             else if (filtered)
173:                 dc.SetPen(*wxLIGHT_GREY_PEN);
174:             else if (istag)
175:                 dc.SetPen(wxColour(LightColor(doc-&gt;tags[t])));
176:             else
177:                 dc.SetPen(sys-&gt;pen_tinytext);
178:         }
179:         for (;;) {
180:             auto curl = GetLine(i, maxcolwidth);
181:             if (!curl.Len()) break;
182:             if (cell-&gt;tiny) {
183:                 if (sys-&gt;fastrender) {
184:                     dc.DrawLine(bx + ixs, by + lines * h, bx + ixs + static_cast&lt;int&gt;(curl.Len()),
185:                                 by + lines * h);
186:                     /*
187:                     wxPoint points[] = { wxPoint(bx + ixs, by + lines * h), wxPoint(bx + ixs +
188:                     curl.Len(), by + lines * h) }; dc.DrawLines(1, points, 0, 0);
189:                      */
190:                 } else {
191:                     auto word = 0;
192:                     loop(p, static_cast&lt;int&gt;(curl.Len()) + 1) {
193:                         if (static_cast&lt;int&gt;(curl.Len()) &lt;= p || curl[p] == &apos; &apos;) {
194:                             if (word)
195:                                 dc.DrawLine(bx + p - word + ixs, by + lines * h, bx + p,
196:                                             by + lines * h);
197:                             word = 0;
198:                         } else
199:                             word++;
200:                     }
201:                 }
202:             } else {
203:                 if (searchfound)
204:                     dc.SetTextForeground(*wxRED);
205:                 else if (filtered)
206:                     dc.SetTextForeground(*wxLIGHT_GREY);
207:                 else if (istag)
208:                     dc.SetTextForeground(wxColour(LightColor(doc-&gt;tags[t])));
209:                 else if (cell-&gt;textcolor)
210:                     dc.SetTextForeground(LightColor(cell-&gt;textcolor));  // FIXME: clean up
211:                 auto tx = bx + 2 + ixs;
212:                 auto ty = by + lines * h;
213:                 dc.DrawText(curl, tx + g_margin_extra, ty + g_margin_extra);
214:                 if (searchfound || filtered || istag || cell-&gt;textcolor)
215:                     dc.SetTextForeground(sys-&gt;darkmode ? *wxWHITE : *wxBLACK);
216:             }
217:             lines++;
218:         }
219:         return max(lines * h, iys);
220:     }
221:     void FindCursor(Document *doc, int bx, int by, wxDC &amp;dc, Selection &amp;s, int maxcolwidth) {
222:         bx -= g_margin_extra;
223:         by -= g_margin_extra;
224:         auto ixs = 0, iys = 0;
225:         if (!cell-&gt;tiny) sys-&gt;ImageSize(DisplayImage(), ixs, iys);
226:         if (ixs) ixs += 2;
227:         doc-&gt;PickFont(dc, cell-&gt;Depth() - doc-&gt;drawpath.size(), relsize, stylebits);
228:         auto i = 0, linestart = 0;
229:         auto line = by / dc.GetCharHeight();
230:         wxString ls;
231:         loop(l, line + 1) {
232:             linestart = i;
233:             ls = GetLine(i, maxcolwidth);
234:         }
235:         for (;;) {
236:             auto x = 0, y = 0;
237:             dc.GetTextExtent(ls, &amp;x, &amp;y);  // FIXME: can we do this more intelligently?
238:             if (x &lt;= bx - ixs + 2 || !x) break;
239:             ls.Truncate(ls.Len() - 1);
240:         }
241:         s.cursor = s.cursorend = linestart + static_cast&lt;int&gt;(ls.Len());
242:         ASSERT(s.cursor &gt;= 0 &amp;&amp; s.cursor &lt;= static_cast&lt;int&gt;(t.Len()));
243:     }
244:     void DrawCursor(Document *doc, wxDC &amp;dc, Selection &amp;s, bool full, uint color, int maxcolwidth) {
245:         auto ixs = 0, iys = 0;
246:         if (!cell-&gt;tiny) sys-&gt;ImageSize(DisplayImage(), ixs, iys);
247:         if (ixs) ixs += 2;
248:         doc-&gt;PickFont(dc, cell-&gt;Depth() - doc-&gt;drawpath.size(), relsize, stylebits);
249:         auto h = dc.GetCharHeight();
250:         {
251:             auto i = 0;
252:             for (auto l = 0;; l++) {
253:                 auto start = i;
254:                 auto ls = GetLine(i, maxcolwidth);
255:                 auto len = static_cast&lt;int&gt;(ls.Len());
256:                 auto end = start + len;
257:                 if (s.cursor != s.cursorend) {
258:                     if (s.cursor &lt;= end &amp;&amp; s.cursorend &gt;= start) {
259:                         ls.Truncate(min(s.cursorend, end) - start);
260:                         auto x1 = 0, x2 = 0;
261:                         dc.GetTextExtent(ls, &amp;x2, nullptr);
262:                         ls.Truncate(max(s.cursor, start) - start);
263:                         dc.GetTextExtent(ls, &amp;x1, nullptr);
264:                         if (x1 != x2) {
265:                             int startx = cell-&gt;GetX(doc) + x1 + 2 + ixs + g_margin_extra;
266:                             int starty =
267:                                 cell-&gt;GetY(doc) + l * h + 1 + cell-&gt;ycenteroff + g_margin_extra;
268:                             DrawRectangle(dc, color, startx, starty, x2 - x1, h - 1, true);
269:                             HintIMELocation(doc, startx, starty, h - 1, stylebits);
270:                         }
271:                     }
272:                 } else if (s.cursor &gt;= start &amp;&amp; s.cursor &lt;= end) {
273:                     ls.Truncate(s.cursor - start);
274:                     auto x = 0;
275:                     dc.GetTextExtent(ls, &amp;x, nullptr);
276:                     int startx = cell-&gt;GetX(doc) + x + 1 + ixs + g_margin_extra;
277:                     int starty = cell-&gt;GetY(doc) + l * h + 1 + cell-&gt;ycenteroff + g_margin_extra;
278:                     DrawRectangle(dc, color, startx, starty, 2, h - 2);
279:                     HintIMELocation(doc, startx, starty, h - 2, stylebits);
280:                     break;
281:                 }
282:                 if (!len) break;
283:             }
284:         }
285:     }
286:     void ExpandToWord(Selection &amp;s) {
287:         if (!wxIsalnum(t[s.cursor])) return;
288:         while (s.cursor &gt; 0 &amp;&amp; wxIsalnum(t[s.cursor - 1])) s.cursor--;
289:         while (s.cursorend &lt; static_cast&lt;int&gt;(t.Len()) &amp;&amp; wxIsalnum(t[s.cursorend])) s.cursorend++;
290:     }
291:     void SelectWord(Selection &amp;s) {
292:         if (s.cursor &gt;= static_cast&lt;int&gt;(t.Len())) return;
293:         s.cursorend = s.cursor + 1;
294:         ExpandToWord(s);
295:     }
296:     void SelectWordBefore(Selection &amp;s) {
297:         if (s.cursor &lt;= 1) return;
298:         s.cursorend = s.cursor--;
299:         ExpandToWord(s);
300:     }
301:     bool RangeSelRemove(Selection &amp;s) {
302:         WasEdited();
303:         if (s.cursor != s.cursorend) {
304:             t.Remove(s.cursor, s.cursorend - s.cursor);
305:             s.cursorend = s.cursor;
306:             return true;
307:         }
308:         return false;
309:     }
310:     void SetRelSize(Selection &amp;s) {
311:         if (t.Len() || !cell-&gt;parent) return;
312:         int dd[] = {0, 1, 1, 0, 0, -1, -1, 0};
313:         for (auto i = 0; i &lt; 4; i++) {
314:             auto x = max(0, min(s.x + dd[i * 2], s.grid-&gt;xs - 1));
315:             auto y = max(0, min(s.y + dd[i * 2 + 1], s.grid-&gt;ys - 1));
316:             auto c = s.grid-&gt;C(x, y);
317:             if (c-&gt;text.t.Len()) {
318:                 relsize = c-&gt;text.relsize;
319:                 break;
320:             }
321:         }
322:     }
323:     auto Insert(Document *doc, const auto &amp;ins, Selection &amp;s, bool keeprelsize) {
324:         auto prevl = t.Len();
325:         if (!s.TextEdit()) Clear(doc, s);
326:         RangeSelRemove(s);
327:         if (!prevl &amp;&amp; !keeprelsize) SetRelSize(s);
328:         t.insert(s.cursor, ins);
329:         s.cursor = s.cursorend = s.cursor + static_cast&lt;int&gt;(ins.Len());
330:     }
331:     void Key(Document *doc, int k, Selection &amp;s) {
332:         wxString ins;
333:         ins += k;
334:         Insert(doc, ins, s, false);
335:     }
336:     void Delete(Selection &amp;s) {
337:         if (!RangeSelRemove(s))
338:             if (s.cursor &lt; static_cast&lt;int&gt;(t.Len())) { t.Remove(s.cursor, 1); };
339:     }
340:     void Backspace(Selection &amp;s) {
341:         if (!RangeSelRemove(s))
342:             if (s.cursor &gt; 0) {
343:                 t.Remove(--s.cursor, 1);
344:                 --s.cursorend;
345:             };
346:     }
347:     void DeleteWord(Selection &amp;s) {
348:         SelectWord(s);
349:         Delete(s);
350:     }
351:     void BackspaceWord(Selection &amp;s) {
352:         SelectWordBefore(s);
353:         Backspace(s);
354:     }
355:     void ReplaceStr(const wxString &amp;str, const wxString &amp;lstr) {
356:         if (sys-&gt;casesensitivesearch) {
357:             for (auto i = 0, j = 0; (j = t.Mid(i).Find(sys-&gt;searchstring)) &gt;= 0;) {
358:                 // does this need WasEdited()?
359:                 i += j;
360:                 t.Remove(i, sys-&gt;searchstring.Len());
361:                 t.insert(i, str);
362:                 i += str.Len();
363:             }
364:         } else {
365:             auto lowert = t.Lower();
366:             for (auto i = 0, j = 0; (j = lowert.Mid(i).Find(sys-&gt;searchstring)) &gt;= 0;) {
367:                 // does this need WasEdited()?
368:                 i += j;
369:                 lowert.Remove(i, sys-&gt;searchstring.Len());
370:                 t.Remove(i, sys-&gt;searchstring.Len());
371:                 lowert.insert(i, lstr);
372:                 t.insert(i, str);
373:                 i += str.Len();
374:             }
375:         }
376:     }
377:     void Clear(Document *doc, Selection &amp;s) {
378:         t.Clear();
379:         s.EnterEdit(doc);
380:     }
381:     void HomeEnd(Selection &amp;s, bool home) {
382:         auto i = 0;
383:         auto cw = cell-&gt;ColWidth();
384:         auto findwhere = home ? s.cursor : s.cursorend;
385:         for (;;) {
386:             auto start = i;
387:             auto curl = GetLine(i, cw);
388:             if (!curl.Len()) break;
389:             auto end = i == t.Len() ? i : i - 1;
390:             if (findwhere &gt;= start &amp;&amp; findwhere &lt;= end) {
391:                 s.cursor = s.cursorend = home ? start : end;
392:                 break;
393:             }
394:         }
395:     }
396:     void Save(wxDataOutputStream &amp;dos) const {
397:         dos.WriteString(t.wx_str());
398:         dos.Write32(relsize);
399:         dos.Write32(image ? image-&gt;savedindex : -1);
400:         dos.Write32(stylebits);
401:         wxLongLong le = lastedit.GetValue();
402:         dos.Write64(&amp;le, 1);
403:     }
404:     void Load(wxDataInputStream &amp;dis) {
405:         t = dis.ReadString();
406:         // if (t.length() &gt; 10000)
407:         //    printf(&quot;&quot;);
408:         if (sys-&gt;versionlastloaded &lt;= 11) dis.Read32();  // numlines
409:         relsize = dis.Read32();
410:         int i = dis.Read32();
411:         image = i &gt;= 0 ? sys-&gt;imagelist[sys-&gt;loadimageids[i]].get() : nullptr;
412:         if (sys-&gt;versionlastloaded &gt;= 7) stylebits = dis.Read32();
413:         wxLongLong time;
414:         if (sys-&gt;versionlastloaded &gt;= 14) {
415:             dis.Read64(&amp;time, 1);
416:         } else {
417:             time = sys-&gt;fakelasteditonload--;
418:         }
419:         lastedit = wxDateTime(time);
420:     }
421:     auto Eval(auto &amp;ev) const {
422:         switch (cell-&gt;celltype) {
423:             // Load variable&apos;s data.
424:             case CT_VARU: {
425:                 auto v = ev.Lookup(t);
426:                 if (!v) {
427:                     v = cell-&gt;Clone(nullptr);
428:                     v-&gt;celltype = CT_DATA;
429:                     v-&gt;text.t = &quot;**Variable Load Error**&quot;;
430:                 }
431:                 return v;
432:             }
433:             // Return our current data.
434:             case CT_DATA: return cell-&gt;Clone(nullptr);
435:             default: return unique_ptr&lt;Cell&gt;();
436:         }
437:     }
438: };</file><file path="src/threadpool.h"> 1: class ThreadPool {
 2:     public:
 3:     ThreadPool(size_t);
 4:     template&lt;class F, class... Args&gt;
 5:     auto enqueue(F&amp;&amp; f, Args&amp;&amp;... args)
 6:         -&gt; std::future&lt;typename std::invoke_result&lt;F, Args...&gt;::type&gt;;
 7:     ~ThreadPool();
 8:     private:
 9:     // need to keep track of threads so we can join them
10:     std::vector&lt;std::thread&gt; workers;
11:     // the task queue
12:     std::queue&lt;std::function&lt;void()&gt;&gt; tasks;
13:     // synchronization
14:     std::mutex queue_mutex;
15:     std::condition_variable condition;
16:     bool stop;
17: };
18: // the constructor just launches some amount of workers
19: inline ThreadPool::ThreadPool(size_t threads) : stop(false) {
20:     for (size_t i = 0; i &lt; threads; ++i)
21:         workers.emplace_back([this] {
22:             for (;;) {
23:                 std::function&lt;void()&gt; task;
24:                 {
25:                     std::unique_lock&lt;std::mutex&gt; lock(this-&gt;queue_mutex);
26:                     this-&gt;condition.wait(lock,
27:                                          [this] { return this-&gt;stop || !this-&gt;tasks.empty(); });
28:                     if (this-&gt;stop &amp;&amp; this-&gt;tasks.empty()) return;
29:                     task = std::move(this-&gt;tasks.front());
30:                     this-&gt;tasks.pop();
31:                 }
32:                 task();
33:             }
34:         });
35: }
36: // add new work item to the pool
37: template&lt;class F, class... Args&gt;
38: auto ThreadPool::enqueue(F&amp;&amp; f, Args&amp;&amp;... args)
39:     -&gt; std::future&lt;typename std::invoke_result&lt;F, Args...&gt;::type&gt; {
40:     using return_type = typename std::invoke_result&lt;F, Args...&gt;::type;
41:     auto task = std::make_shared&lt;std::packaged_task&lt;return_type()&gt;&gt;(
42:         std::bind(std::forward&lt;F&gt;(f), std::forward&lt;Args&gt;(args)...));
43:     std::future&lt;return_type&gt; res = task-&gt;get_future();
44:     {
45:         std::unique_lock&lt;std::mutex&gt; lock(queue_mutex);
46:         // don&apos;t allow enqueueing after stopping the pool
47:         assert(!stop);
48:         tasks.emplace([task]() { (*task)(); });
49:     }
50:     condition.notify_one();
51:     return res;
52: }
53: // the destructor joins all threads
54: inline ThreadPool::~ThreadPool() {
55:     {
56:         std::unique_lock&lt;std::mutex&gt; lock(queue_mutex);
57:         stop = true;
58:     }
59:     condition.notify_all();
60:     for (std::thread&amp; worker : workers) worker.join();
61: }</file><file path="src/tools.h">  1: typedef unsigned char uchar;
  2: typedef unsigned short ushort;
  3: typedef unsigned int uint;
  4: #ifdef _DEBUG
  5: #define ASSERT(c) assert(c)
  6: #else
  7: #define ASSERT(c) \
  8:     if (c) {}
  9: #endif
 10: #define loop(i, m) for (int i = 0; i &lt; int(m); i++)
 11: #define loopv(i, v) for (int i = 0; i &lt; (v).size(); i++)
 12: #define loopvrev(i, v) for (int i = (v).size() - 1; i &gt;= 0; i--)
 13: #define max(a, b) ((a) &lt; (b) ? (b) : (a))
 14: #define min(a, b) ((a) &gt; (b) ? (b) : (a))
 15: #define sign(x) ((x) &lt; 0 ? -1 : 1)
 16: #define varargs(v, fmt, body) \
 17:     {                         \
 18:         va_list v;            \
 19:         va_start(v, fmt);     \
 20:         body;                 \
 21:         va_end(v);            \
 22:     }
 23: #define DELETEP(p)       \
 24:     {                    \
 25:         if (p) {         \
 26:             delete p;    \
 27:             p = nullptr; \
 28:         }                \
 29:     }
 30: #define DELETEA(a)       \
 31:     {                    \
 32:         if (a) {         \
 33:             delete[] a;  \
 34:             a = nullptr; \
 35:         }                \
 36:     }
 37: #define bound(v, a, s, e)     \
 38:     {                         \
 39:         v += a;               \
 40:         if (v &gt; (e)) v = (e); \
 41:         if (v &lt; (s)) v = (s); \
 42:     }
 43: // Use the same on all platforms, because:
 44: // Win32: usually contains both.
 45: // Macos: older versions use \r and newer \n in clipboard?
 46: // Linux: should only ever be \n but if we encounter \r we want to strip it.
 47: #ifdef __WXGTK__
 48:     #define LINE_SEPARATOR L&quot;\r\n&quot;
 49: #else
 50:     #define LINE_SEPARATOR L&quot;\n&quot;
 51: #endif
 52: #ifdef WIN32
 53: #define PATH_SEPARATOR L&quot;\\&quot;
 54: #else
 55: #define PATH_SEPARATOR L&quot;/&quot;
 56: #define __cdecl
 57: #define _vsnprintf vsnprintf
 58: #endif
 59: template&lt;class T&gt; inline void swap_(T &amp;a, T &amp;b) {
 60:     T c = a;
 61:     a = b;
 62:     b = c;
 63: };
 64: #ifdef WIN32
 65: #pragma warning(3 : 4189)        // local variable is initialized but not referenced
 66: #pragma warning(disable : 4244)  // conversion from &apos;int&apos; to &apos;float&apos;, possible loss of data
 67: #pragma warning(disable : 4355)  // &apos;this&apos; : used in base member initializer list
 68: #pragma warning(disable : 4996)  // &apos;strncpy&apos; was declared deprecated
 69: #endif
 70: inline uchar *loadfile(const char *fn, size_t *lenret = nullptr) {
 71:     FILE *f = fopen(fn, &quot;rb&quot;);
 72:     if (!f) return nullptr;
 73:     fseek(f, 0, SEEK_END);
 74:     size_t len = ftell(f);
 75:     fseek(f, 0, SEEK_SET);
 76:     uchar *buf = (uchar *)malloc(len + 1);
 77:     if (!buf) {
 78:         fclose(f);
 79:         return nullptr;
 80:     }
 81:     buf[len] = 0;
 82:     size_t rlen = fread(buf, 1, len, f);
 83:     fclose(f);
 84:     if (len != rlen || len &lt;= 0) {
 85:         free(buf);
 86:         return nullptr;
 87:     }
 88:     if (lenret) *lenret = len;
 89:     return buf;
 90: }
 91: // for use with vc++ crtdbg
 92: #if defined(_DEBUG) &amp;&amp; defined(_WIN32)
 93: inline void *__cdecl operator new(size_t n, const char *fn, int l) {
 94:     return ::operator new(n, 1, fn, l);
 95: }
 96: inline void *__cdecl operator new[](size_t n, const char *fn, int l) {
 97:     return ::operator new[](n, 1, fn, l);
 98: }
 99: inline void __cdecl operator delete(void *p, const char *fn, int l) {
100:     ::operator delete(p, 1, fn, l);
101: }
102: inline void __cdecl operator delete[](void *p, const char *fn, int l) {
103:     ::operator delete[](p, 1, fn, l);
104: }
105: #define new new (__FILE__, __LINE__)
106: #endif
107: inline uint64_t FNV1A64(uint8_t *data, size_t size) {
108:     uint64_t hash = 0xCBF29CE484222325;
109:     for (size_t i = 0; i &lt; size; ++i) {
110:         hash ^= data[i];
111:         hash *= 0x100000001B3;
112:     }
113:     return hash;
114: }</file><file path="src/treesheets_impl.h">  1: struct TreeSheetsScriptImpl : public ScriptInterface {
  2:     Document *document = nullptr;
  3:     Cell *current = nullptr;
  4:     Cell *lowestcommonancestor = nullptr;
  5:     enum { max_new_grid_cells = 256 * 256 };  // Don&apos;t allow crazy sizes.
  6:     void SwitchToCurrentDocument() {
  7:         document = sys-&gt;frame-&gt;GetCurrentTab()-&gt;doc;
  8:         current = document-&gt;root;
  9:         lowestcommonancestor = nullptr;
 10:     }
 11:     void AddUndoIfNecessary() {
 12:         if (!lowestcommonancestor) {
 13:             UpdateLowestCommonAncestor(true);
 14:         } else {
 15:             for (auto p = current; p; p = p-&gt;parent) {
 16:                 if (p == lowestcommonancestor) {
 17:                     // There is no need to add current to the undo stack as
 18:                     // lowestcommonancestor including subordinated current
 19:                     // is already in there.
 20:                     return;
 21:                 }
 22:             }
 23:             UpdateLowestCommonAncestor(false);
 24:         }
 25:     }
 26:     void UpdateLowestCommonAncestor(bool newgeneration) {
 27:         // Use parent as lowestcommonancestor so changes to siblings are already covered
 28:         lowestcommonancestor = current-&gt;parent;
 29:         document-&gt;AddUndo(lowestcommonancestor, newgeneration);
 30:     }
 31:     std::string ScriptRun(const char *filename) {
 32:         SwitchToCurrentDocument();
 33:         bool dump_builtins = false;
 34:         #ifdef _DEBUG
 35:             //dump_builtins = true;
 36:         #endif
 37:         auto errormessage = RunLobster(filename, {}, dump_builtins);
 38:         document-&gt;root-&gt;ResetChildren();
 39:         document-&gt;canvas-&gt;Refresh();
 40:         document = nullptr;
 41:         current = nullptr;
 42:         return errormessage;
 43:     }
 44:     bool LoadDocument(const char *filename) {
 45:         auto message = sys-&gt;LoadDB(filename);
 46:         if (*message) return false;
 47:         SwitchToCurrentDocument();
 48:         return true;
 49:     }
 50:     void GoToRoot() { current = document-&gt;root; }
 51:     void GoToView() { current = document-&gt;currentdrawroot; }
 52:     bool HasSelection() { return document-&gt;selected.grid; }
 53:     void GoToSelection() {
 54:         auto cell = document-&gt;selected.GetFirst();
 55:         if (cell) current = cell;
 56:     }
 57:     bool HasParent() { return current-&gt;parent; }
 58:     void GoToParent() {
 59:         if (current-&gt;parent) current = current-&gt;parent;
 60:     }
 61:     int NumChildren() { return current-&gt;grid ? current-&gt;grid-&gt;xs * current-&gt;grid-&gt;ys : 0; }
 62:     icoord NumColumnsRows() {
 63:         return current-&gt;grid ? icoord(current-&gt;grid-&gt;xs, current-&gt;grid-&gt;ys) : icoord(0, 0);
 64:     }
 65:     int GetColWidth() { return current-&gt;parent ? current-&gt;parent-&gt;grid-&gt;GetColWidth(current) : 0; }
 66:     void SetColWidth(int w) {
 67:         if (current-&gt;parent) { current-&gt;parent-&gt;grid-&gt;SetColWidth(current, w); }
 68:     }
 69:     ibox SelectionBox() {
 70:         auto &amp;selection = document-&gt;selected;
 71:         return selection.grid ? ibox(icoord(selection.x, selection.y), icoord(selection.xs, selection.ys))
 72:                       : ibox(icoord(0, 0), icoord(0, 0));
 73:     }
 74:     void GoToChild(int n) {
 75:         if (current-&gt;grid &amp;&amp; n &lt; current-&gt;grid-&gt;xs * current-&gt;grid-&gt;ys)
 76:             current = current-&gt;grid-&gt;cells[n];
 77:     }
 78:     void GoToColumnRow(int x, int y) {
 79:         if (current-&gt;grid &amp;&amp; x &lt; current-&gt;grid-&gt;xs &amp;&amp; y &lt; current-&gt;grid-&gt;ys)
 80:             current = current-&gt;grid-&gt;C(x, y);
 81:     }
 82:     std::string GetText() { return current-&gt;text.t.utf8_string(); }
 83:     void SetText(std::string_view t) {
 84:         if (current-&gt;parent) {
 85:             AddUndoIfNecessary();
 86:             current-&gt;text.t = wxString::FromUTF8(t.data(), t.size());
 87:         }
 88:     }
 89:     void CreateGrid(int x, int y) {
 90:         if (x &gt; 0 &amp;&amp; y &gt; 0 &amp;&amp; x * y &lt; max_new_grid_cells) {
 91:             AddUndoIfNecessary();
 92:             current-&gt;AddGrid(x, y);
 93:         }
 94:     }
 95:     void InsertColumn(int x) {
 96:         if (current-&gt;grid &amp;&amp; x &gt;= 0 &amp;&amp; x &lt;= current-&gt;grid-&gt;xs) {
 97:             AddUndoIfNecessary();
 98:             current-&gt;grid-&gt;InsertCells(x, -1, 1, 0);
 99:         }
100:     }
101:     void InsertRow(int y) {
102:         if (current-&gt;grid &amp;&amp; y &gt;= 0 &amp;&amp; y &lt;= current-&gt;grid-&gt;ys) {
103:             AddUndoIfNecessary();
104:             current-&gt;grid-&gt;InsertCells(-1, y, 0, 1);
105:         }
106:     }
107:     void Delete(int x, int y, int xs, int ys) {
108:         if (current-&gt;grid &amp;&amp; x &gt;= 0 &amp;&amp; x + xs &lt;= current-&gt;grid-&gt;xs &amp;&amp; y &gt;= 0 &amp;&amp;
109:             y + ys &lt;= current-&gt;grid-&gt;ys) {
110:             AddUndoIfNecessary();
111:             Selection s(current-&gt;grid, x, y, xs, ys);
112:             current-&gt;grid-&gt;MultiCellDeleteSub(document, s);
113:             document-&gt;SetSelect(Selection());
114:             document-&gt;Zoom(-100);
115:         }
116:     }
117:     void SetBackgroundColor(uint color) {
118:         AddUndoIfNecessary();
119:         current-&gt;cellcolor = color;
120:     }
121:     void SetTextColor(uint color) {
122:         AddUndoIfNecessary();
123:         current-&gt;textcolor = color;
124:     }
125:     void SetTextFiltered(bool filtered) {
126:         if (current-&gt;parent) {
127:             AddUndoIfNecessary();
128:             current-&gt;text.filtered = filtered;
129:         }
130:     }
131:     bool IsTextFiltered() { return current-&gt;text.filtered; }
132:     void SetBorderColor(uint color) {
133:         if (current-&gt;grid) {
134:             AddUndoIfNecessary();
135:             current-&gt;grid-&gt;bordercolor = color;
136:         }
137:     }
138:     int GetRelativeSize() { return -current-&gt;text.relsize; }
139:     void SetRelativeSize(int relsize) {
140:         AddUndoIfNecessary();
141:         current-&gt;text.relsize = -relsize;
142:     }
143:     void SetStyle(int stylebits) {
144:         AddUndoIfNecessary();
145:         current-&gt;text.stylebits = stylebits;
146:     }
147:     int GetStyle() { return current-&gt;text.stylebits; }
148:     void SetStatusMessage(std::string_view message) {
149:         auto ws = wxString(message.data(), message.size());
150:         sys-&gt;frame-&gt;SetStatus(ws);
151:     }
152:     void SetWindowSize(int width, int height) { sys-&gt;frame-&gt;SetSize(width, height); }
153:     std::string GetFileNameFromUser(bool is_save) {
154:         int flags = wxFD_CHANGE_DIR;
155:         if (is_save)
156:             flags |= wxFD_OVERWRITE_PROMPT | wxFD_SAVE;
157:         else
158:             flags |= wxFD_OPEN | wxFD_FILE_MUST_EXIST;
159:         wxString fn = ::wxFileSelector(_(L&quot;Choose file:&quot;), L&quot;&quot;, L&quot;&quot;, L&quot;&quot;, L&quot;*.*&quot;, flags);
160:         return fn.utf8_string();
161:     }
162:     std::string GetFileName() { return document-&gt;filename.utf8_string(); }
163:     int64_t GetLastEdit() { return current-&gt;text.lastedit.GetValue().GetValue(); }
164:     bool IsTag() { return current-&gt;IsTag(document); }
165: };
166: static int64_t TreeSheetsLoader(string_view_nt absfilename, std::string *dest, int64_t start,
167:                                 int64_t len) {
168:     size_t l = 0;
169:     auto buf = (char *)loadfile(absfilename.c_str(), &amp;l);
170:     if (!buf) return -1;
171:     dest-&gt;assign(buf, l);
172:     free(buf);
173:     return l;
174: }
175: static TreeSheetsScriptImpl tssi;
176: static string ScriptInit(const wxString &amp;datapath) {
177:     return InitLobster(&amp;tssi, datapath, &quot;&quot;, false, TreeSheetsLoader);
178: }</file><file path="src/tsapp.h">  1: struct IPCServer : wxServer {
  2:     wxConnectionBase *OnAcceptConnection(const wxString &amp;topic) {
  3:         sys-&gt;frame-&gt;DeIconize();
  4:         if (topic.Len() &amp;&amp; topic != L&quot;*&quot;) sys-&gt;Open(topic);
  5:         return new wxConnection();
  6:     }
  7: };
  8: struct TSApp : wxApp {
  9:     TSFrame *frame {nullptr};
 10:     unique_ptr&lt;IPCServer&gt; serv {make_unique&lt;IPCServer&gt;()};
 11:     wxString service {
 12:         #ifdef __WXMSW__
 13:                 L&quot;4242&quot;
 14:         #else
 15:                 L&quot;/tmp/TreeSheets-socket&quot;
 16:         #endif
 17:     };
 18:     wxString filename;
 19:     bool initiateventloop {false};
 20:     wxString exename;
 21:     wxString exepath;
 22:     unique_ptr&lt;wxSingleInstanceChecker&gt; instance_checker {nullptr};
 23:     bool OnInit() override {
 24:         #if wxUSE_UNICODE == 0
 25:             #error &quot;must use unicode version of wx libs to ensure data integrity of .cts files&quot;
 26:         #endif
 27:         ASSERT(wxUSE_UNICODE);
 28:         exename = GetExecutablePath();
 29:         exepath = wxFileName(exename).GetPath();
 30:         #if defined(__WXMAC__)
 31:             int cut = exepath.Find(&quot;/MacOS&quot;);
 32:             if (cut &gt; 0) { exepath = exepath.SubString(0, cut) + &quot;/Resources&quot;; }
 33:             wxDisableAsserts();
 34:             // wxSystemOptions::SetOption(&quot;mac.toolbar.no-native&quot;, 1);
 35:         #elif defined(__WXMSW__)
 36:             DeclareHiDpiAwareOnWindows();
 37:         #endif
 38:         bool portable = false;
 39:         bool single_instance = true;
 40:         bool dump_builtins = false;
 41:         for (int i = 1; i &lt; argc; i++) {
 42:             if (argv[i][0] == &apos;-&apos;) {
 43:                 switch (static_cast&lt;int&gt;(argv[i][1])) {
 44:                     case &apos;p&apos;: portable = true; break;
 45:                     case &apos;i&apos;: single_instance = false; break;
 46:                     case &apos;d&apos;:
 47:                         dump_builtins = true;
 48:                         single_instance = false;
 49:                         break;
 50:                 }
 51:             } else {
 52:                 filename = argv[i];
 53:             }
 54:         }
 55:         if (single_instance) {
 56:             instance_checker.reset(new wxSingleInstanceChecker(
 57:                 wxTheApp-&gt;GetAppName() + &apos;-&apos; + wxGetUserId(), wxStandardPaths::Get().GetTempDir()));
 58:             if (instance_checker-&gt;IsAnotherRunning()) {
 59:                 wxClient client;
 60:                 client.MakeConnection(
 61:                     L&quot;localhost&quot;, service,
 62:                     filename.Len() ? filename.wc_str() : L&quot;*&quot;);  // fire and forget
 63:                 return false;
 64:             }
 65:         }
 66:         wxStandardPaths::Get().SetFileLayout(wxStandardPathsBase::FileLayout_XDG);
 67:         sys = new System(portable);
 68:         SetupInternationalization();
 69:         frame = new TSFrame(this);
 70:         #ifdef ENABLE_LOBSTER
 71:             auto serr = ScriptInit(GetDataPath(&quot;scripts/&quot;));
 72:             if (!serr.empty()) {
 73:                 wxLogFatalError(L&quot;Script system could not initialize: %s&quot;, serr);
 74:                 return false;
 75:             }
 76:         #endif
 77:         if (dump_builtins) {
 78:             #ifdef ENABLE_LOBSTER
 79:                 TSDumpBuiltinDoc();
 80:             #endif
 81:             return false;
 82:         }
 83:         SetTopWindow(frame);
 84:         serv-&gt;Create(service);
 85:         return true;
 86:     }
 87:     void OnEventLoopEnter(wxEventLoopBase *WXUNUSED(loop)) override {
 88:         if (!initiateventloop) {
 89:             initiateventloop = true;
 90:             frame-&gt;AppOnEventLoopEnter();
 91:             sys-&gt;Init(filename);
 92:         }
 93:     }
 94:     #ifdef __WXMAC__
 95:         void MacOpenFiles(const wxArrayString &amp;filenames) override {
 96:             if (!sys) return;
 97:             // MacOpenFiles does not trigger OnEventLoopEnter so we need
 98:             // to do this manually
 99:             if (!initiateventloop) {
100:                 initiateventloop = true;
101:                 frame-&gt;AppOnEventLoopEnter();
102:             }
103:             for (auto &amp;fn : filenames) { sys-&gt;Init(fn); }
104:         }
105:     #endif
106:     int OnExit() override {
107:         DELETEP(sys);
108:         return 0;
109:     }
110:     wxString GetExecutablePath() {
111:         wxString executablepath = argv[0];
112:         #if defined(__WXMAC__)
113:             char path[PATH_MAX];
114:             uint32_t size = sizeof(path);
115:             if(_NSGetExecutablePath(path, &amp;size) == 0) executablepath = path;
116:         #elif defined(__WXGTK__)
117:             // argv[0] could be relative, this is apparently a more robust way to get the
118:             // full path.
119:             char path[PATH_MAX];
120:             auto len = readlink(&quot;/proc/self/exe&quot;, path, PATH_MAX - 1);
121:             if (len &gt;= 0) {
122:                 path[len] = 0;
123:                 executablepath = path;
124:             }
125:         #endif
126:         return executablepath;
127:     }
128:     void SetupInternationalization() {
129:         wxUILocale::UseDefault();
130:         #ifdef __WXGTK__
131:             wxFileTranslationsLoader::AddCatalogLookupPathPrefix(L&quot;/usr&quot;);
132:             wxFileTranslationsLoader::AddCatalogLookupPathPrefix(L&quot;/usr/local&quot;);
133:             #ifdef LOCALEDIR
134:                 wxFileTranslationsLoader::AddCatalogLookupPathPrefix(LOCALEDIR);
135:             #endif
136:             wxString prefix = wxStandardPaths::Get().GetInstallPrefix();
137:             wxFileTranslationsLoader::AddCatalogLookupPathPrefix(prefix);
138:         #endif
139:         wxFileTranslationsLoader::AddCatalogLookupPathPrefix(GetDataPath(&quot;translations&quot;));
140:         auto trans = new wxTranslations();
141:         trans-&gt;SetLanguage(sys-&gt;defaultlang);
142:         trans-&gt;AddCatalog(L&quot;ts&quot;);
143:         wxTranslations::Set(trans);
144:     }
145:     wxString GetDataPath(const wxString &amp;relpath) {
146:         std::filesystem::path candidatePaths[] = {
147:             std::filesystem::path(exepath.Length()
148:                                       ? exepath.ToStdString() + &quot;/&quot; + relpath.ToStdString()
149:                                       : relpath.ToStdString()),
150:             #ifdef TREESHEETS_DATADIR
151:                 std::filesystem::path(TREESHEETS_DATADIR &quot;/&quot; + relpath.ToStdString()),
152:             #endif
153:         };
154:         std::filesystem::path relativePath;
155:         for (auto path : candidatePaths) {
156:             relativePath = path;
157:             if (std::filesystem::exists(relativePath)) { break; }
158:         }
159:         return wxString(relativePath.c_str());
160:     }
161:     wxString GetDocPath(const wxString &amp;relpath) {
162:         std::filesystem::path candidatePaths[] = {
163:             std::filesystem::path(exepath.Length()
164:                                       ? exepath.ToStdString() + &quot;/&quot; + relpath.ToStdString()
165:                                       : relpath.ToStdString()),
166:             #ifdef TREESHEETS_DOCDIR
167:                 std::filesystem::path(TREESHEETS_DOCDIR &quot;/&quot; + relpath.ToStdString()),
168:             #endif
169:         };
170:         std::filesystem::path relativePath;
171:         for (auto path : candidatePaths) {
172:             relativePath = path;
173:             if (std::filesystem::exists(relativePath)) { break; }
174:         }
175:         return wxString(relativePath.c_str());
176:     }
177:     #ifdef __WXMSW__
178:         void DeclareHiDpiAwareOnWindows() {
179:             // wxWidgets should really be doing this itself, but it does not (or expects you to
180:             // want to use a manifest), so we try to use the most recent Windows API to declare
181:             // ourselves as HiDPI compatible.
182:             #ifndef DPI_ENUMS_DECLARED
183:                 typedef enum PROCESS_DPI_AWARENESS {
184:                     PROCESS_DPI_UNAWARE = 0,
185:                     PROCESS_SYSTEM_DPI_AWARE = 1,
186:                     PROCESS_PER_MONITOR_DPI_AWARE = 2
187:                 } PROCESS_DPI_AWARENESS;
188:             #endif
189:             using SetProcessDPIAware_T = BOOL(WINAPI *)(void);
190:             using SetProcessDpiAwareness_T = HRESULT(WINAPI *)(PROCESS_DPI_AWARENESS);
191:             using SetProcessDpiAwarenessContext_T = BOOL(WINAPI *)(DPI_AWARENESS_CONTEXT);
192:             SetProcessDPIAware_T SetProcessDPIAware = nullptr;
193:             SetProcessDpiAwareness_T SetProcessDpiAwareness = nullptr;
194:             SetProcessDpiAwarenessContext_T SetProcessDpiAwarenessContext = nullptr;
195:             HMODULE user32 = LoadLibraryA(&quot;User32.dll&quot;);
196:             HMODULE shcore = LoadLibraryA(&quot;Shcore.dll&quot;);
197:             if (user32) {
198:                 SetProcessDPIAware = (SetProcessDPIAware_T)GetProcAddress(user32, &quot;SetProcessDPIAware&quot;);
199:                 SetProcessDpiAwarenessContext = (SetProcessDpiAwarenessContext_T)GetProcAddress(
200:                     user32, &quot;SetProcessDpiAwarenessContext&quot;);
201:             }
202:             if (shcore) {
203:                 SetProcessDpiAwareness =
204:                     (SetProcessDpiAwareness_T)GetProcAddress(shcore, &quot;SetProcessDpiAwareness&quot;);
205:             }
206:             if (SetProcessDpiAwarenessContext) {
207:                 SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
208:             } else if (SetProcessDpiAwareness) {
209:                 SetProcessDpiAwareness(PROCESS_PER_MONITOR_DPI_AWARE);
210:             } else if (SetProcessDPIAware) {
211:                 SetProcessDPIAware();
212:             }
213:             if (user32) FreeLibrary(user32);
214:             if (shcore) FreeLibrary(shcore);
215:         }
216:     #endif
217:     DECLARE_EVENT_TABLE()
218: };</file><file path="src/tscanvas.h">  1: struct TSCanvas : public wxScrolledCanvas {
  2:     TSFrame *frame;
  3:     Document *doc {nullptr};
  4:     int mousewheelaccum {0};
  5:     bool lastrmbwaswithctrl {false};
  6:     wxPoint lastmousepos;
  7:     TSCanvas(TSFrame *fr, wxWindow *parent, const wxSize &amp;size = wxDefaultSize)
  8:         : wxScrolledCanvas(parent, wxID_ANY, wxDefaultPosition, size,
  9:                            wxScrolledWindowStyle | wxWANTS_CHARS | wxFULL_REPAINT_ON_RESIZE),
 10:           frame(fr) {
 11:         SetBackgroundStyle(wxBG_STYLE_PAINT);
 12:         SetBackgroundColour(*wxWHITE);
 13:         DisableKeyboardScrolling();
 14:         // Without this, canvas does its own scrolling upon mousewheel events, which
 15:         // interferes with our own.
 16:         EnableScrolling(false, false);
 17:     }
 18:     ~TSCanvas() {
 19:         DELETEP(doc);
 20:         frame = nullptr;
 21:     }
 22:     void OnPaint(wxPaintEvent &amp;event) {
 23:         #ifdef __WXMSW__
 24:             auto sz = GetClientSize();
 25:             if (sz.GetX() &lt;= 0 || sz.GetY() &lt;= 0) return;
 26:             wxBitmap bmp;
 27:             auto sf = GetDPIScaleFactor();
 28:             bmp.CreateWithDIPSize(sz, sf, 24);
 29:             wxBufferedPaintDC dc(this, bmp);
 30:         #else
 31:             wxPaintDC dc(this);
 32:         #endif
 33:         DoPrepareDC(dc);
 34:         doc-&gt;Draw(dc);
 35:     };
 36:     void OnMotion(wxMouseEvent &amp;me) {
 37:         wxClientDC dc(this);  // TODO: replace with wxInfoDC starting wxWidgets 3.3.0
 38:         doc-&gt;UpdateHover(dc, me.GetX(), me.GetY());
 39:         if (me.LeftIsDown() || me.RightIsDown()) {
 40:             if (me.AltDown() &amp;&amp; me.ShiftDown()) {
 41:                 doc-&gt;Copy(A_DRAGANDDROP);
 42:                 Refresh();
 43:             } else {
 44:                 if (doc-&gt;isctrlshiftdrag) {
 45:                     doc-&gt;begindrag = doc-&gt;hover;
 46:                 } else if (!doc-&gt;hover.Thin()) {
 47:                     if (doc-&gt;begindrag.Thin() || doc-&gt;selected.Thin()) {
 48:                         doc-&gt;SetSelect(doc-&gt;hover);
 49:                         doc-&gt;ResetCursor();
 50:                         Refresh();
 51:                     } else {
 52:                         Selection old = doc-&gt;selected;
 53:                         doc-&gt;selected.Merge(doc-&gt;begindrag, doc-&gt;hover);
 54:                         if (!(old == doc-&gt;selected)) {
 55:                             doc-&gt;ResetCursor();
 56:                             Refresh();
 57:                         }
 58:                     }
 59:                 }
 60:             }
 61:             sys-&gt;frame-&gt;UpdateStatus(doc-&gt;selected);
 62:         } else if (me.MiddleIsDown()) {
 63:             wxPoint p = me.GetPosition() - lastmousepos;
 64:             CursorScroll(-p.x, -p.y);
 65:         } else {
 66:             if (doc-&gt;hover != doc-&gt;prev &amp;&amp; !doc-&gt;hover.Thin()) sys-&gt;frame-&gt;UpdateStatus(doc-&gt;hover);
 67:         }
 68:         lastmousepos = me.GetPosition();
 69:     }
 70:     void SelectClick(int mx, int my, bool right, int isctrlshift) {
 71:         wxClientDC dc(this);  // TODO: replace with wxInfoDC starting wxWidgets 3.3.0
 72:         if (mx &lt; 0 || my &lt; 0)
 73:             return;  // for some reason, using just the &quot;menu&quot; key sends a right-click at (-1, -1)
 74:         doc-&gt;isctrlshiftdrag = isctrlshift;
 75:         doc-&gt;UpdateHover(dc, mx, my);
 76:         doc-&gt;SelectClick(right);
 77:         sys-&gt;frame-&gt;UpdateStatus(doc-&gt;selected);
 78:         Refresh();
 79:     }
 80:     void OnLeftDown(wxMouseEvent &amp;me) {
 81:         #ifndef __WXMSW__
 82:         // seems to not want to give the canvas focus otherwise (thinks its already in focus
 83:         // when its not?)
 84:         if (frame-&gt;filter) frame-&gt;filter-&gt;SetFocus();
 85:         #endif
 86:         SetFocus();
 87:         if (me.ShiftDown())
 88:             OnMotion(me);
 89:         else
 90:             SelectClick(me.GetX(), me.GetY(), false, me.CmdDown() + me.AltDown() * 2);
 91:     }
 92:     void OnLeftUp(wxMouseEvent &amp;me) {
 93:         if (me.CmdDown() || me.AltDown()) {
 94:             wxClientDC dc(this);  // TODO: replace with wxInfoDC starting wxWidgets 3.3.0
 95:             doc-&gt;UpdateHover(dc, me.GetX(), me.GetY());
 96:             doc-&gt;SelectUp();
 97:             sys-&gt;frame-&gt;UpdateStatus(doc-&gt;selected);
 98:             Refresh();
 99:         }
100:     }
101:     void OnRightDown(wxMouseEvent &amp;me) {
102:         SetFocus();
103:         SelectClick(me.GetX(), me.GetY(), true, 0);
104:         lastrmbwaswithctrl = me.CmdDown();
105:         #ifndef __WXMSW__
106:         me.Skip();  // otherwise EVT_CONTEXT_MENU won&apos;t be triggered?
107:         #endif
108:     }
109:     void OnLeftDoubleClick(wxMouseEvent &amp;me) {
110:         wxClientDC dc(this);  // TODO: replace with wxInfoDC starting wxWidgets 3.3.0
111:         doc-&gt;UpdateHover(dc, me.GetX(), me.GetY());
112:         doc-&gt;DoubleClick();
113:         sys-&gt;frame-&gt;UpdateStatus(doc-&gt;selected);
114:         Refresh();
115:     }
116:     void OnKeyDown(wxKeyEvent &amp;ce) { ce.Skip(); }
117:     void OnChar(wxKeyEvent &amp;ce) {
118:         /*
119:         if (sys-&gt;insidefiledialog)
120:         {
121:             ce.Skip();
122:             return;
123:         }
124:         */
125:         #ifndef __WXMAC__
126:             // Without this check, Alt+[Alphanumericals], Alt+Shift+[Alphanumericals] and
127:             // Alt+[Shift]+cursor (scrolling) don&apos;t work. The 128 makes sure unicode entry on e.g.
128:             // Polish keyboards still works. (on Linux in particular).
129:             if ((ce.GetModifiers() == wxMOD_ALT || ce.GetModifiers() == (wxMOD_ALT | wxMOD_SHIFT)) &amp;&amp;
130:                 (ce.GetUnicodeKey() &lt; 128)) {
131:                 ce.Skip();
132:                 return;
133:             }
134:         #endif
135:         bool unprocessed = false;
136:         sys-&gt;frame-&gt;SetStatus(doc-&gt;Key(ce.GetUnicodeKey(), ce.GetKeyCode(), ce.AltDown(),
137:                                        ce.CmdDown(), ce.ShiftDown(), unprocessed));
138:         if (unprocessed) ce.Skip();
139:     }
140:     void OnMouseWheel(wxMouseEvent &amp;me) {
141:         bool ctrl = me.CmdDown();
142:         if (sys-&gt;zoomscroll) ctrl = !ctrl;
143:         if (me.AltDown() || ctrl || me.ShiftDown()) {
144:             mousewheelaccum += me.GetWheelRotation();
145:             int steps = mousewheelaccum / me.GetWheelDelta();
146:             if (!steps) return;
147:             mousewheelaccum -= steps * me.GetWheelDelta();
148:             sys-&gt;frame-&gt;SetStatus(doc-&gt;Wheel(steps, me.AltDown(), ctrl, me.ShiftDown()));
149:         } else if (me.GetWheelAxis()) {
150:             CursorScroll(me.GetWheelRotation() * g_scrollratewheel, 0);
151:         } else {
152:             CursorScroll(0, -me.GetWheelRotation() * g_scrollratewheel);
153:         }
154:     }
155:     void OnSize(wxSizeEvent &amp;se) {}
156:     void OnContextMenuClick(wxContextMenuEvent &amp;cme) {
157:         if (lastrmbwaswithctrl) {
158:             auto tagmenu = make_unique&lt;wxMenu&gt;();
159:             doc-&gt;RecreateTagMenu(*tagmenu);
160:             PopupMenu(tagmenu.get());
161:         } else {
162:             PopupMenu(frame-&gt;editmenupopup);
163:         }
164:     }
165:     void OnScrollWin(wxScrollWinEvent &amp;swe) {
166:         // This only gets called when scrolling using the scroll bar, not with mousewheel.
167:         swe.Skip();  // Use default scrolling behavior.
168:     }
169:     void CursorScroll(int dx, int dy) {
170:         int x, y;
171:         GetViewStart(&amp;x, &amp;y);
172:         x += dx;
173:         y += dy;
174:         // EnableScrolling(true, true);
175:         Scroll(x, y);
176:         // EnableScrolling(false, false);
177:     }
178:     DECLARE_EVENT_TABLE()
179: };</file><file path="src/tsframe.h">   1: struct TSFrame : wxFrame {
   2:     TSApp *app;
   3:     wxIcon icon;
   4:     wxTaskBarIcon taskbaricon;
   5:     wxMenu *editmenupopup;
   6:     wxFileHistory filehistory;
   7:     #ifdef ENABLE_LOBSTER
   8:         wxFileHistory scripts {A_MAXACTION - A_SCRIPT, A_SCRIPT};
   9:     #endif
  10:     wxFileSystemWatcher *watcher;
  11:     wxAuiNotebook *notebook {nullptr};
  12:     wxAuiManager aui {this};
  13:     wxBitmap line_nw;
  14:     wxBitmap line_sw;
  15:     wxBitmap foldicon;
  16:     bool fromclosebox {true};
  17:     bool watcherwaitingforuser {false};
  18:     wxColour toolbarbackgroundcolor {0xD8C7BC};
  19:     wxTextCtrl *filter {nullptr};
  20:     wxTextCtrl *replaces {nullptr};
  21:     ColorDropdown *cellcolordropdown {nullptr};
  22:     ColorDropdown *textcolordropdown {nullptr};
  23:     ColorDropdown *bordercolordropdown {nullptr};
  24:     ImageDropdown *imagedropdown {nullptr};
  25:     wxString imagepath;
  26:     int refreshhack {0};
  27:     int refreshhackinstances {0};
  28:     std::map&lt;wxString, wxString&gt; menustrings;
  29:     TSFrame(TSApp *_app)
  30:         : wxFrame((wxFrame *)nullptr, wxID_ANY, L&quot;TreeSheets&quot;, wxDefaultPosition, wxDefaultSize,
  31:                   wxDEFAULT_FRAME_STYLE),
  32:           app(_app) {
  33:         sys-&gt;frame = this;
  34:         class MyLog : public wxLog {
  35:             void DoLogString(const wxChar *message, time_t timestamp) { DoLogText(*message); }
  36:             void DoLogText(const wxString &amp;message) {
  37:                 #ifdef WIN32
  38:                 OutputDebugString(message.c_str());
  39:                 OutputDebugString(L&quot;\n&quot;);
  40:                 #else
  41:                 fputws(message.c_str(), stderr);
  42:                 fputws(L&quot;\n&quot;, stderr);
  43:                 #endif
  44:             }
  45:         };
  46:         wxLog::SetActiveTarget(new MyLog());
  47:         wxLogMessage(L&quot;%s&quot;, wxVERSION_STRING);
  48:         aui.SetManagedWindow(this);
  49:         wxInitAllImageHandlers();
  50:         wxIconBundle icons;
  51:         wxIcon iconbig;
  52:         #ifdef WIN32
  53:             int iconsmall = ::GetSystemMetrics(SM_CXSMICON);
  54:             int iconlarge = ::GetSystemMetrics(SM_CXICON);
  55:         #endif
  56:         icon.LoadFile(app-&gt;GetDataPath(L&quot;images/icon16.png&quot;), wxBITMAP_TYPE_PNG
  57:             #ifdef WIN32
  58:                 , iconsmall, iconsmall
  59:             #endif
  60:         );
  61:         iconbig.LoadFile(app-&gt;GetDataPath(L&quot;images/icon32.png&quot;), wxBITMAP_TYPE_PNG
  62:             #ifdef WIN32
  63:                 , iconlarge, iconlarge
  64:             #endif
  65:         );
  66:         if (!icon.IsOk() || !iconbig.IsOk()) {
  67:             wxMessageBox(_(L&quot;Error loading core data file (TreeSheets not installed correctly?)&quot;),
  68:                          _(L&quot;Initialization Error&quot;), wxOK, this);
  69:             exit(1);
  70:         }
  71:         icons.AddIcon(icon);
  72:         icons.AddIcon(iconbig);
  73:         SetIcons(icons);
  74:         RenderFolderIcon();
  75:         line_nw.LoadFile(app-&gt;GetDataPath(L&quot;images/render/line_nw.png&quot;), wxBITMAP_TYPE_PNG);
  76:         line_sw.LoadFile(app-&gt;GetDataPath(L&quot;images/render/line_sw.png&quot;), wxBITMAP_TYPE_PNG);
  77:         imagepath = app-&gt;GetDataPath(&quot;images/nuvola/dropdown/&quot;);
  78:         if (sys-&gt;singletray)
  79:             taskbaricon.Connect(wxID_ANY, wxEVT_TASKBAR_LEFT_UP,
  80:                         wxTaskBarIconEventHandler(TSFrame::OnTBIDBLClick), nullptr, this);
  81:         else
  82:             taskbaricon.Connect(wxID_ANY, wxEVT_TASKBAR_LEFT_DCLICK,
  83:                         wxTaskBarIconEventHandler(TSFrame::OnTBIDBLClick), nullptr, this);
  84:         bool showtbar, showsbar, lefttabs;
  85:         sys-&gt;cfg-&gt;Read(L&quot;showtbar&quot;, &amp;showtbar, true);
  86:         sys-&gt;cfg-&gt;Read(L&quot;showsbar&quot;, &amp;showsbar, true);
  87:         sys-&gt;cfg-&gt;Read(L&quot;lefttabs&quot;, &amp;lefttabs, true);
  88:         filehistory.Load(*sys-&gt;cfg);
  89:         #ifdef ENABLE_LOBSTER
  90:             auto oldpath = sys-&gt;cfg-&gt;GetPath();
  91:             sys-&gt;cfg-&gt;SetPath(&quot;/scripts&quot;);
  92:             scripts.Load(*sys-&gt;cfg);
  93:             sys-&gt;cfg-&gt;SetPath(oldpath);
  94:         #endif
  95:         #ifdef __WXMAC__
  96:             #define CTRLORALT &quot;CTRL&quot;
  97:         #else
  98:             #define CTRLORALT &quot;ALT&quot;
  99:         #endif
 100:         #ifdef __WXMAC__
 101:             #define ALTORCTRL &quot;ALT&quot;
 102:         #else
 103:             #define ALTORCTRL &quot;CTRL&quot;
 104:         #endif
 105:         auto expmenu = new wxMenu();
 106:         MyAppend(expmenu, A_EXPXML, _(L&quot;&amp;XML...&quot;),
 107:                  _(L&quot;Export the current view as XML (which can also be reimported without losing structure)&quot;));
 108:         MyAppend(expmenu, A_EXPHTMLT, _(L&quot;&amp;HTML (Tables+Styling)...&quot;),
 109:                  _(L&quot;Export the current view as HTML using nested tables, that will look somewhat like the TreeSheet&quot;));
 110:         MyAppend(expmenu, A_EXPHTMLTE, _(L&quot;&amp;HTML (Tables+Styling+Images)...&quot;),
 111:                  _(L&quot;Export the curent view as HTML using nested tables and exported images&quot;));
 112:         MyAppend(expmenu, A_EXPHTMLB, _(L&quot;HTML (&amp;Bullet points)...&quot;),
 113:                  _(L&quot;Export the current view as HTML as nested bullet points.&quot;));
 114:         MyAppend(expmenu, A_EXPHTMLO, _(L&quot;HTML (&amp;Outline)...&quot;),
 115:                  _(L&quot;Export the current view as HTML as nested headers, suitable for importing into Word&apos;s outline mode&quot;));
 116:         MyAppend(
 117:             expmenu, A_EXPTEXT, _(L&quot;Indented &amp;Text...&quot;),
 118:             _(L&quot;Export the current view as tree structured text, using spaces for each indentation level. Suitable for importing into mindmanagers and general text programs&quot;));
 119:         MyAppend(
 120:             expmenu, A_EXPCSV, _(L&quot;&amp;Comma delimited text (CSV)...&quot;),
 121:             _(L&quot;Export the current view as CSV. Good for spreadsheets and databases. Only works on grids with no sub-grids (use the Flatten operation first if need be)&quot;));
 122:         MyAppend(expmenu, A_EXPIMAGE, _(L&quot;&amp;Image...&quot;),
 123:                  _(L&quot;Export the current view as an image. Useful for faithful renderings of the TreeSheet, and programs that don&apos;t accept any of the above options&quot;));
 124:         auto impmenu = new wxMenu();
 125:         MyAppend(impmenu, A_IMPXML, _(L&quot;XML...&quot;));
 126:         MyAppend(impmenu, A_IMPXMLA, _(L&quot;XML (attributes too, for OPML etc)...&quot;));
 127:         MyAppend(impmenu, A_IMPTXTI, _(L&quot;Indented text...&quot;));
 128:         MyAppend(impmenu, A_IMPTXTC, _(L&quot;Comma delimited text (CSV)...&quot;));
 129:         MyAppend(impmenu, A_IMPTXTS, _(L&quot;Semi-Colon delimited text (CSV)...&quot;));
 130:         MyAppend(impmenu, A_IMPTXTT, _(L&quot;Tab delimited text...&quot;));
 131:         auto recentmenu = new wxMenu();
 132:         filehistory.UseMenu(recentmenu);
 133:         filehistory.AddFilesToMenu();
 134:         auto filemenu = new wxMenu();
 135:         MyAppend(filemenu, wxID_NEW, _(L&quot;&amp;New&quot;) + L&quot;\tCTRL+N&quot;, _(L&quot;Create a new document&quot;));
 136:         MyAppend(filemenu, wxID_OPEN, _(L&quot;&amp;Open...&quot;) + L&quot;\tCTRL+O&quot;,
 137:                  _(L&quot;Open an existing document&quot;));
 138:         MyAppend(filemenu, wxID_CLOSE, _(L&quot;&amp;Close&quot;) + L&quot;\tCTRL+W&quot;, _(L&quot;Close current document&quot;));
 139:         filemenu-&gt;AppendSubMenu(recentmenu, _(L&quot;&amp;Recent files&quot;));
 140:         MyAppend(filemenu, wxID_SAVE, _(L&quot;&amp;Save&quot;) + L&quot;\tCTRL+S&quot;, _(L&quot;Save current document&quot;));
 141:         MyAppend(filemenu, wxID_SAVEAS, _(L&quot;Save &amp;As...&quot;),
 142:                  _(L&quot;Save current document with a different filename&quot;));
 143:         MyAppend(filemenu, A_SAVEALL, _(L&quot;Save All&quot;));
 144:         filemenu-&gt;AppendSeparator();
 145:         MyAppend(filemenu, A_PAGESETUP, _(L&quot;Page Setup...&quot;));
 146:         MyAppend(filemenu, A_PRINTSCALE, _(L&quot;Set Print Scale...&quot;));
 147:         MyAppend(filemenu, wxID_PREVIEW, _(L&quot;Print preview...&quot;));
 148:         MyAppend(filemenu, wxID_PRINT, _(L&quot;&amp;Print...&quot;) + L&quot;\tCTRL+P&quot;);
 149:         filemenu-&gt;AppendSeparator();
 150:         filemenu-&gt;AppendSubMenu(expmenu, _(L&quot;Export &amp;view as&quot;));
 151:         filemenu-&gt;AppendSubMenu(impmenu, _(L&quot;Import from&quot;));
 152:         filemenu-&gt;AppendSeparator();
 153:         MyAppend(filemenu, wxID_EXIT, _(L&quot;&amp;Exit&quot;) + L&quot;\tCTRL+Q&quot;, _(L&quot;Quit this program&quot;));
 154:         wxMenu *editmenu;
 155:         loop(twoeditmenus, 2) {
 156:             auto sizemenu = new wxMenu();
 157:             MyAppend(sizemenu, A_INCSIZE,
 158:                      _(L&quot;&amp;Increase text size (SHIFT+mousewheel)&quot;) + L&quot;\tSHIFT+PGUP&quot;);
 159:             MyAppend(sizemenu, A_DECSIZE,
 160:                      _(L&quot;&amp;Decrease text size (SHIFT+mousewheel)&quot;) + L&quot;\tSHIFT+PGDN&quot;);
 161:             MyAppend(sizemenu, A_RESETSIZE, _(L&quot;&amp;Reset text sizes&quot;) + L&quot;\tCTRL+SHIFT+S&quot;);
 162:             MyAppend(sizemenu, A_MINISIZE, _(L&quot;&amp;Shrink text of all sub-grids&quot;) + L&quot;\tCTRL+SHIFT+M&quot;);
 163:             sizemenu-&gt;AppendSeparator();
 164:             MyAppend(sizemenu, A_INCWIDTH,
 165:                      _(L&quot;Increase column width (ALT+mousewheel)&quot;) + L&quot;\tALT+PGUP&quot;);
 166:             MyAppend(sizemenu, A_DECWIDTH,
 167:                      _(L&quot;Decrease column width (ALT+mousewheel)&quot;) + L&quot;\tALT+PGDN&quot;);
 168:             MyAppend(sizemenu, A_INCWIDTHNH,
 169:                      _(L&quot;Increase column width (no sub grids)&quot;) + L&quot;\tCTRL+ALT+PGUP&quot;);
 170:             MyAppend(sizemenu, A_DECWIDTHNH,
 171:                      _(L&quot;Decrease column width (no sub grids)&quot;) + L&quot;\tCTRL+ALT+PGDN&quot;);
 172:             MyAppend(sizemenu, A_RESETWIDTH, _(L&quot;Reset column widths&quot;) + L&quot;\tCTRL+R&quot;,
 173:                      _(L&quot;Reset the column widths in the selection to the default column width&quot;));
 174:             auto bordmenu = new wxMenu();
 175:             MyAppend(bordmenu, A_BORD0, _(L&quot;Border &amp;0&quot;) + L&quot;\tCTRL+SHIFT+9&quot;);
 176:             MyAppend(bordmenu, A_BORD1, _(L&quot;Border &amp;1&quot;) + L&quot;\tCTRL+SHIFT+1&quot;);
 177:             MyAppend(bordmenu, A_BORD2, _(L&quot;Border &amp;2&quot;) + L&quot;\tCTRL+SHIFT+2&quot;);
 178:             MyAppend(bordmenu, A_BORD3, _(L&quot;Border &amp;3&quot;) + L&quot;\tCTRL+SHIFT+3&quot;);
 179:             MyAppend(bordmenu, A_BORD4, _(L&quot;Border &amp;4&quot;) + L&quot;\tCTRL+SHIFT+4&quot;);
 180:             MyAppend(bordmenu, A_BORD5, _(L&quot;Border &amp;5&quot;) + L&quot;\tCTRL+SHIFT+5&quot;);
 181:             auto selmenu = new wxMenu();
 182:             MyAppend(selmenu, A_NEXT,
 183:                 #ifdef __WXGTK__
 184:                     _(L&quot;Move to next cell (TAB)&quot;)
 185:                 #else
 186:                     _(L&quot;Move to next cell&quot;) + L&quot;\tTAB&quot;
 187:                 #endif
 188:             );
 189:             MyAppend(selmenu, A_PREV, 
 190:                 #ifdef __WXGTK__
 191:                     _(L&quot;Move to previous cell (SHIFT+TAB)&quot;)
 192:                 #else
 193:                     _(L&quot;Move to previous cell&quot;) + L&quot;\tSHIFT+TAB&quot;
 194:                 #endif
 195:             );
 196:             selmenu-&gt;AppendSeparator();
 197:             MyAppend(selmenu, wxID_SELECTALL, _(L&quot;Select &amp;all in current grid/cell&quot;) + L&quot;\tCTRL+A&quot;);
 198:             selmenu-&gt;AppendSeparator();
 199:             MyAppend(selmenu, A_LEFT, 
 200:                 #ifdef __WXGTK__
 201:                     _(L&quot;Move Selection Left (LEFT)&quot;)
 202:                 #else
 203:                     _(L&quot;Move Selection Left&quot;) + L&quot;\tLEFT&quot;
 204:                 #endif
 205:             );
 206:             MyAppend(selmenu, A_RIGHT, 
 207:                 #ifdef __WXGTK__
 208:                     _(L&quot;Move Selection Right (RIGHT)&quot;)
 209:                 #else 
 210:                     _(L&quot;Move Selection Right&quot;) + L&quot;\tRIGHT&quot;
 211:                 #endif
 212:             );
 213:             MyAppend(selmenu, A_UP, 
 214:                 #ifdef __WXGTK__
 215:                     _(L&quot;Move Selection Up (UP)&quot;)
 216:                 #else
 217:                     _(L&quot;Move Selection Up&quot;) + L&quot;\tUP&quot;
 218:                 #endif
 219:             );
 220:             MyAppend(selmenu, A_DOWN, 
 221:                 #ifdef __WXGTK__
 222:                     _(L&quot;Move Selection Down (DOWN)&quot;)
 223:                 #else
 224:                     _(L&quot;Move Selection Down&quot;) + L&quot;\tDOWN&quot;
 225:                 #endif
 226:             );
 227:             selmenu-&gt;AppendSeparator();
 228:             MyAppend(selmenu, A_MLEFT, _(L&quot;Move Cells Left&quot;) + L&quot;\tCTRL+LEFT&quot;);
 229:             MyAppend(selmenu, A_MRIGHT, _(L&quot;Move Cells Right&quot;) + L&quot;\tCTRL+RIGHT&quot;);
 230:             MyAppend(selmenu, A_MUP, _(L&quot;Move Cells Up&quot;) + L&quot;\tCTRL+UP&quot;);
 231:             MyAppend(selmenu, A_MDOWN, _(L&quot;Move Cells Down&quot;) + L&quot;\tCTRL+DOWN&quot;);
 232:             selmenu-&gt;AppendSeparator();
 233:             MyAppend(selmenu, A_SLEFT, _(L&quot;Extend Selection Left&quot;) + L&quot;\tSHIFT+LEFT&quot;);
 234:             MyAppend(selmenu, A_SRIGHT, _(L&quot;Extend Selection Right&quot;) + L&quot;\tSHIFT+RIGHT&quot;);
 235:             MyAppend(selmenu, A_SUP, _(L&quot;Extend Selection Up&quot;) + L&quot;\tSHIFT+UP&quot;);
 236:             MyAppend(selmenu, A_SDOWN, _(L&quot;Extend Selection Down&quot;) + L&quot;\tSHIFT+DOWN&quot;);
 237:             selmenu-&gt;AppendSeparator();
 238:             MyAppend(selmenu, A_SROWS, _(L&quot;Extend Selection Full Rows&quot;));
 239:             MyAppend(selmenu, A_SCLEFT, _(L&quot;Extend Selection Rows Left&quot;) + L&quot;\tCTRL+SHIFT+LEFT&quot;);
 240:             MyAppend(selmenu, A_SCRIGHT, _(L&quot;Extend Selection Rows Right&quot;) + L&quot;\tCTRL+SHIFT+RIGHT&quot;);
 241:             selmenu-&gt;AppendSeparator();
 242:             MyAppend(selmenu, A_SCOLS, _(L&quot;Extend Selection Full Columns&quot;) + L&quot;\tCTRL+SHIFT+a&quot;);
 243:             MyAppend(selmenu, A_SCUP, _(L&quot;Extend Selection Columns Up&quot;) + L&quot;\tCTRL+SHIFT+UP&quot;);
 244:             MyAppend(selmenu, A_SCDOWN, _(L&quot;Extend Selection Columns Down&quot;) + L&quot;\tCTRL+SHIFT+DOWN&quot;);
 245:             selmenu-&gt;AppendSeparator();
 246:             MyAppend(selmenu, A_CANCELEDIT, _(L&quot;Select &amp;Parent&quot;) + L&quot;\tESC&quot;);
 247:             MyAppend(selmenu, A_ENTERGRID, _(L&quot;Select First &amp;Child&quot;) + L&quot;\tSHIFT+ENTER&quot;);
 248:             selmenu-&gt;AppendSeparator();
 249:             MyAppend(selmenu, A_LINK, _(L&quot;Go To &amp;Matching Cell (Text)&quot;) + L&quot;\tF6&quot;);
 250:             MyAppend(selmenu, A_LINKREV, _(L&quot;Go To Matching Cell (Text, Reverse)&quot;) + L&quot;\tSHIFT+F6&quot;);
 251:             MyAppend(selmenu, A_LINKIMG, _(L&quot;Go To Matching Cell (Image)&quot;) + L&quot;\tF7&quot;);
 252:             MyAppend(selmenu, A_LINKIMGREV,
 253:                      _(L&quot;Go To Matching Cell (Image, Reverse)&quot;) + L&quot;\tSHIFT+F7&quot;);
 254:             auto temenu = new wxMenu();
 255:             MyAppend(temenu, A_LEFT, _(L&quot;Cursor Left&quot;) + L&quot;\tLEFT&quot;);
 256:             MyAppend(temenu, A_RIGHT, _(L&quot;Cursor Right&quot;) + L&quot;\tRIGHT&quot;);
 257:             MyAppend(temenu, A_MLEFT, _(L&quot;Word Left&quot;) + L&quot;\tCTRL+LEFT&quot;);
 258:             MyAppend(temenu, A_MRIGHT, _(L&quot;Word Right&quot;) + L&quot;\tCTRL+RIGHT&quot;);
 259:             temenu-&gt;AppendSeparator();
 260:             MyAppend(temenu, A_SLEFT, _(L&quot;Extend Selection Left&quot;) + L&quot;\tSHIFT+LEFT&quot;);
 261:             MyAppend(temenu, A_SRIGHT, _(L&quot;Extend Selection Right&quot;) + L&quot;\tSHIFT+RIGHT&quot;);
 262:             MyAppend(temenu, A_SCLEFT, _(L&quot;Extend Selection Word Left&quot;) + L&quot;\tCTRL+SHIFT+LEFT&quot;);
 263:             MyAppend(temenu, A_SCRIGHT, _(L&quot;Extend Selection Word Right&quot;) + L&quot;\tCTRL+SHIFT+RIGHT&quot;);
 264:             MyAppend(temenu, A_SHOME, _(L&quot;Extend Selection to Start&quot;) + L&quot;\tSHIFT+HOME&quot;);
 265:             MyAppend(temenu, A_SEND, _(L&quot;Extend Selection to End&quot;) + L&quot;\tSHIFT+END&quot;);
 266:             temenu-&gt;AppendSeparator();
 267:             MyAppend(temenu, A_HOME, _(L&quot;Start of line of text&quot;) + L&quot;\tHOME&quot;);
 268:             MyAppend(temenu, A_END, _(L&quot;End of line of text&quot;) + L&quot;\tEND&quot;);
 269:             MyAppend(temenu, A_CHOME, _(L&quot;Start of text&quot;) + L&quot;\tCTRL+HOME&quot;);
 270:             MyAppend(temenu, A_CEND, _(L&quot;End of text&quot;) + L&quot;\tCTRL+END&quot;);
 271:             temenu-&gt;AppendSeparator();
 272:             MyAppend(temenu, A_ENTERCELL, _(L&quot;Enter/exit text edit mode&quot;) + L&quot;\tENTER&quot;);
 273:             MyAppend(temenu, A_ENTERCELL_JUMPTOEND,
 274:                      _(L&quot;...and jump to the end of the text&quot;) + L&quot;\tF2&quot;);
 275:             MyAppend(
 276:                 temenu, A_ENTERCELL_JUMPTOSTART,
 277:                 _(L&quot;...and progress to the first cell in the new row&quot;) + L&quot;\t&quot; ALTORCTRL &quot;+ENTER&quot;);
 278:             MyAppend(
 279:                 temenu, A_PROGRESSCELL,
 280:                 _(L&quot;...and progress to the next cell on the right&quot;) + L&quot;\t&quot; CTRLORALT &quot;+ENTER&quot;);
 281:             MyAppend(temenu, A_CANCELEDIT, _(L&quot;Cancel text edits&quot;) + &quot;\tESC&quot;);
 282:             auto stmenu = new wxMenu();
 283:             MyAppend(stmenu, wxID_BOLD, _(L&quot;Toggle cell &amp;BOLD&quot;) + L&quot;\tCTRL+B&quot;);
 284:             MyAppend(stmenu, wxID_ITALIC, _(L&quot;Toggle cell &amp;ITALIC&quot;) + L&quot;\tCTRL+I&quot;);
 285:             MyAppend(stmenu, A_TT, _(L&quot;Toggle cell &amp;typewriter&quot;) + L&quot;\tCTRL+ALT+T&quot;);
 286:             MyAppend(stmenu, wxID_UNDERLINE, _(L&quot;Toggle cell &amp;underlined&quot;) + L&quot;\tCTRL+U&quot;);
 287:             MyAppend(stmenu, wxID_STRIKETHROUGH, _(L&quot;Toggle cell &amp;strikethrough&quot;) + L&quot;\tCTRL+T&quot;);
 288:             stmenu-&gt;AppendSeparator();
 289:             MyAppend(stmenu, A_RESETSTYLE, _(L&quot;&amp;Reset text styles&quot;) + L&quot;\tCTRL+SHIFT+R&quot;);
 290:             MyAppend(stmenu, A_RESETCOLOR, _(L&quot;Reset &amp;colors&quot;) + L&quot;\tCTRL+SHIFT+C&quot;);
 291:             stmenu-&gt;AppendSeparator();
 292:             MyAppend(stmenu, A_LASTCELLCOLOR, _(L&quot;Apply last cell color&quot;) + L&quot;\tSHIFT+ALT+C&quot;);
 293:             MyAppend(stmenu, A_LASTTEXTCOLOR, _(L&quot;Apply last text color&quot;) + L&quot;\tSHIFT+ALT+T&quot;);
 294:             MyAppend(stmenu, A_LASTBORDCOLOR, _(L&quot;Apply last border color&quot;) + L&quot;\tSHIFT+ALT+B&quot;);
 295:             MyAppend(stmenu, A_OPENCELLCOLOR, _(L&quot;Open cell colors&quot;) + L&quot;\tSHIFT+ALT+F9&quot;);
 296:             MyAppend(stmenu, A_OPENTEXTCOLOR, _(L&quot;Open text colors&quot;) + L&quot;\tSHIFT+ALT+F10&quot;);
 297:             MyAppend(stmenu, A_OPENBORDCOLOR, _(L&quot;Open border colors&quot;) + L&quot;\tSHIFT+ALT+F11&quot;);
 298:             MyAppend(stmenu, A_OPENIMGDROPDOWN, _(L&quot;Open image dropdown&quot;) + L&quot;\tSHIFT+ALT+F12&quot;);
 299:             auto tagmenu = new wxMenu();
 300:             MyAppend(tagmenu, A_TAGADD, _(L&quot;&amp;Add Cell Text as Tag&quot;));
 301:             MyAppend(tagmenu, A_TAGREMOVE, _(L&quot;&amp;Remove Cell Text from Tags&quot;));
 302:             MyAppend(tagmenu, A_NOP, _(L&quot;&amp;Set Cell Text to tag (use CTRL+RMB)&quot;),
 303:                      _(L&quot;Hold CTRL while pressing right mouse button to quickly set a tag for the current cell using a popup menu&quot;));
 304:             auto orgmenu = new wxMenu();
 305:             MyAppend(orgmenu, A_TRANSPOSE, _(L&quot;&amp;Transpose&quot;) + L&quot;\tCTRL+SHIFT+T&quot;,
 306:                      _(L&quot;changes the orientation of a grid&quot;));
 307:             MyAppend(orgmenu, A_SORT, _(L&quot;Sort &amp;Ascending&quot;),
 308:                      _(L&quot;Make a 1xN selection to indicate which column to sort on, and which rows to affect&quot;));
 309:             MyAppend(orgmenu, A_SORTD, _(L&quot;Sort &amp;Descending&quot;),
 310:                      _(L&quot;Make a 1xN selection to indicate which column to sort on, and which rows to affect&quot;));
 311:             MyAppend(orgmenu, A_HSWAP, _(L&quot;Hierarchy &amp;Swap&quot;) + L&quot;\tF8&quot;,
 312:                      _(L&quot;Swap all cells with this text at this level (or above) with the parent&quot;));
 313:             MyAppend(orgmenu, A_HIFY, _(L&quot;&amp;Hierarchify&quot;),
 314:                      _(L&quot;Convert an NxN grid with repeating elements per column into an 1xN grid with hierarchy, useful to convert data from spreadsheets&quot;));
 315:             MyAppend(orgmenu, A_FLATTEN, _(L&quot;&amp;Flatten&quot;),
 316:                      _(L&quot;Takes a hierarchy (nested 1xN or Nx1 grids) and converts it into a flat NxN grid, useful for export to spreadsheets&quot;));
 317:             auto imgmenu = new wxMenu();
 318:             MyAppend(imgmenu, A_IMAGE, _(L&quot;&amp;Add...&quot;), _(L&quot;Add an image to the selected cell&quot;));
 319:             MyAppend(imgmenu, A_IMAGESVA, _(L&quot;&amp;Save as...&quot;),
 320:                      _(L&quot;Save image(s) from selected cell(s) to disk. Multiple images will be saved with a counter appended to each file name.&quot;));
 321:             imgmenu-&gt;AppendSeparator();
 322:             MyAppend(
 323:                 imgmenu, A_IMAGESCP, _(L&quot;Scale (re-sa&amp;mple pixels, by %)&quot;),
 324:                 _(L&quot;Change the image(s) size if it is too big, by reducing the amount of pixels&quot;));
 325:             MyAppend(
 326:                 imgmenu, A_IMAGESCW, _(L&quot;Scale (re-sample pixels, by &amp;width)&quot;),
 327:                 _(L&quot;Change the image(s) size if it is too big, by reducing the amount of pixels&quot;));
 328:             MyAppend(imgmenu, A_IMAGESCF, _(L&quot;Scale (&amp;display only)&quot;),
 329:                      _(L&quot;Change the image(s) size if it is too big or too small, by changing the size shown on screen. Applies to all uses of this image.&quot;));
 330:             MyAppend(imgmenu, A_IMAGESCN, _(L&quot;&amp;Reset Scale (display only)&quot;),
 331:                      _(L&quot;Change the image(s) scale to match DPI of the current display. Applies to all uses of this image.&quot;));
 332:             imgmenu-&gt;AppendSeparator();
 333:             MyAppend(
 334:                 imgmenu, A_SAVE_AS_JPEG, _(L&quot;Embed as &amp;JPEG&quot;),
 335:                 _(L&quot;Embed the image(s) in the selected cells in JPEG format (reduces data size)&quot;));
 336:             MyAppend(imgmenu, A_SAVE_AS_PNG, _(L&quot;Embed as &amp;PNG&quot;),
 337:                      _(L&quot;Embed the image(s) in the selected cells in PNG format (default)&quot;));
 338:             imgmenu-&gt;AppendSeparator();
 339:             MyAppend(imgmenu, A_LASTIMAGE, _(L&quot;Insert last image&quot;) + L&quot;\tSHIFT+ALT+i&quot;,
 340:                      _(L&quot;Insert the last image that has been inserted before in TreeSheets.&quot;));
 341:             MyAppend(imgmenu, A_IMAGER, _(L&quot;Remo&amp;ve&quot;),
 342:                      _(L&quot;Remove image(s) from the selected cells&quot;));
 343:             auto navmenu = new wxMenu();
 344:             MyAppend(navmenu, A_BROWSE, _(L&quot;Open link in &amp;browser&quot;) + L&quot;\tF5&quot;,
 345:                      _(L&quot;Opens up the text from the selected cell in browser (should start be a valid URL)&quot;));
 346:             MyAppend(navmenu, A_BROWSEF, _(L&quot;Open &amp;file&quot;) + &quot;\tF4&quot;,
 347:                      _(L&quot;Opens up the text from the selected cell in default application for the file type&quot;));
 348:             auto laymenu = new wxMenu();
 349:             MyAppend(laymenu, A_V_GS,
 350:                      _(L&quot;Vertical Layout with Grid Style Rendering&quot;) + L&quot;\t&quot; CTRLORALT &quot;+1&quot;);
 351:             MyAppend(laymenu, A_V_BS,
 352:                      _(L&quot;Vertical Layout with Bubble Style Rendering&quot;) + L&quot;\t&quot; CTRLORALT &quot;+2&quot;);
 353:             MyAppend(laymenu, A_V_LS,
 354:                      _(L&quot;Vertical Layout with Line Style Rendering&quot;) + L&quot;\t&quot; CTRLORALT &quot;+3&quot;);
 355:             laymenu-&gt;AppendSeparator();
 356:             MyAppend(laymenu, A_H_GS,
 357:                      _(L&quot;Horizontal Layout with Grid Style Rendering&quot;) + L&quot;\t&quot; CTRLORALT &quot;+4&quot;);
 358:             MyAppend(laymenu, A_H_BS,
 359:                      _(L&quot;Horizontal Layout with Bubble Style Rendering&quot;) + L&quot;\t&quot; CTRLORALT &quot;+5&quot;);
 360:             MyAppend(laymenu, A_H_LS,
 361:                      _(L&quot;Horizontal Layout with Line Style Rendering&quot;) + L&quot;\t&quot; CTRLORALT &quot;+6&quot;);
 362:             laymenu-&gt;AppendSeparator();
 363:             MyAppend(laymenu, A_GS, _(L&quot;Grid Style Rendering&quot;) + L&quot;\t&quot; CTRLORALT &quot;+7&quot;);
 364:             MyAppend(laymenu, A_BS, _(L&quot;Bubble Style Rendering&quot;) + L&quot;\t&quot; CTRLORALT &quot;+8&quot;);
 365:             MyAppend(laymenu, A_LS, _(L&quot;Line Style Rendering&quot;) + L&quot;\t&quot; CTRLORALT &quot;+9&quot;);
 366:             laymenu-&gt;AppendSeparator();
 367:             MyAppend(laymenu, A_TEXTGRID, _(L&quot;Toggle Vertical Layout&quot;) + L&quot;\t&quot; CTRLORALT &quot;+0&quot;,
 368:                      _(L&quot;Make a hierarchy layout more vertical (default) or more horizontal&quot;));
 369:             editmenu = new wxMenu();
 370:             MyAppend(editmenu, wxID_CUT, _(L&quot;Cu&amp;t&quot;) + L&quot;\tCTRL+X&quot;, _(L&quot;Cut selection&quot;));
 371:             MyAppend(editmenu, wxID_COPY, _(L&quot;&amp;Copy&quot;) + L&quot;\tCTRL+C&quot;, _(L&quot;Copy selection&quot;));
 372:             editmenu-&gt;AppendSeparator();
 373:             MyAppend(editmenu, A_COPYWI, _(L&quot;Copy with &amp;Images&quot;) + L&quot;\tCTRL+ALT+C&quot;);
 374:             MyAppend(editmenu, A_COPYBM, _(L&quot;&amp;Copy as Bitmap&quot;));
 375:             MyAppend(editmenu, A_COPYCT, _(L&quot;Copy As Continuous Text&quot;));
 376:             editmenu-&gt;AppendSeparator();
 377:             MyAppend(editmenu, wxID_PASTE, _(L&quot;&amp;Paste&quot;) + L&quot;\tCTRL+V&quot;,
 378:                      _(L&quot;Paste clipboard contents&quot;));
 379:             MyAppend(editmenu, A_PASTESTYLE, _(L&quot;Paste Style Only&quot;) + L&quot;\tCTRL+SHIFT+V&quot;,
 380:                      _(L&quot;only sets the colors and style of the copied cell, and keeps the text&quot;));
 381:             MyAppend(editmenu, A_COLLAPSE, _(L&quot;Collapse Ce&amp;lls&quot;) + L&quot;\tCTRL+L&quot;);
 382:             editmenu-&gt;AppendSeparator();
 383:             MyAppend(editmenu, wxID_UNDO, _(L&quot;&amp;Undo&quot;) + L&quot;\tCTRL+Z&quot;,
 384:                      _(L&quot;revert the changes, one step at a time&quot;));
 385:             MyAppend(editmenu, wxID_REDO, _(L&quot;&amp;Redo&quot;) + L&quot;\tCTRL+Y&quot;,
 386:                      _(L&quot;redo any undo steps, if you haven&apos;t made changes since&quot;));
 387:             editmenu-&gt;AppendSeparator();
 388:             MyAppend(
 389:                 editmenu, A_DELETE, _(L&quot;&amp;Delete After&quot;) + L&quot;\tDEL&quot;,
 390:                 _(L&quot;Deletes the column of cells after the selected grid line, or the row below&quot;));
 391:             MyAppend(
 392:                 editmenu, A_BACKSPACE, _(L&quot;Delete Before&quot;) + L&quot;\tBACK&quot;,
 393:                 _(L&quot;Deletes the column of cells before the selected grid line, or the row above&quot;));
 394:             MyAppend(editmenu, A_DELETE_WORD, _(L&quot;Delete Word After&quot;) + L&quot;\tCTRL+DEL&quot;,
 395:                      _(L&quot;Deletes the entire word after the cursor&quot;));
 396:             MyAppend(editmenu, A_BACKSPACE_WORD, _(L&quot;Delete Word Before&quot;) + L&quot;\tCTRL+BACK&quot;,
 397:                      _(L&quot;Deletes the entire word before the cursor&quot;));
 398:             editmenu-&gt;AppendSeparator();
 399:             MyAppend(editmenu, A_NEWGRID,
 400:                      #ifdef __WXMAC__
 401:                      _(L&quot;&amp;Insert New Grid&quot;) + L&quot;\tCTRL+G&quot;,
 402:                      #else
 403:                      _(L&quot;&amp;Insert New Grid&quot;) + L&quot;\tINS&quot;,
 404:                      #endif
 405:                      _(L&quot;Adds a grid to the selected cell&quot;));
 406:             MyAppend(editmenu, A_WRAP, _(L&quot;&amp;Wrap in new parent&quot;) + L&quot;\tF9&quot;,
 407:                      _(L&quot;Creates a new level of hierarchy around the current selection&quot;));
 408:             editmenu-&gt;AppendSeparator();
 409:             // F10 is tied to the OS on both Ubuntu and OS X, and SHIFT+F10 is now right
 410:             // click on all platforms?
 411:             MyAppend(editmenu, A_FOLD,
 412:                      #ifndef WIN32
 413:                      _(L&quot;Toggle Fold&quot;) + L&quot;\tCTRL+F10&quot;,
 414:                      #else
 415:                      _(L&quot;Toggle Fold&quot;) + L&quot;\tF10&quot;,
 416:                      #endif
 417:                     _(&quot;Toggles showing the grid of the selected cell(s)&quot;));
 418:             MyAppend(editmenu, A_FOLDALL, _(L&quot;Fold All&quot;) + L&quot;\tCTRL+SHIFT+F10&quot;,
 419:                 _(L&quot;Folds the grid of the selected cell(s) recursively&quot;));
 420:             MyAppend(editmenu, A_UNFOLDALL, _(L&quot;Unfold All&quot;) + L&quot;\tCTRL+ALT+F10&quot;,
 421:                 _(L&quot;Unfolds the grid of the selected cell(s) recursively&quot;));
 422:             editmenu-&gt;AppendSeparator();
 423:             editmenu-&gt;AppendSubMenu(selmenu, _(L&quot;&amp;Selection&quot;));
 424:             editmenu-&gt;AppendSubMenu(orgmenu, _(L&quot;&amp;Grid Reorganization&quot;));
 425:             editmenu-&gt;AppendSubMenu(laymenu, _(L&quot;&amp;Layout &amp;&amp; Render Style&quot;));
 426:             editmenu-&gt;AppendSubMenu(imgmenu, _(L&quot;&amp;Images&quot;));
 427:             editmenu-&gt;AppendSubMenu(navmenu, _(L&quot;&amp;Browsing&quot;));
 428:             editmenu-&gt;AppendSubMenu(temenu, _(L&quot;Text &amp;Editing&quot;));
 429:             editmenu-&gt;AppendSubMenu(sizemenu, _(L&quot;Text Sizing&quot;));
 430:             editmenu-&gt;AppendSubMenu(stmenu, _(L&quot;Text Style&quot;));
 431:             editmenu-&gt;AppendSubMenu(bordmenu, _(L&quot;Set Grid Border Width&quot;));
 432:             editmenu-&gt;AppendSubMenu(tagmenu, _(L&quot;Tag&quot;));
 433:             if (!twoeditmenus) editmenupopup = editmenu;
 434:         }
 435:         auto semenu = new wxMenu();
 436:         MyAppend(semenu, wxID_FIND, _(L&quot;&amp;Search&quot;) + L&quot;\tCTRL+F&quot;, _(L&quot;Find in document&quot;));
 437:         semenu-&gt;AppendCheckItem(A_CASESENSITIVESEARCH, _(L&quot;Case-sensitive search&quot;));
 438:         semenu-&gt;Check(A_CASESENSITIVESEARCH, sys-&gt;casesensitivesearch);
 439:         semenu-&gt;AppendSeparator();
 440:         MyAppend(semenu, A_SEARCHNEXT, _(L&quot;&amp;Next Match&quot;) + L&quot;\tF3&quot;, _(L&quot;Go to next search match&quot;));
 441:         MyAppend(semenu, A_SEARCHPREV, _(L&quot;&amp;Previous Match&quot;) + L&quot;\tSHIFT+F3&quot;,
 442:                  _(L&quot;Go to previous search match&quot;));
 443:         semenu-&gt;AppendSeparator();
 444:         MyAppend(semenu, wxID_REPLACE, _(L&quot;&amp;Replace&quot;) + L&quot;\tCTRL+H&quot;,
 445:                  _(L&quot;Find and replace in document&quot;));
 446:         MyAppend(semenu, A_REPLACEONCE, _(L&quot;Replace in Current &amp;Selection&quot;) + L&quot;\tCTRL+K&quot;);
 447:         MyAppend(semenu, A_REPLACEONCEJ,
 448:                  _(L&quot;Replace in Current Selection &amp;&amp; &amp;Jump Next&quot;) + L&quot;\tCTRL+J&quot;);
 449:         MyAppend(semenu, A_REPLACEALL, _(L&quot;Replace &amp;All&quot;));
 450:         auto scrollmenu = new wxMenu();
 451:         MyAppend(scrollmenu, A_AUP, _(L&quot;Scroll Up (mousewheel)&quot;) + L&quot;\tPGUP&quot;);
 452:         MyAppend(scrollmenu, A_AUP, _(L&quot;Scroll Up (mousewheel)&quot;) + L&quot;\tALT+UP&quot;);
 453:         MyAppend(scrollmenu, A_ADOWN, _(L&quot;Scroll Down (mousewheel)&quot;) + L&quot;\tPGDN&quot;);
 454:         MyAppend(scrollmenu, A_ADOWN, _(L&quot;Scroll Down (mousewheel)&quot;) + L&quot;\tALT+DOWN&quot;);
 455:         MyAppend(scrollmenu, A_ALEFT, _(L&quot;Scroll Left&quot;) + L&quot;\tALT+LEFT&quot;);
 456:         MyAppend(scrollmenu, A_ARIGHT, _(L&quot;Scroll Right&quot;) + L&quot;\tALT+RIGHT&quot;);
 457:         auto filtermenu = new wxMenu();
 458:         MyAppend(filtermenu, A_FILTEROFF, _(L&quot;Turn filter &amp;off&quot;) + L&quot;\tCTRL+SHIFT+F&quot;);
 459:         MyAppend(filtermenu, A_FILTERS, _(L&quot;Show only cells in current search&quot;));
 460:         MyAppend(filtermenu, A_FILTERRANGE, _(L&quot;Show last edits in specific date range&quot;));
 461:         // xgettext:no-c-format
 462:         MyAppend(filtermenu, A_FILTER5, _(L&quot;Show 5% of last edits&quot;));
 463:         // xgettext:no-c-format
 464:         MyAppend(filtermenu, A_FILTER10, _(L&quot;Show 10% of last edits&quot;));
 465:         // xgettext:no-c-format
 466:         MyAppend(filtermenu, A_FILTER20, _(L&quot;Show 20% of last edits&quot;));
 467:         // xgettext:no-c-format
 468:         MyAppend(filtermenu, A_FILTER50, _(L&quot;Show 50% of last edits&quot;));
 469:         // xgettext:no-c-format
 470:         MyAppend(filtermenu, A_FILTERM, _(L&quot;Show 1% more than the last filter&quot;));
 471:         // xgettext:no-c-format
 472:         MyAppend(filtermenu, A_FILTERL, _(L&quot;Show 1% less than the last filter&quot;));
 473:         MyAppend(filtermenu, A_FILTERBYCELLBG, _(L&quot;Filter by the same cell color&quot;));
 474:         MyAppend(filtermenu, A_FILTERMATCHNEXT, _(L&quot;Go to next filter match&quot;) + L&quot;\tCTRL+F3&quot;);
 475:         auto viewmenu = new wxMenu();
 476:         MyAppend(viewmenu, A_ZOOMIN, _(L&quot;Zoom &amp;In (CTRL+mousewheel)&quot;) + L&quot;\tCTRL+PGUP&quot;);
 477:         MyAppend(viewmenu, A_ZOOMOUT, _(L&quot;Zoom &amp;Out (CTRL+mousewheel)&quot;) + L&quot;\tCTRL+PGDN&quot;);
 478:         viewmenu-&gt;AppendSeparator();
 479:         MyAppend(
 480:             viewmenu, A_NEXTFILE,
 481:             _(L&quot;&amp;Next tab&quot;)
 482:                  #ifndef __WXGTK__
 483:                     // On Linux, this conflicts with CTRL+I, see Document::Key()
 484:                     // CTRL+SHIFT+TAB below still works, so that will have to be used to switch tabs.
 485:                      + L&quot;\tCTRL+TAB&quot;
 486:                  #endif
 487:             ,
 488:             _(L&quot;Go to the document in the next tab&quot;));
 489:         MyAppend(viewmenu, A_PREVFILE, _(L&quot;Previous tab&quot;) + L&quot;\tCTRL+SHIFT+TAB&quot;,
 490:                  _(L&quot;Go to the document in the previous tab&quot;));
 491:         viewmenu-&gt;AppendSeparator();
 492:         MyAppend(viewmenu, A_FULLSCREEN,
 493:                  #ifdef __WXMAC__
 494:                  _(L&quot;Toggle &amp;Fullscreen View&quot;) + L&quot;\tCTRL+F11&quot;);
 495:                  #else
 496:                  _(L&quot;Toggle &amp;Fullscreen View&quot;) + L&quot;\tF11&quot;);
 497:                  #endif
 498:         MyAppend(viewmenu, A_SCALED,
 499:                  #ifdef __WXMAC__
 500:                  _(L&quot;Toggle &amp;Scaled Presentation View&quot;) + L&quot;\tCTRL+F12&quot;);
 501:                  #else
 502:                  _(L&quot;Toggle &amp;Scaled Presentation View&quot;) + L&quot;\tF12&quot;);
 503:                  #endif
 504:         viewmenu-&gt;AppendSeparator();
 505:         viewmenu-&gt;AppendSubMenu(scrollmenu, _(L&quot;Scroll Sheet&quot;));
 506:         viewmenu-&gt;AppendSubMenu(filtermenu, _(L&quot;Filter&quot;));
 507:         auto roundmenu = new wxMenu();
 508:         roundmenu-&gt;AppendRadioItem(A_ROUND0, _(L&quot;Radius &amp;0&quot;));
 509:         roundmenu-&gt;AppendRadioItem(A_ROUND1, _(L&quot;Radius &amp;1&quot;));
 510:         roundmenu-&gt;AppendRadioItem(A_ROUND2, _(L&quot;Radius &amp;2&quot;));
 511:         roundmenu-&gt;AppendRadioItem(A_ROUND3, _(L&quot;Radius &amp;3&quot;));
 512:         roundmenu-&gt;AppendRadioItem(A_ROUND4, _(L&quot;Radius &amp;4&quot;));
 513:         roundmenu-&gt;AppendRadioItem(A_ROUND5, _(L&quot;Radius &amp;5&quot;));
 514:         roundmenu-&gt;AppendRadioItem(A_ROUND6, _(L&quot;Radius &amp;6&quot;));
 515:         roundmenu-&gt;Check(sys-&gt;roundness + A_ROUND0, true);
 516:         auto autoexportmenu = new wxMenu();
 517:         autoexportmenu-&gt;AppendRadioItem(A_AUTOEXPORT_HTML_NONE, _(L&quot;No autoexport&quot;));
 518:         autoexportmenu-&gt;AppendRadioItem(A_AUTOEXPORT_HTML_WITH_IMAGES, _(L&quot;Export with images&quot;),
 519:                                         _(L&quot;Export to a HTML file with exported images alongside &quot;
 520:                                           L&quot;the original TreeSheets file when document is saved&quot;));
 521:         autoexportmenu-&gt;AppendRadioItem(A_AUTOEXPORT_HTML_WITHOUT_IMAGES,
 522:                                         _(L&quot;Export without images&quot;),
 523:                                         _(L&quot;Export to a HTML file alongside the original &quot;
 524:                                           L&quot;TreeSheets file when document is saved&quot;));
 525:         autoexportmenu-&gt;Check(sys-&gt;autohtmlexport + A_AUTOEXPORT_HTML_NONE, true);
 526:         auto optmenu = new wxMenu();
 527:         MyAppend(optmenu, wxID_SELECT_FONT, _(L&quot;Font...&quot;),
 528:                  _(L&quot;Set the font the document text is displayed with&quot;));
 529:         MyAppend(optmenu, A_SET_FIXED_FONT, _(L&quot;Typewriter font...&quot;),
 530:                  _(L&quot;Set the font the typewriter text is displayed with.&quot;));
 531:         MyAppend(optmenu, A_CUSTKEY, _(L&quot;Key bindings...&quot;),
 532:                  _(L&quot;Change the key binding of a menu item&quot;));
 533:         MyAppend(optmenu, A_SETLANG, _(L&quot;Change language...&quot;), _(L&quot;Change interface language&quot;));
 534:         MyAppend(optmenu, A_DEFAULTMAXCOLWIDTH, _(L&quot;Default column width...&quot;),
 535:                  _(L&quot;Set the default column width for a new grid&quot;));
 536:         optmenu-&gt;AppendSeparator();
 537:         MyAppend(optmenu, A_CUSTCOL, _(L&quot;Custom &amp;color...&quot;),
 538:                  _(L&quot;Set a custom color for the color dropdowns&quot;));
 539:         MyAppend(
 540:             optmenu, A_COLCELL, _(L&quot;&amp;Set custom color from cell background&quot;),
 541:             _(L&quot;Set a custom color for the color dropdowns from the selected cell background&quot;));
 542:         MyAppend(optmenu, A_DEFBGCOL, _(L&quot;Background color...&quot;),
 543:                  _(L&quot;Set the color for the document background&quot;));
 544:         MyAppend(optmenu, A_DEFCURCOL, _(L&quot;Cu&amp;rsor color...&quot;),
 545:                  _(L&quot;Set the color for the text cursor&quot;));
 546:         optmenu-&gt;AppendSeparator();
 547:         MyAppend(optmenu, A_RESETPERSPECTIVE, _(L&quot;Reset toolbar&quot;),
 548:                  _(L&quot;Reset the toolbar appearance&quot;));
 549:         optmenu-&gt;AppendCheckItem(
 550:             A_SHOWTBAR, _(L&quot;Toolbar&quot;),
 551:             _(L&quot;Toggle whether toolbar is shown between menu bar and documents&quot;));
 552:         optmenu-&gt;Check(A_SHOWTBAR, sys-&gt;showtoolbar);
 553:         optmenu-&gt;AppendCheckItem(A_SHOWSBAR, _(L&quot;Statusbar&quot;),
 554:                                  _(L&quot;Toggle whether statusbar is shown below the documents&quot;));
 555:         optmenu-&gt;Check(A_SHOWSBAR, sys-&gt;showstatusbar);
 556:         optmenu-&gt;AppendCheckItem(
 557:             A_LEFTTABS, _(L&quot;File Tabs on the bottom&quot;),
 558:             _(L&quot;Toggle whether file tabs are shown on top or on bottom of the documents&quot;));
 559:         optmenu-&gt;Check(A_LEFTTABS, lefttabs);
 560:         optmenu-&gt;AppendCheckItem(A_TOTRAY, _(L&quot;Minimize to tray&quot;),
 561:                                  _(L&quot;Toogle whether window is minimized to system tray&quot;));
 562:         optmenu-&gt;Check(A_TOTRAY, sys-&gt;totray);
 563:         optmenu-&gt;AppendCheckItem(A_MINCLOSE, _(L&quot;Minimize on close&quot;),
 564:                                  _(L&quot;Toggle whether the window is minimized instead of closed&quot;));
 565:         optmenu-&gt;Check(A_MINCLOSE, sys-&gt;minclose);
 566:         optmenu-&gt;AppendCheckItem(
 567:             A_SINGLETRAY, _(L&quot;Single click maximize from tray&quot;),
 568:             _(L&quot;Toggle whether only one click is required to maximize from system tray&quot;));
 569:         optmenu-&gt;Check(A_SINGLETRAY, sys-&gt;singletray);
 570:         optmenu-&gt;AppendSeparator();
 571:         optmenu-&gt;AppendCheckItem(A_ZOOMSCR, _(L&quot;Swap mousewheel scrolling and zooming&quot;));
 572:         optmenu-&gt;Check(A_ZOOMSCR, sys-&gt;zoomscroll);
 573:         optmenu-&gt;AppendCheckItem(A_THINSELC, _(L&quot;Navigate in between cells with cursor keys&quot;),
 574:                                  _(L&quot;Toggle whether the cursor keys are used for navigation in addition to text editing&quot;));
 575:         optmenu-&gt;Check(A_THINSELC, sys-&gt;thinselc);
 576:         optmenu-&gt;AppendSeparator();
 577:         optmenu-&gt;AppendCheckItem(A_MAKEBAKS, _(L&quot;Backup files&quot;),
 578:                                  _(L&quot;Create backup file before document is saved to file&quot;));
 579:         optmenu-&gt;Check(A_MAKEBAKS, sys-&gt;makebaks);
 580:         optmenu-&gt;AppendCheckItem(A_AUTOSAVE, _(L&quot;Autosave&quot;),
 581:                                  _(L&quot;Save open documents periodically to temporary files&quot;));
 582:         optmenu-&gt;Check(A_AUTOSAVE, sys-&gt;autosave);
 583:         optmenu-&gt;AppendCheckItem(
 584:             A_FSWATCH, _(L&quot;Autoreload documents&quot;),
 585:             _(L&quot;Reload when another computer has changed a file (if you have made changes, asks)&quot;));
 586:         optmenu-&gt;Check(A_FSWATCH, sys-&gt;fswatch);
 587:         optmenu-&gt;AppendSubMenu(autoexportmenu, _(L&quot;Autoexport to HTML&quot;));
 588:         optmenu-&gt;AppendSeparator();
 589:         optmenu-&gt;AppendCheckItem(
 590:             A_CENTERED, _(L&quot;Render document centered&quot;),
 591:             _(L&quot;Toggle whether documents are rendered centered or left aligned&quot;));
 592:         optmenu-&gt;Check(A_CENTERED, sys-&gt;centered);
 593:         optmenu-&gt;AppendCheckItem(
 594:             A_FASTRENDER, _(L&quot;Faster line rendering&quot;),
 595:             _(L&quot;Toggle whether lines are drawn solid (faster rendering) or dashed&quot;));
 596:         optmenu-&gt;Check(A_FASTRENDER, sys-&gt;fastrender);
 597:         optmenu-&gt;AppendCheckItem(A_INVERTRENDER, _(L&quot;Invert in dark mode&quot;),
 598:                                  _(L&quot;Invert the document in dark mode&quot;));
 599:         optmenu-&gt;Check(A_INVERTRENDER, sys-&gt;followdarkmode);
 600:         optmenu-&gt;AppendSubMenu(roundmenu, _(L&quot;&amp;Roundness of grid borders&quot;));
 601:         #ifdef ENABLE_LOBSTER
 602:             auto scriptmenu = new wxMenu();
 603:             MyAppend(scriptmenu, A_ADDSCRIPT, _(L&quot;Add...&quot;) + L&quot;\tCTRL+ALT+L&quot;,
 604:                      _(L&quot;Add Lobster scripts to the menu&quot;));
 605:             MyAppend(scriptmenu, A_DETSCRIPT, _(L&quot;Remove...&quot;) + L&quot;\tCTRL+SHIFT+ALT+L&quot;,
 606:                      _(L&quot;Remove script from list in the menu&quot;));
 607:             scripts.UseMenu(scriptmenu);
 608:             scripts.SetMenuPathStyle(wxFH_PATH_SHOW_NEVER);
 609:             scripts.AddFilesToMenu();
 610:             auto scriptpath = app-&gt;GetDataPath(&quot;scripts/&quot;);
 611:             auto sf = wxFindFirstFile(scriptpath + L&quot;*.lobster&quot;);
 612:             int sidx = 0;
 613:             while (!sf.empty()) {
 614:                 auto fn = wxFileName::FileName(sf).GetFullName();
 615:                 scripts.AddFileToHistory(fn);
 616:                 sf = wxFindNextFile();
 617:             }
 618:         #endif
 619:         auto markmenu = new wxMenu();
 620:         MyAppend(markmenu, A_MARKDATA, _(L&quot;&amp;Data&quot;) + L&quot;\tCTRL+ALT+D&quot;);
 621:         MyAppend(markmenu, A_MARKCODE, _(L&quot;&amp;Operation&quot;) + L&quot;\tCTRL+ALT+O&quot;);
 622:         MyAppend(markmenu, A_MARKVARD, _(L&quot;Variable &amp;Assign&quot;) + L&quot;\tCTRL+ALT+A&quot;);
 623:         MyAppend(markmenu, A_MARKVARU, _(L&quot;Variable &amp;Read&quot;) + L&quot;\tCTRL+ALT+R&quot;);
 624:         MyAppend(markmenu, A_MARKVIEWH, _(L&quot;&amp;Horizontal View&quot;) + L&quot;\tCTRL+ALT+.&quot;);
 625:         MyAppend(markmenu, A_MARKVIEWV, _(L&quot;&amp;Vertical View&quot;) + L&quot;\tCTRL+ALT+,&quot;);
 626:         auto langmenu = new wxMenu();
 627:         MyAppend(langmenu, wxID_EXECUTE, _(L&quot;&amp;Run&quot;) + L&quot;\tCTRL+ALT+F5&quot;);
 628:         langmenu-&gt;AppendSubMenu(markmenu, _(L&quot;&amp;Mark as&quot;));
 629:         MyAppend(langmenu, A_CLRVIEW, _(L&quot;&amp;Clear Views&quot;));
 630:         auto helpmenu = new wxMenu();
 631:         MyAppend(helpmenu, wxID_ABOUT, _(L&quot;&amp;About...&quot;), _(L&quot;Show About dialog&quot;));
 632:         helpmenu-&gt;AppendSeparator();
 633:         MyAppend(helpmenu, wxID_HELP, _(L&quot;Interactive &amp;tutorial&quot;) + L&quot;\tF1&quot;,
 634:                  _(L&quot;Load an interactive tutorial in TreeSheets&quot;));
 635:         MyAppend(helpmenu, A_HELP_OP_REF, _(L&quot;Operation reference&quot;) + L&quot;\tCTRL+ALT+F1&quot;,
 636:                  _(L&quot;Load an interactive program operation reference in TreeSheets&quot;));
 637:         helpmenu-&gt;AppendSeparator();
 638:         MyAppend(helpmenu, A_TUTORIALWEBPAGE, _(L&quot;Tutorial &amp;web page&quot;),
 639:                  _(L&quot;Open the tutorial web page in browser&quot;));
 640:         #ifdef ENABLE_LOBSTER
 641:             MyAppend(helpmenu, A_SCRIPTREFERENCE, _(L&quot;&amp;Script reference&quot;),
 642:                  _(L&quot;Open the Lobster script reference in browser&quot;));
 643:         #endif
 644:         wxAcceleratorEntry entries[3];
 645:         entries[0].Set(wxACCEL_SHIFT, WXK_DELETE, wxID_CUT);
 646:         entries[1].Set(wxACCEL_SHIFT, WXK_INSERT, wxID_PASTE);
 647:         entries[2].Set(wxACCEL_CTRL, WXK_INSERT, wxID_COPY);
 648:         wxAcceleratorTable accel(3, entries);
 649:         SetAcceleratorTable(accel);
 650:         auto menubar = new wxMenuBar();
 651:         menubar-&gt;Append(filemenu, _(L&quot;&amp;File&quot;));
 652:         menubar-&gt;Append(editmenu, _(L&quot;&amp;Edit&quot;));
 653:         menubar-&gt;Append(semenu, _(L&quot;&amp;Search&quot;));
 654:         menubar-&gt;Append(viewmenu, _(L&quot;&amp;View&quot;));
 655:         menubar-&gt;Append(optmenu, _(L&quot;&amp;Options&quot;));
 656:         #ifdef ENABLE_LOBSTER
 657:             menubar-&gt;Append(scriptmenu, _(L&quot;S&amp;cript&quot;));
 658:         #endif
 659:         menubar-&gt;Append(langmenu, _(L&quot;&amp;Program&quot;));
 660:         menubar-&gt;Append(helpmenu,
 661:                         #ifdef __WXMAC__
 662:                         wxApp::s_macHelpMenuTitleName  // so merges with osx provided help
 663:                         #else
 664:                         _(L&quot;&amp;Help&quot;)
 665:                         #endif
 666:                         );
 667:         #ifdef __WXMAC__
 668:         // these don&apos;t seem to work anymore in the newer wxWidgets, handled in the menu event
 669:         // handler below instead
 670:         wxApp::s_macAboutMenuItemId = wxID_ABOUT;
 671:         wxApp::s_macExitMenuItemId = wxID_EXIT;
 672:         wxApp::s_macPreferencesMenuItemId =
 673:             wxID_SELECT_FONT;  // we have no prefs, so for now just select the font
 674:         #endif
 675:         SetMenuBar(menubar);
 676:         RefreshToolBar();
 677:         auto sb = CreateStatusBar(5);
 678:         SetStatusBarPane(0);
 679:         SetDPIAwareStatusWidths();
 680:         sb-&gt;Show(sys-&gt;showstatusbar);
 681:         notebook =
 682:             new wxAuiNotebook(this, wxID_ANY, wxDefaultPosition, wxDefaultSize,
 683:                               wxAUI_NB_TAB_MOVE | wxAUI_NB_TAB_SPLIT | wxAUI_NB_SCROLL_BUTTONS |
 684:                                   wxAUI_NB_WINDOWLIST_BUTTON | wxAUI_NB_CLOSE_ON_ALL_TABS |
 685:                                   (lefttabs ? wxAUI_NB_BOTTOM : wxAUI_NB_TOP));
 686:         int display_id = wxDisplay::GetFromWindow(this);
 687:         wxRect disprect = wxDisplay(display_id == wxNOT_FOUND ? 0 : display_id).GetClientArea();
 688:         const int boundary = 64;
 689:         const int defx = disprect.width - 2 * boundary;
 690:         const int defy = disprect.height - 2 * boundary;
 691:         int resx, resy, posx, posy;
 692:         sys-&gt;cfg-&gt;Read(L&quot;resx&quot;, &amp;resx, defx);
 693:         sys-&gt;cfg-&gt;Read(L&quot;resy&quot;, &amp;resy, defy);
 694:         sys-&gt;cfg-&gt;Read(L&quot;posx&quot;, &amp;posx, boundary + disprect.x);
 695:         sys-&gt;cfg-&gt;Read(L&quot;posy&quot;, &amp;posy, boundary + disprect.y);
 696:         #ifndef __WXGTK__
 697:         // On X11, disprect only refers to the primary screen. Thus, for a multi-head display,
 698:         // the conditions below might be fulfilled (e.g. large window spanning multiple screens
 699:         // or being on the secondary screen), so just ignore them.
 700:         if (resx &gt; disprect.width || resy &gt; disprect.height || posx &lt; disprect.x ||
 701:             posy &lt; disprect.y || posx + resx &gt; disprect.width + disprect.x ||
 702:             posy + resy &gt; disprect.height + disprect.y) {
 703:             // Screen res has been resized since we last ran, set sizes to default to avoid being
 704:             // off-screen.
 705:             resx = defx;
 706:             resy = defy;
 707:             posx = posy = boundary;
 708:             posx += disprect.x;
 709:             posy += disprect.y;
 710:         }
 711:         #endif
 712:         SetSize(resx, resy);
 713:         Move(posx, posy);
 714:         bool ismax;
 715:         sys-&gt;cfg-&gt;Read(L&quot;maximized&quot;, &amp;ismax, true);
 716:         aui.AddPane(
 717:             notebook,
 718:             wxAuiPaneInfo().Name(&quot;notebook&quot;).Caption(&quot;Notebook&quot;).CenterPane().PaneBorder(false));
 719:         aui.LoadPerspective(sys-&gt;cfg-&gt;Read(L&quot;perspective&quot;, L&quot;&quot;));
 720:         aui.Update();
 721:         Show(!IsIconized());
 722:         // needs to be after Show() to avoid scrollbars rendered in the wrong place?
 723:         if (ismax &amp;&amp; !IsIconized()) Maximize(true);
 724:         SetFileAssoc(app-&gt;exename);
 725:         wxSafeYield();
 726:     }
 727:     wxArrayString GetToolbarPaneNames() {
 728:         wxArrayString toolbarNames;
 729:         wxAuiPaneInfoArray &amp;all_panes = aui.GetAllPanes();
 730:         for (size_t i = 0; i &lt; all_panes.GetCount(); ++i) {
 731:             wxAuiPaneInfo &amp;pane = all_panes.Item(i);
 732:             if (pane.IsToolbar()) { toolbarNames.Add(pane.name); }
 733:         }
 734:         return toolbarNames;
 735:     }
 736:     void DestroyToolbarPane(const wxString &amp;name) {
 737:         wxAuiPaneInfo &amp;pane = aui.GetPane(name);
 738:         if (pane.IsOk()) {
 739:             wxWindow *wnd = pane.window;
 740:             aui.DetachPane(wnd);
 741:             if (wnd) { wnd-&gt;Destroy(); }
 742:         }
 743:     }
 744:     void RefreshToolBar() {
 745:         for (const auto &amp;name : GetToolbarPaneNames()) { DestroyToolbarPane(name); }
 746:         auto iconpath = app-&gt;GetDataPath(L&quot;images/material/toolbar/&quot;);
 747:         auto AddToolbarIcon = [&amp;](wxAuiToolBar *tb, const wxChar *name, int action,
 748:                                   wxString iconpath, wxString lighticon, wxString darkicon) {
 749:             tb-&gt;AddTool(
 750:                 action, name,
 751:                 wxBitmapBundle::FromSVGFile(
 752:                     iconpath + (wxSystemSettings::GetAppearance().IsDark() ? darkicon : lighticon),
 753:                     wxSize(24, 24)),
 754:                 name, wxITEM_NORMAL);
 755:         };
 756:         auto filetb = new wxAuiToolBar(this, wxID_ANY, wxDefaultPosition, wxDefaultSize,
 757:                                        wxAUI_TB_DEFAULT_STYLE);
 758:         AddToolbarIcon(filetb, _(L&quot;New (CTRL+n)&quot;), wxID_NEW, iconpath, L&quot;filenew.svg&quot;,
 759:                        L&quot;filenew_dark.svg&quot;);
 760:         AddToolbarIcon(filetb, _(L&quot;Open (CTRL+o)&quot;), wxID_OPEN, iconpath, L&quot;fileopen.svg&quot;,
 761:                        L&quot;fileopen_dark.svg&quot;);
 762:         AddToolbarIcon(filetb, _(L&quot;Save (CTRL+s)&quot;), wxID_SAVE, iconpath, L&quot;filesave.svg&quot;,
 763:                        L&quot;filesave_dark.svg&quot;);
 764:         AddToolbarIcon(filetb, _(L&quot;Save as...&quot;), wxID_SAVEAS, iconpath, L&quot;filesaveas.svg&quot;,
 765:                        L&quot;filesaveas_dark.svg&quot;);
 766:         filetb-&gt;Realize();
 767:         auto edittb = new wxAuiToolBar(this, wxID_ANY, wxDefaultPosition, wxDefaultSize,
 768:                                        wxAUI_TB_DEFAULT_STYLE);
 769:         AddToolbarIcon(edittb, _(L&quot;Undo (CTRL+z)&quot;), wxID_UNDO, iconpath, L&quot;undo.svg&quot;,
 770:                        L&quot;undo_dark.svg&quot;);
 771:         AddToolbarIcon(edittb, _(L&quot;Copy (CTRL+c)&quot;), wxID_COPY, iconpath, L&quot;editcopy.svg&quot;,
 772:                        L&quot;editcopy_dark.svg&quot;);
 773:         AddToolbarIcon(edittb, _(L&quot;Paste (CTRL+v)&quot;), wxID_PASTE, iconpath, L&quot;editpaste.svg&quot;,
 774:                        L&quot;editpaste_dark.svg&quot;);
 775:         edittb-&gt;Realize();
 776:         auto zoomtb = new wxAuiToolBar(this, wxID_ANY, wxDefaultPosition, wxDefaultSize,
 777:                                        wxAUI_TB_DEFAULT_STYLE);
 778:         AddToolbarIcon(zoomtb, _(L&quot;Zoom In (CTRL+mousewheel)&quot;), A_ZOOMIN, iconpath, L&quot;zoomin.svg&quot;,
 779:                        L&quot;zoomin_dark.svg&quot;);
 780:         AddToolbarIcon(zoomtb, _(L&quot;Zoom Out (CTRL+mousewheel)&quot;), A_ZOOMOUT, iconpath,
 781:                        L&quot;zoomout.svg&quot;, L&quot;zoomout_dark.svg&quot;);
 782:         zoomtb-&gt;Realize();
 783:         auto celltb = new wxAuiToolBar(this, wxID_ANY, wxDefaultPosition, wxDefaultSize,
 784:                                        wxAUI_TB_DEFAULT_STYLE);
 785:         AddToolbarIcon(celltb, _(L&quot;New Grid (INS)&quot;), A_NEWGRID, iconpath, L&quot;newgrid.svg&quot;,
 786:                        L&quot;newgrid_dark.svg&quot;);
 787:         AddToolbarIcon(celltb, _(L&quot;Add Image&quot;), A_IMAGE, iconpath, L&quot;image.svg&quot;, L&quot;image_dark.svg&quot;);
 788:         AddToolbarIcon(celltb, _(L&quot;Run&quot;), wxID_EXECUTE, iconpath, L&quot;run.svg&quot;, L&quot;run_dark.svg&quot;);
 789:         celltb-&gt;Realize();
 790:         auto findtb = new wxAuiToolBar(this, wxID_ANY, wxDefaultPosition, wxDefaultSize,
 791:                                        wxAUI_TB_DEFAULT_STYLE);
 792:         findtb-&gt;AddControl(new wxStaticText(findtb, wxID_ANY, _(L&quot;Search &quot;)));
 793:         findtb-&gt;AddControl(filter = new wxTextCtrl(findtb, A_SEARCH, &quot;&quot;, wxDefaultPosition,
 794:                                                    FromDIP(wxSize(80, 22)),
 795:                                                    wxWANTS_CHARS | wxTE_PROCESS_ENTER));
 796:         AddToolbarIcon(findtb, _(L&quot;Clear search&quot;), A_CLEARSEARCH, iconpath, L&quot;cancel.svg&quot;,
 797:                        L&quot;cancel_dark.svg&quot;);
 798:         AddToolbarIcon(findtb, _(L&quot;Go to Next Search Result&quot;), A_SEARCHNEXT, iconpath,
 799:                        L&quot;search.svg&quot;, L&quot;search_dark.svg&quot;);
 800:         findtb-&gt;Realize();
 801:         auto repltb = new wxAuiToolBar(this, wxID_ANY, wxDefaultPosition, wxDefaultSize,
 802:                                        wxAUI_TB_DEFAULT_STYLE);
 803:         repltb-&gt;AddControl(new wxStaticText(repltb, wxID_ANY, _(L&quot;Replace &quot;)));
 804:         repltb-&gt;AddControl(replaces = new wxTextCtrl(repltb, A_REPLACE, &quot;&quot;, wxDefaultPosition,
 805:                                                      FromDIP(wxSize(80, 22)),
 806:                                                      wxWANTS_CHARS | wxTE_PROCESS_ENTER));
 807:         AddToolbarIcon(repltb, _(L&quot;Clear replace&quot;), A_CLEARREPLACE, iconpath, L&quot;cancel.svg&quot;,
 808:                        L&quot;cancel_dark.svg&quot;);
 809:         AddToolbarIcon(repltb, _(L&quot;Replace in selection&quot;), A_REPLACEONCE, iconpath, L&quot;replace.svg&quot;,
 810:                        L&quot;replace_dark.svg&quot;);
 811:         AddToolbarIcon(repltb, _(L&quot;Replace All&quot;), A_REPLACEALL, iconpath, L&quot;replaceall.svg&quot;,
 812:                        L&quot;replaceall_dark.svg&quot;);
 813:         repltb-&gt;Realize();
 814:         auto cellcolortb = new wxAuiToolBar(this, wxID_ANY, wxDefaultPosition, wxDefaultSize,
 815:                                             wxAUI_TB_DEFAULT_STYLE);
 816:         cellcolortb-&gt;AddControl(new wxStaticText(cellcolortb, wxID_ANY, _(L&quot;Cell &quot;)));
 817:         cellcolordropdown = new ColorDropdown(cellcolortb, A_CELLCOLOR, 1);
 818:         cellcolortb-&gt;AddControl(cellcolordropdown);
 819:         cellcolortb-&gt;Realize();
 820:         auto textcolortb = new wxAuiToolBar(this, wxID_ANY, wxDefaultPosition, wxDefaultSize,
 821:                                             wxAUI_TB_DEFAULT_STYLE);
 822:         textcolortb-&gt;AddControl(new wxStaticText(textcolortb, wxID_ANY, _(L&quot;Text &quot;)));
 823:         textcolordropdown = new ColorDropdown(textcolortb, A_TEXTCOLOR, 2);
 824:         textcolortb-&gt;AddControl(textcolordropdown);
 825:         textcolortb-&gt;Realize();
 826:         auto bordercolortb = new wxAuiToolBar(this, wxID_ANY, wxDefaultPosition, wxDefaultSize,
 827:                                               wxAUI_TB_DEFAULT_STYLE);
 828:         bordercolortb-&gt;AddControl(new wxStaticText(bordercolortb, wxID_ANY, _(L&quot;Border &quot;)));
 829:         bordercolordropdown = new ColorDropdown(bordercolortb, A_BORDCOLOR, 7);
 830:         bordercolortb-&gt;AddControl(bordercolordropdown);
 831:         bordercolortb-&gt;Realize();
 832:         auto imagetb = new wxAuiToolBar(this, wxID_ANY, wxDefaultPosition, wxDefaultSize,
 833:                                         wxAUI_TB_DEFAULT_STYLE);
 834:         imagetb-&gt;AddControl(new wxStaticText(imagetb, wxID_ANY, _(L&quot;Image &quot;)));
 835:         imagedropdown = new ImageDropdown(imagetb, imagepath);
 836:         imagetb-&gt;AddControl(imagedropdown);
 837:         imagetb-&gt;Realize();
 838:         aui.AddPane(filetb, wxAuiPaneInfo()
 839:                                 .Name(&quot;filetb&quot;)
 840:                                 .Caption(&quot;File operations&quot;)
 841:                                 .ToolbarPane()
 842:                                 .Top()
 843:                                 .Row(0)
 844:                                 .LeftDockable(false)
 845:                                 .RightDockable(false)
 846:                                 .Gripper(true));
 847:         aui.AddPane(edittb, wxAuiPaneInfo()
 848:                                 .Name(&quot;edittb&quot;)
 849:                                 .Caption(&quot;Edit operations&quot;)
 850:                                 .ToolbarPane()
 851:                                 .Top()
 852:                                 .Row(0)
 853:                                 .LeftDockable(false)
 854:                                 .RightDockable(false)
 855:                                 .Gripper(true));
 856:         aui.AddPane(zoomtb, wxAuiPaneInfo()
 857:                                 .Name(&quot;zoomtb&quot;)
 858:                                 .Caption(&quot;Zoom operations&quot;)
 859:                                 .ToolbarPane()
 860:                                 .Top()
 861:                                 .Row(0)
 862:                                 .LeftDockable(false)
 863:                                 .RightDockable(false)
 864:                                 .Gripper(true));
 865:         aui.AddPane(celltb, wxAuiPaneInfo()
 866:                                 .Name(&quot;celltb&quot;)
 867:                                 .Caption(&quot;Cell operations&quot;)
 868:                                 .ToolbarPane()
 869:                                 .Top()
 870:                                 .Row(0)
 871:                                 .LeftDockable(false)
 872:                                 .RightDockable(false)
 873:                                 .Gripper(true));
 874:         aui.AddPane(findtb, wxAuiPaneInfo()
 875:                                 .Name(&quot;findtb&quot;)
 876:                                 .Caption(&quot;Find operations&quot;)
 877:                                 .ToolbarPane()
 878:                                 .Top()
 879:                                 .Row(0)
 880:                                 .LeftDockable(false)
 881:                                 .RightDockable(false)
 882:                                 .Gripper(true));
 883:         aui.AddPane(repltb, wxAuiPaneInfo()
 884:                                 .Name(&quot;repltb&quot;)
 885:                                 .Caption(&quot;Replace operations&quot;)
 886:                                 .ToolbarPane()
 887:                                 .Top()
 888:                                 .Row(0)
 889:                                 .LeftDockable(false)
 890:                                 .RightDockable(false)
 891:                                 .Gripper(true));
 892:         aui.AddPane(cellcolortb, wxAuiPaneInfo()
 893:                                      .Name(&quot;cellcolortb&quot;)
 894:                                      .Caption(&quot;Cell color operations&quot;)
 895:                                      .ToolbarPane()
 896:                                      .Top()
 897:                                      .Row(0)
 898:                                      .LeftDockable(false)
 899:                                      .RightDockable(false)
 900:                                      .Gripper(true));
 901:         aui.AddPane(textcolortb, wxAuiPaneInfo()
 902:                                      .Name(&quot;textcolortb&quot;)
 903:                                      .Caption(&quot;Text color operations&quot;)
 904:                                      .ToolbarPane()
 905:                                      .Top()
 906:                                      .Row(0)
 907:                                      .LeftDockable(false)
 908:                                      .RightDockable(false)
 909:                                      .Gripper(true));
 910:         aui.AddPane(bordercolortb, wxAuiPaneInfo()
 911:                                        .Name(&quot;bordercolortb&quot;)
 912:                                        .Caption(&quot;Border color operations&quot;)
 913:                                        .ToolbarPane()
 914:                                        .Top()
 915:                                        .Row(0)
 916:                                        .LeftDockable(false)
 917:                                        .RightDockable(false)
 918:                                        .Gripper(true));
 919:         aui.AddPane(imagetb, wxAuiPaneInfo()
 920:                                  .Name(&quot;imagetb&quot;)
 921:                                  .Caption(&quot;Image operations&quot;)
 922:                                  .ToolbarPane()
 923:                                  .Top()
 924:                                  .Row(0)
 925:                                  .LeftDockable(false)
 926:                                  .RightDockable(false)
 927:                                  .Gripper(true));
 928:     }
 929:     void AppOnEventLoopEnter() {
 930:         watcher = new wxFileSystemWatcher();
 931:         watcher-&gt;SetOwner(this);
 932:         Connect(wxEVT_FSWATCHER, wxFileSystemWatcherEventHandler(TSFrame::OnFileSystemEvent));
 933:     }
 934:     // event handling functions
 935:     void OnMenu(wxCommandEvent &amp;ce) {
 936:         wxTextCtrl *tc;
 937:         auto canvas = GetCurrentTab();
 938:         if ((tc = filter) &amp;&amp; filter == wxWindow::FindFocus() ||
 939:             (tc = replaces) &amp;&amp; replaces == wxWindow::FindFocus()) {
 940:             long from, to;
 941:             tc-&gt;GetSelection(&amp;from, &amp;to);
 942:             switch (ce.GetId()) {
 943:                 #if defined(__WXMSW__) || defined(__WXMAC__)
 944:                 // FIXME: have to emulate this behavior on Windows and Mac because menu always captures these events (??)
 945:                 case A_MLEFT:
 946:                 case A_LEFT:
 947:                     if (from != to)
 948:                         tc-&gt;SetInsertionPoint(from);
 949:                     else if (from)
 950:                         tc-&gt;SetInsertionPoint(from - 1);
 951:                     return;
 952:                 case A_MRIGHT:
 953:                 case A_RIGHT:
 954:                     if (from != to)
 955:                         tc-&gt;SetInsertionPoint(to);
 956:                     else if (to &lt; tc-&gt;GetLineLength(0))
 957:                         tc-&gt;SetInsertionPoint(to + 1);
 958:                     return;
 959:                 case A_SHOME: tc-&gt;SetSelection(0, to); return;
 960:                 case A_SEND: tc-&gt;SetSelection(from, 1000); return;
 961:                 case A_SCLEFT:
 962:                 case A_SLEFT:
 963:                     if (from) tc-&gt;SetSelection(from - 1, to);
 964:                     return;
 965:                 case A_SCRIGHT:
 966:                 case A_SRIGHT:
 967:                     if (to &lt; tc-&gt;GetLineLength(0)) tc-&gt;SetSelection(from, to + 1);
 968:                     return;
 969:                 case A_BACKSPACE: tc-&gt;Remove(from - (from == to), to); return;
 970:                 case A_DELETE: tc-&gt;Remove(from, to + (from == to)); return;
 971:                 case A_HOME: tc-&gt;SetSelection(0, 0); return;
 972:                 case A_END: tc-&gt;SetSelection(1000, 1000); return;
 973:                 case wxID_SELECTALL: tc-&gt;SetSelection(0, 1000); return;
 974:                 #endif
 975:                 #ifdef __WXMSW__
 976:                 case A_ENTERCELL: {
 977:                     if (tc == filter) {
 978:                         // OnSearchEnter equivalent implementation for MSW
 979:                         // as EVT_TEXT_ENTER event is not generated.
 980:                         if (sys-&gt;searchstring.IsEmpty()) {
 981:                             canvas-&gt;SetFocus();
 982:                         } else {
 983:                             canvas-&gt;doc-&gt;Action(A_SEARCHNEXT);
 984:                         }
 985:                     } else if (tc == replaces) {
 986:                         // OnReplaceEnter equivalent implementation for MSW
 987:                         // as EVT_TEXT_ENTER event is not generated.
 988:                         canvas-&gt;doc-&gt;Action(A_REPLACEONCEJ);
 989:                     }
 990:                     return;
 991:                 }
 992:                 #endif
 993:                 case A_CANCELEDIT:
 994:                     tc-&gt;Clear();
 995:                     canvas-&gt;SetFocus();
 996:                     return;
 997:             }
 998:         }
 999:         auto Check = [&amp;](const wxChar *cfg) {
1000:             sys-&gt;cfg-&gt;Write(cfg, ce.IsChecked());
1001:             SetStatus(_(L&quot;change will take effect next run of TreeSheets&quot;));
1002:         };
1003:         switch (ce.GetId()) {
1004:             case A_NOP: break;
1005:             case A_ALEFT: canvas-&gt;CursorScroll(-g_scrollratecursor, 0); break;
1006:             case A_ARIGHT: canvas-&gt;CursorScroll(g_scrollratecursor, 0); break;
1007:             case A_AUP: canvas-&gt;CursorScroll(0, -g_scrollratecursor); break;
1008:             case A_ADOWN: canvas-&gt;CursorScroll(0, g_scrollratecursor); break;
1009:             case A_RESETPERSPECTIVE:
1010:                 RefreshToolBar();
1011:                 sys-&gt;showtoolbar = true;
1012:                 aui.Update();
1013:                 break;
1014:             case A_SHOWSBAR:
1015:                 if (!IsFullScreen()) {
1016:                     sys-&gt;cfg-&gt;Write(L&quot;showstatusbar&quot;, sys-&gt;showstatusbar = ce.IsChecked());
1017:                     auto wsb = GetStatusBar();
1018:                     wsb-&gt;Show(sys-&gt;showstatusbar);
1019:                     SendSizeEvent();
1020:                     Refresh();
1021:                     wsb-&gt;Refresh();
1022:                 }
1023:                 break;
1024:             case A_SHOWTBAR:
1025:                 if (!IsFullScreen()) {
1026:                     sys-&gt;cfg-&gt;Write(L&quot;showtoolbar&quot;, sys-&gt;showtoolbar = ce.IsChecked());
1027:                     for (const auto &amp;name : GetToolbarPaneNames()) {
1028:                         if (sys-&gt;showtoolbar)
1029:                             aui.GetPane(name).Show();
1030:                         else
1031:                             aui.GetPane(name).Hide();
1032:                     }
1033:                     aui.Update();
1034:                 }
1035:                 break;
1036:             case A_CUSTCOL: {
1037:                 if (auto color = PickColor(sys-&gt;frame, sys-&gt;customcolor); color != (uint)-1)
1038:                     sys-&gt;cfg-&gt;Write(L&quot;customcolor&quot;, sys-&gt;customcolor = color);
1039:                 break;
1040:             }
1041:             #ifdef ENABLE_LOBSTER
1042:                 case A_ADDSCRIPT: {
1043:                     wxArrayString filenames;
1044:                     GetFilesFromUser(filenames, this, _(L&quot;Please select Lobster script file(s):&quot;),
1045:                                      _(L&quot;Lobster Files (*.lobster)|*.lobster|All Files (*.*)|*.*&quot;));
1046:                     for (auto &amp;filename : filenames) scripts.AddFileToHistory(filename);
1047:                     break;
1048:                 }
1049:                 case A_DETSCRIPT: {
1050:                     wxArrayString filenames;
1051:                     for (int i = 0, n = scripts.GetCount(); i &lt; n; i++) {
1052:                         filenames.Add(scripts.GetHistoryFile(i));
1053:                     }
1054:                     auto dialog = wxSingleChoiceDialog(
1055:                         this, _(L&quot;Please select the script you want to remove from the list:&quot;),
1056:                         _(L&quot;Remove script from list...&quot;), filenames);
1057:                     if (dialog.ShowModal() == wxID_OK)
1058:                         scripts.RemoveFileFromHistory(dialog.GetSelection());
1059:                     break;
1060:                 }
1061:             #endif
1062:             case A_DEFAULTMAXCOLWIDTH: {
1063:                 int w = wxGetNumberFromUser(_(L&quot;Please enter the default column width:&quot;),
1064:                                             _(L&quot;Width&quot;), _(L&quot;Default column width&quot;),
1065:                                             sys-&gt;defaultmaxcolwidth, 1, 1000, sys-&gt;frame);
1066:                 if (w &gt; 0) sys-&gt;cfg-&gt;Write(L&quot;defaultmaxcolwidth&quot;, sys-&gt;defaultmaxcolwidth = w);
1067:                 break;
1068:             }
1069:             case A_LEFTTABS: Check(L&quot;lefttabs&quot;); break;
1070:             case A_SINGLETRAY: Check(L&quot;singletray&quot;); break;
1071:             case A_MAKEBAKS: sys-&gt;cfg-&gt;Write(L&quot;makebaks&quot;, sys-&gt;makebaks = ce.IsChecked()); break;
1072:             case A_TOTRAY: sys-&gt;cfg-&gt;Write(L&quot;totray&quot;, sys-&gt;totray = ce.IsChecked()); break;
1073:             case A_MINCLOSE: sys-&gt;cfg-&gt;Write(L&quot;minclose&quot;, sys-&gt;minclose = ce.IsChecked()); break;
1074:             case A_ZOOMSCR: sys-&gt;cfg-&gt;Write(L&quot;zoomscroll&quot;, sys-&gt;zoomscroll = ce.IsChecked()); break;
1075:             case A_THINSELC: sys-&gt;cfg-&gt;Write(L&quot;thinselc&quot;, sys-&gt;thinselc = ce.IsChecked()); break;
1076:             case A_AUTOSAVE: sys-&gt;cfg-&gt;Write(L&quot;autosave&quot;, sys-&gt;autosave = ce.IsChecked()); break;
1077:             case A_CENTERED:
1078:                 sys-&gt;cfg-&gt;Write(L&quot;centered&quot;, sys-&gt;centered = ce.IsChecked());
1079:                 Refresh();
1080:                 break;
1081:             case A_FSWATCH:
1082:                 Check(L&quot;fswatch&quot;);
1083:                 sys-&gt;fswatch = ce.IsChecked();
1084:                 break;
1085:             case A_AUTOEXPORT_HTML_NONE:
1086:             case A_AUTOEXPORT_HTML_WITH_IMAGES:
1087:             case A_AUTOEXPORT_HTML_WITHOUT_IMAGES:
1088:                 sys-&gt;cfg-&gt;Write(
1089:                     L&quot;autohtmlexport&quot;,
1090:                     static_cast&lt;long&gt;(sys-&gt;autohtmlexport = ce.GetId() - A_AUTOEXPORT_HTML_NONE));
1091:                 break;
1092:             case A_FASTRENDER:
1093:                 sys-&gt;cfg-&gt;Write(L&quot;fastrender&quot;, sys-&gt;fastrender = ce.IsChecked());
1094:                 Refresh();
1095:                 break;
1096:             case A_INVERTRENDER:
1097:                 sys-&gt;cfg-&gt;Write(L&quot;followdarkmode&quot;, sys-&gt;followdarkmode = ce.IsChecked());
1098:                 sys-&gt;darkmode = sys-&gt;followdarkmode &amp;&amp; wxSystemSettings::GetAppearance().IsDark();
1099:                 Refresh();
1100:                 break;
1101:             case A_FULLSCREEN:
1102:                 ShowFullScreen(!IsFullScreen());
1103:                 if (IsFullScreen()) SetStatus(_(L&quot;Press F11 to exit fullscreen mode.&quot;));
1104:                 break;
1105:             case wxID_FIND:
1106:                 if (filter) {
1107:                     filter-&gt;SetFocus();
1108:                     filter-&gt;SetSelection(0, 1000);
1109:                 } else {
1110:                     SetStatus(_(L&quot;Please enable (Options -&gt; Show Toolbar) to use search.&quot;));
1111:                 }
1112:                 break;
1113:             case wxID_REPLACE:
1114:                 if (replaces) {
1115:                     replaces-&gt;SetFocus();
1116:                     replaces-&gt;SetSelection(0, 1000);
1117:                 } else {
1118:                     SetStatus(_(L&quot;Please enable (Options -&gt; Show Toolbar) to use replace.&quot;));
1119:                 }
1120:                 break;
1121:             #ifdef __WXMAC__
1122:                 case wxID_OSX_HIDE: Iconize(true); break;
1123:                 case wxID_OSX_HIDEOTHERS: SetStatus(L&quot;NOT IMPLEMENTED&quot;); break;
1124:                 case wxID_OSX_SHOWALL: Iconize(false); break;
1125:                 case wxID_ABOUT: canvas-&gt;doc-&gt;Action(wxID_ABOUT); break;
1126:                 case wxID_PREFERENCES: canvas-&gt;doc-&gt;Action(wxID_SELECT_FONT); break;
1127:             #endif
1128:             case wxID_EXIT:
1129:                 fromclosebox = false;
1130:                 Close();
1131:                 break;
1132:             case wxID_CLOSE:
1133:                 canvas-&gt;doc-&gt;Action(ce.GetId());
1134:                 break;  // canvas dangling pointer on return
1135:             default:
1136:                 if (ce.GetId() &gt;= wxID_FILE1 &amp;&amp; ce.GetId() &lt;= wxID_FILE9) {
1137:                     wxString filename(filehistory.GetHistoryFile(ce.GetId() - wxID_FILE1));
1138:                     SetStatus(sys-&gt;Open(filename));
1139:                 #ifdef ENABLE_LOBSTER
1140:                     } else if (ce.GetId() &gt;= A_TAGSET &amp;&amp; ce.GetId() &lt; A_SCRIPT) {
1141:                         SetStatus(canvas-&gt;doc-&gt;TagSet(ce.GetId() - A_TAGSET));
1142:                     } else if (ce.GetId() &gt;= A_SCRIPT &amp;&amp; ce.GetId() &lt; A_MAXACTION) {
1143:                         auto message =
1144:                             tssi.ScriptRun(scripts.GetHistoryFile(ce.GetId() - A_SCRIPT).c_str());
1145:                         message.erase(std::remove(message.begin(), message.end(), &apos;\n&apos;), message.end());
1146:                         SetStatus(wxString(message));
1147:                 #else
1148:                     } else if (ce.GetId() &gt;= A_TAGSET &amp;&amp; ce.GetId() &lt; A_MAXACTION) {
1149:                         SetStatus(canvas-&gt;doc-&gt;TagSet(ce.GetId() - A_TAGSET));
1150:                 #endif
1151:                 } else {
1152:                     SetStatus(canvas-&gt;doc-&gt;Action(ce.GetId()));
1153:                     break;
1154:                 }
1155:         }
1156:     }
1157:     void OnTabChange(wxAuiNotebookEvent &amp;nbe) {
1158:         auto canvas = static_cast&lt;TSCanvas *&gt;(notebook-&gt;GetPage(nbe.GetSelection()));
1159:         SetStatus();
1160:         sys-&gt;TabChange(canvas-&gt;doc);
1161:         nbe.Skip();
1162:     }
1163:     void OnTabClose(wxAuiNotebookEvent &amp;nbe) {
1164:         auto canvas = static_cast&lt;TSCanvas *&gt;(notebook-&gt;GetPage(nbe.GetSelection()));
1165:         if (notebook-&gt;GetPageCount() &lt;= 1) {
1166:             nbe.Veto();
1167:             Close();
1168:         } else if (canvas-&gt;doc-&gt;CloseDocument()) {
1169:             nbe.Veto();
1170:         } else {
1171:             nbe.Skip();
1172:         }
1173:     }
1174:     void OnSearch(wxCommandEvent &amp;ce) {
1175:         auto searchstring = ce.GetString();
1176:         sys-&gt;darkennonmatchingcells = searchstring.Len() != 0;
1177:         sys-&gt;searchstring = sys-&gt;casesensitivesearch ? searchstring : searchstring.Lower();
1178:         TSCanvas *canvas = GetCurrentTab();
1179:         Document *doc = canvas-&gt;doc;
1180:         if (doc-&gt;searchfilter) {
1181:             doc-&gt;SetSearchFilter(sys-&gt;searchstring.Len() != 0);
1182:             doc-&gt;searchfilter = true;
1183:         }
1184:         canvas-&gt;Refresh();
1185:     }
1186:     void OnSearchReplaceEnter(wxCommandEvent &amp;ce) {
1187:         auto canvas = GetCurrentTab();
1188:         if (ce.GetId() == A_SEARCH &amp;&amp; ce.GetString().IsEmpty())
1189:             canvas-&gt;SetFocus();
1190:         else
1191:             canvas-&gt;doc-&gt;Action(ce.GetId() == A_SEARCH ? A_SEARCHNEXT : A_REPLACEONCEJ);
1192:     }
1193:     void OnChangeColor(wxCommandEvent &amp;ce) {
1194:         GetCurrentTab()-&gt;doc-&gt;ColorChange(ce.GetId(), ce.GetInt());
1195:         ReFocus();
1196:     }
1197:     void OnDDImage(wxCommandEvent &amp;ce) {
1198:         GetCurrentTab()-&gt;doc-&gt;ImageChange(imagedropdown-&gt;filenames[ce.GetInt()], dd_icon_res_scale);
1199:         ReFocus();
1200:     }
1201:     void OnActivate(wxActivateEvent &amp;ae) {
1202:         // This causes warnings in the debug log, but without it keyboard entry upon window select
1203:         // doesn&apos;t work.
1204:         ReFocus();
1205:     }
1206:     void OnSizing(wxSizeEvent &amp;se) { se.Skip(); }
1207:     void OnMaximize(wxMaximizeEvent &amp;me) {
1208:         ReFocus();
1209:         me.Skip();
1210:     }
1211:     void OnIconize(wxIconizeEvent &amp;me) {
1212:         if (me.IsIconized()) {
1213:             #ifndef __WXMAC__
1214:             if (sys-&gt;totray) {
1215:                 taskbaricon.SetIcon(icon, L&quot;TreeSheets&quot;);
1216:                 Show(false);
1217:                 Iconize();
1218:             }
1219:             #endif
1220:         } else {
1221:             #ifdef __WXGTK__
1222:             if (sys-&gt;totray) {
1223:                 Show(true);
1224:             }
1225:             #endif
1226:             if (TSCanvas *canvas = GetCurrentTab()) canvas-&gt;SetFocus();
1227:         }
1228:     }
1229:     void OnTBIDBLClick(wxTaskBarIconEvent &amp;e) { DeIconize(); }
1230:     void OnClosing(wxCloseEvent &amp;ce) {
1231:         bool fcb = fromclosebox;
1232:         fromclosebox = true;
1233:         if (fcb &amp;&amp; sys-&gt;minclose) {
1234:             ce.Veto();
1235:             Iconize();
1236:             return;
1237:         }
1238:         sys-&gt;RememberOpenFiles();
1239:         if (ce.CanVeto()) {
1240:             // ask to save/discard all files before closing any
1241:             loop(i, notebook-&gt;GetPageCount()) {
1242:                 auto canvas = static_cast&lt;TSCanvas *&gt;(notebook-&gt;GetPage(i));
1243:                 if (canvas-&gt;doc-&gt;modified) {
1244:                     notebook-&gt;SetSelection(i);
1245:                     if (canvas-&gt;doc-&gt;CheckForChanges()) {
1246:                         ce.Veto();
1247:                         return;
1248:                     }
1249:                 }
1250:             }
1251:             // all files have been saved/discarded
1252:             while (notebook-&gt;GetPageCount()) {
1253:                 GetCurrentTab()-&gt;doc-&gt;RemoveTmpFile();
1254:                 notebook-&gt;DeletePage(notebook-&gt;GetSelection());
1255:             }
1256:         }
1257:         sys-&gt;every_second_timer.Stop();
1258:         filehistory.Save(*sys-&gt;cfg);
1259:         #ifdef ENABLE_LOBSTER
1260:             auto oldpath = sys-&gt;cfg-&gt;GetPath();
1261:             sys-&gt;cfg-&gt;SetPath(&quot;/scripts&quot;);
1262:             scripts.Save(*sys-&gt;cfg);
1263:             sys-&gt;cfg-&gt;SetPath(oldpath);
1264:         #endif
1265:         if (!IsIconized()) {
1266:             sys-&gt;cfg-&gt;Write(L&quot;maximized&quot;, IsMaximized());
1267:             if (!IsMaximized()) {
1268:                 sys-&gt;cfg-&gt;Write(L&quot;resx&quot;, GetSize().x);
1269:                 sys-&gt;cfg-&gt;Write(L&quot;resy&quot;, GetSize().y);
1270:                 sys-&gt;cfg-&gt;Write(L&quot;posx&quot;, GetPosition().x);
1271:                 sys-&gt;cfg-&gt;Write(L&quot;posy&quot;, GetPosition().y);
1272:             }
1273:         }
1274:         sys-&gt;cfg-&gt;Write(L&quot;perspective&quot;, aui.SavePerspective());
1275:         aui.ClearEventHashTable();
1276:         aui.UnInit();
1277:         DELETEP(editmenupopup);
1278:         DELETEP(watcher);
1279:         Destroy();
1280:     }
1281:     void OnFileSystemEvent(wxFileSystemWatcherEvent &amp;event) {
1282:         // 0xF == create/delete/rename/modify
1283:         if ((event.GetChangeType() &amp; 0xF) == 0 || watcherwaitingforuser || !notebook) return;
1284:         const auto &amp;modfile = event.GetPath().GetFullPath();
1285:         loop(i, notebook-&gt;GetPageCount()) {
1286:             Document *doc = static_cast&lt;TSCanvas *&gt;(notebook-&gt;GetPage(i))-&gt;doc;
1287:             if (modfile == doc-&gt;filename) {
1288:                 auto modtime = wxFileName(modfile).GetModificationTime();
1289:                 // Compare with last modified to trigger multiple times.
1290:                 if (!modtime.IsValid() || !doc-&gt;lastmodificationtime.IsValid() ||
1291:                     modtime == doc-&gt;lastmodificationtime) {
1292:                     return;
1293:                 }
1294:                 if (doc-&gt;modified) {
1295:                     // TODO: this dialog is problematic since it may be on an unattended
1296:                     // computer and more of these events may fire. since the occurrence of this
1297:                     // situation is rare, it may be better to just take the most
1298:                     // recently changed version (which is the one that has just been modified
1299:                     // on disk) this potentially throws away local changes, but this can only
1300:                     // happen if the user left changes unsaved, then decided to go edit an older
1301:                     // version on another computer.
1302:                     // for now, we leave this code active, and guard it with
1303:                     // watcherwaitingforuser
1304:                     auto message = wxString::Format(
1305:                         _(L&quot;%s\nhas been modified on disk by another program / computer:\nWould you like to discard your changes and re-load from disk?&quot;),
1306:                         doc-&gt;filename);
1307:                     watcherwaitingforuser = true;
1308:                     int res = wxMessageBox(message, _(L&quot;File modification conflict!&quot;),
1309:                                            wxYES_NO | wxICON_QUESTION, this);
1310:                     watcherwaitingforuser = false;
1311:                     if (res != wxYES) return;
1312:                 }
1313:                 auto message = sys-&gt;LoadDB(doc-&gt;filename, true);
1314:                 assert(message);
1315:                 if (*message) {
1316:                     SetStatus(message);
1317:                 } else {
1318:                     loop(j,
1319:                          notebook-&gt;GetPageCount()) if (static_cast&lt;TSCanvas *&gt;(notebook-&gt;GetPage(j))
1320:                                                            -&gt;doc == doc) notebook-&gt;DeletePage(j);
1321:                     ::wxRemoveFile(sys-&gt;TmpName(modfile));
1322:                     SetStatus(
1323:                         _(L&quot;File has been re-loaded because of modifications of another program / computer&quot;));
1324:                 }
1325:                 return;
1326:             }
1327:         }
1328:     }
1329:     void OnDPIChanged(wxDPIChangedEvent &amp;dce) {
1330:         // block all other events until we finished preparing
1331:         wxEventBlocker blocker(this);
1332:         wxBusyCursor wait;
1333:         {
1334:             ThreadPool pool(std::thread::hardware_concurrency());
1335:             for (const auto &amp;image : sys-&gt;imagelist) {
1336:                 pool.enqueue(
1337:                     [](auto img) {
1338:                         img-&gt;bm_display = wxNullBitmap;
1339:                         img-&gt;Display();
1340:                     },
1341:                     image.get());
1342:             }
1343:         }  // wait until all tasks are finished
1344:         RenderFolderIcon();
1345:         dce.Skip();
1346:     }
1347:     void OnSysColourChanged(wxSysColourChangedEvent &amp;se) {
1348:         sys-&gt;darkmode = sys-&gt;followdarkmode &amp;&amp; wxSystemSettings::GetAppearance().IsDark();
1349:         auto perspective = aui.SavePerspective();
1350:         RefreshToolBar();
1351:         aui.LoadPerspective(perspective);
1352:         aui.Update();
1353:         se.Skip();
1354:     }
1355:     // helper functions
1356:     void CycleTabs(int offset = 1) {
1357:         auto numtabs = static_cast&lt;int&gt;(notebook-&gt;GetPageCount());
1358:         offset = offset &gt;= 0 ? 1 : numtabs - 1;  // normalize to non-negative wrt modulo
1359:         notebook-&gt;SetSelection((notebook-&gt;GetSelection() + offset) % numtabs);
1360:     }
1361:     void DeIconize() {
1362:         if (!IsIconized()) {
1363:             RequestUserAttention();
1364:             return;
1365:         }
1366:         Show(true);
1367:         Iconize(false);
1368:         taskbaricon.RemoveIcon();
1369:     }
1370:     TSCanvas *GetCurrentTab() {
1371:         return notebook ? static_cast&lt;TSCanvas *&gt;(notebook-&gt;GetCurrentPage()) : nullptr;
1372:     }
1373:     TSCanvas *GetTabByFileName(const wxString &amp;filename) {
1374:         if (notebook) loop(i, notebook-&gt;GetPageCount()) {
1375:                 auto canvas = static_cast&lt;TSCanvas *&gt;(notebook-&gt;GetPage(i));
1376:                 if (canvas-&gt;doc-&gt;filename == filename) {
1377:                     notebook-&gt;SetSelection(i);
1378:                     return canvas;
1379:                 }
1380:             }
1381:         return nullptr;
1382:     }
1383:     void MyAppend(wxMenu *menu, int tag, const wxString &amp;contents, const wchar_t *help = L&quot;&quot;) {
1384:         auto item = contents;
1385:         wxString key = L&quot;&quot;;
1386:         if (int pos = contents.Find(&quot;\t&quot;); pos &gt;= 0) {
1387:             item = contents.Mid(0, pos);
1388:             key = contents.Mid(pos + 1);
1389:         }
1390:         key = sys-&gt;cfg-&gt;Read(item, key);
1391:         auto newcontents = item;
1392:         if (key.Length()) newcontents += &quot;\t&quot; + key;
1393:         menu-&gt;Append(tag, newcontents, help);
1394:         menustrings[item] = key;
1395:     }
1396:     TSCanvas *NewTab(Document *doc, bool append = false) {
1397:         TSCanvas *canvas = new TSCanvas(this, notebook);
1398:         canvas-&gt;doc = doc;
1399:         doc-&gt;canvas = canvas;
1400:         canvas-&gt;SetScrollRate(1, 1);
1401:         if (append)
1402:             notebook-&gt;AddPage(canvas, _(L&quot;&lt;unnamed&gt;&quot;), true, wxNullBitmap);
1403:         else
1404:             notebook-&gt;InsertPage(0, canvas, _(L&quot;&lt;unnamed&gt;&quot;), true, wxNullBitmap);
1405:         canvas-&gt;SetDropTarget(new DropTarget(doc-&gt;dndobjc));
1406:         canvas-&gt;SetFocus();
1407:         return canvas;
1408:     }
1409:     void ReFocus() {
1410:         if (TSCanvas *canvas = GetCurrentTab()) canvas-&gt;SetFocus();
1411:     }
1412:     void RenderFolderIcon() {
1413:         wxImage foldiconi;
1414:         foldiconi.LoadFile(app-&gt;GetDataPath(L&quot;images/nuvola/fold.png&quot;));
1415:         foldicon = wxBitmap(foldiconi);
1416:         ScaleBitmap(foldicon, FromDIP(1.0) / 3.0, foldicon);
1417:     }
1418:     void SetDPIAwareStatusWidths() {
1419:         int statusbarfieldwidths[] = {-1, FromDIP(300), FromDIP(120), FromDIP(100), FromDIP(150)};
1420:         SetStatusWidths(5, statusbarfieldwidths);
1421:     }
1422:     void SetFileAssoc(wxString &amp;exename) {
1423:         #ifdef WIN32
1424:         SetRegistryKey(L&quot;HKEY_CURRENT_USER\\Software\\Classes\\.cts&quot;, L&quot;TreeSheets&quot;);
1425:         SetRegistryKey(L&quot;HKEY_CURRENT_USER\\Software\\Classes\\TreeSheets&quot;, L&quot;TreeSheets file&quot;);
1426:         SetRegistryKey(L&quot;HKEY_CURRENT_USER\\Software\\Classes\\TreeSheets\\Shell\\Open\\Command&quot;,
1427:                        wxString(L&quot;\&quot;&quot;) + exename + L&quot;\&quot; \&quot;%1\&quot;&quot;);
1428:         SetRegistryKey(L&quot;HKEY_CURRENT_USER\\Software\\Classes\\TreeSheets\\DefaultIcon&quot;,
1429:                        wxString(L&quot;\&quot;&quot;) + exename + L&quot;\&quot;,0&quot;);
1430:         #else
1431:         // TODO: do something similar for mac/kde/gnome?
1432:         #endif
1433:     }
1434:     void SetPageTitle(const wxString &amp;filename, wxString mods, int page = -1) {
1435:         if (page &lt; 0) page = notebook-&gt;GetSelection();
1436:         if (page &lt; 0) return;
1437:         if (page == notebook-&gt;GetSelection()) SetTitle(L&quot;TreeSheets - &quot; + filename + mods);
1438:         notebook-&gt;SetPageText(
1439:             page,
1440:             (filename.empty() ? wxString(_(L&quot;&lt;unnamed&gt;&quot;)) : wxFileName(filename).GetName()) + mods);
1441:     }
1442:     #ifdef WIN32
1443:     void SetRegistryKey(const wxChar *key, wxString value) {
1444:         wxRegKey registrykey(key);
1445:         registrykey.Create();
1446:         registrykey.SetValue(L&quot;&quot;, value);
1447:     }
1448:     #endif
1449:     void SetStatus(const wxChar *message = nullptr) {
1450:         if (GetStatusBar() &amp;&amp; (!message || *message)) SetStatusText(message ? message : L&quot;&quot;, 0);
1451:     }
1452:     void TabsReset() {
1453:         if (notebook) loop(i, notebook-&gt;GetPageCount()) {
1454:                 auto canvas = static_cast&lt;TSCanvas *&gt;(notebook-&gt;GetPage(i));
1455:                 canvas-&gt;doc-&gt;root-&gt;ResetChildren();
1456:             }
1457:     }
1458:     void UpdateStatus(const Selection &amp;s) {
1459:         if (GetStatusBar()) {
1460:             if (Cell *c = s.GetCell(); c &amp;&amp; s.xs) {
1461:                 SetStatusText(wxString::Format(_(L&quot;Size %d&quot;), -c-&gt;text.relsize), 3);
1462:                 SetStatusText(wxString::Format(_(L&quot;Width %d&quot;), s.grid-&gt;colwidths[s.x]), 2);
1463:                 SetStatusText(
1464:                     wxString::Format(_(L&quot;Edited %s %s&quot;), c-&gt;text.lastedit.FormatDate().c_str(),
1465:                                      c-&gt;text.lastedit.FormatTime().c_str()),
1466:                     1);
1467:             } else
1468:                 for (int field : {1, 2, 3}) SetStatusText(&quot;&quot;, field);
1469:             SetStatusText(wxString::Format(_(L&quot;%d cell(s)&quot;), s.xs * s.ys), 4);
1470:         }
1471:     }
1472:     DECLARE_EVENT_TABLE()
1473: };</file><file path="src/wxtools.h">  1: static void DrawRectangle(wxDC &amp;dc, uint color, int x, int y, int xs, int ys,
  2:                           bool outline = false) {
  3:     if (outline)
  4:         dc.SetBrush(*wxTRANSPARENT_BRUSH);
  5:     else
  6:         dc.SetBrush(wxBrush(wxColour(LightColor(color))));
  7:     dc.SetPen(wxPen(wxColour(LightColor(color))));
  8:     dc.DrawRectangle(x, y, xs, ys);
  9: }
 10: struct DropTarget : wxDropTarget {
 11:     DropTarget(wxDataObject *data) : wxDropTarget(data) {};
 12:     wxDragResult OnDragOver(wxCoord x, wxCoord y, wxDragResult def) {
 13:         auto canvas = sys-&gt;frame-&gt;GetCurrentTab();
 14:         wxClientDC dc(canvas);  // TODO: replace with wxInfoDC starting wxWidgets 3.3.0
 15:         canvas-&gt;doc-&gt;UpdateHover(dc, x, y);
 16:         return canvas-&gt;doc-&gt;hover.grid ? wxDragCopy : wxDragNone;
 17:     }
 18:     bool OnDrop(wxCoord x, wxCoord y) {
 19:         return sys-&gt;frame-&gt;GetCurrentTab()-&gt;doc-&gt;hover.grid != nullptr;
 20:     }
 21:     wxDragResult OnData(wxCoord x, wxCoord y, wxDragResult def) {
 22:         GetData();
 23:         auto canvas = sys-&gt;frame-&gt;GetCurrentTab();
 24:         wxClientDC dc(canvas);  // TODO: replace with wxInfoDC starting wxWidgets 3.3.0
 25:         canvas-&gt;doc-&gt;UpdateHover(dc, x, y);
 26:         canvas-&gt;doc-&gt;SelectClick();
 27:         canvas-&gt;doc-&gt;Drop();
 28:         canvas-&gt;Refresh();
 29:         return wxDragCopy;
 30:     }
 31: };
 32: struct ThreeChoiceDialog : public wxDialog {
 33:     ThreeChoiceDialog(wxWindow *parent, const wxString &amp;title, const wxString &amp;msg,
 34:                       const wxString &amp;ch1, const wxString &amp;ch2, const wxString &amp;ch3)
 35:         : wxDialog(parent, wxID_ANY, title) {
 36:         auto bsv = new wxBoxSizer(wxVERTICAL);
 37:         bsv-&gt;Add(new wxStaticText(this, -1, msg), 0, wxALL, 5);
 38:         auto bsb = new wxBoxSizer(wxHORIZONTAL);
 39:         bsb-&gt;Prepend(new wxButton(this, 2, ch3), 0, wxALL, 5);
 40:         bsb-&gt;PrependStretchSpacer(1);
 41:         bsb-&gt;Prepend(new wxButton(this, 1, ch2), 0, wxALL, 5);
 42:         bsb-&gt;PrependStretchSpacer(1);
 43:         bsb-&gt;Prepend(new wxButton(this, 0, ch1), 0, wxALL, 5);
 44:         bsv-&gt;Add(bsb, 1, wxEXPAND);
 45:         SetSizer(bsv);
 46:         bsv-&gt;SetSizeHints(this);
 47:     }
 48:     void OnButton(wxCommandEvent &amp;ce) { EndModal(ce.GetId()); }
 49:     int Run() { return ShowModal(); }
 50:     DECLARE_EVENT_TABLE()
 51: };
 52: struct DateTimeRangeDialog : public wxDialog {
 53:     wxStaticText introtext {this, wxID_ANY, _(L&quot;Please select the datetime range.&quot;)};
 54:     wxStaticText starttext {this, wxID_ANY, _(L&quot;Start date and time&quot;)};
 55:     wxDatePickerCtrl startdate {this, wxID_ANY};
 56:     wxTimePickerCtrl starttime {this, wxID_ANY};
 57:     wxStaticText endtext {this, wxID_ANY, _(L&quot;End date and time&quot;)};
 58:     wxDatePickerCtrl enddate {this, wxID_ANY};
 59:     wxTimePickerCtrl endtime {this, wxID_ANY};
 60:     wxButton okbtn {this, wxID_OK, _(L&quot;Filter&quot;)};
 61:     wxButton cancelbtn {this, wxID_CANCEL, _(L&quot;Cancel&quot;)};
 62:     wxDateTime begin;
 63:     wxDateTime end;
 64:     DateTimeRangeDialog(wxWindow *parent) : wxDialog(parent, wxID_ANY, _(L&quot;Date and time range&quot;)) {
 65:         wxSizerFlags sizerflags(1);
 66:         auto startsizer = new wxFlexGridSizer(2, wxSize(5, 5));
 67:         startsizer-&gt;Add(&amp;startdate, 0, wxALL, 5);
 68:         startsizer-&gt;Add(&amp;starttime, 0, wxALL, 5);
 69:         auto endsizer = new wxFlexGridSizer(2, wxSize(5, 5));
 70:         endsizer-&gt;Add(&amp;enddate, 0, wxALL, 5);
 71:         endsizer-&gt;Add(&amp;endtime, 0, wxALL, 5);
 72:         auto btnsizer = new wxFlexGridSizer(2, wxSize(5, 5));
 73:         btnsizer-&gt;Add(&amp;okbtn, 0, wxALL, 5);
 74:         btnsizer-&gt;Add(&amp;cancelbtn, 0, wxALL, 5);
 75:         auto topsizer = new wxFlexGridSizer(1);
 76:         topsizer-&gt;Add(&amp;introtext, 0, wxALL, 5);
 77:         topsizer-&gt;Add(&amp;starttext, 0, wxALL, 5);
 78:         topsizer-&gt;Add(startsizer, sizerflags);
 79:         topsizer-&gt;Add(&amp;endtext, 0, wxALL, 5);
 80:         topsizer-&gt;Add(endsizer, sizerflags);
 81:         topsizer-&gt;Add(btnsizer, sizerflags);
 82:         SetSizerAndFit(topsizer);
 83:         topsizer-&gt;SetSizeHints(this);
 84:     }
 85:     void OnButton(wxCommandEvent &amp;ce) {
 86:         if (ce.GetId() == wxID_OK) {
 87:             int starthour, startmin, startsec;
 88:             starttime.GetTime(&amp;starthour, &amp;startmin, &amp;startsec);
 89:             wxTimeSpan starttimespan(starthour, startmin, startsec);
 90:             int endhour, endmin, endsec;
 91:             endtime.GetTime(&amp;endhour, &amp;endmin, &amp;endsec);
 92:             wxTimeSpan endtimespan(endhour, endmin, endsec);
 93:             begin = startdate.GetValue().Add(starttimespan);
 94:             end = enddate.GetValue().Add(endtimespan);
 95:         }
 96:         EndModal(ce.GetId());
 97:     }
 98:     int Run() { return ShowModal(); }
 99:     DECLARE_EVENT_TABLE()
100: };
101: struct ColorPopup : wxVListBoxComboPopup {
102:     ColorPopup(wxWindow *parent) {}
103:     void OnComboDoubleClick() {
104:         sys-&gt;frame-&gt;GetCurrentTab()-&gt;doc-&gt;ColorChange(m_combo-&gt;GetId(), GetSelection());
105:     }
106: };
107: struct ColorDropdown : wxOwnerDrawnComboBox {
108:     ColorDropdown(wxWindow *parent, wxWindowID id, int sel) {
109:         wxArrayString as;
110:         as.Add(L&quot;&quot;, sizeof(celltextcolors) / sizeof(uint));
111:         Create(parent, id, L&quot;&quot;, wxDefaultPosition, FromDIP(wxSize(44, 22)), as,
112:                wxCB_READONLY | wxCC_SPECIAL_DCLICK);
113:         SetPopupControl(new ColorPopup(this));
114:         SetSelection(sel);
115:         SetPopupMaxHeight(wxDisplay().GetGeometry().GetHeight() * 3 / 4);
116:     }
117:     wxCoord OnMeasureItem(size_t item) const { return FromDIP(22); }
118:     wxCoord OnMeasureItemWidth(size_t item) const { return FromDIP(40); }
119:     void OnDrawBackground(wxDC &amp;dc, const wxRect &amp;rect, int item, int flags) const {
120:         DrawRectangle(dc, flags &amp; wxODCB_PAINTING_SELECTED ? 0xA9A9A9 : 0xFFFFFF, rect.x, rect.y,
121:                       rect.width, rect.height);
122:     }
123:     void OnDrawItem(wxDC &amp;dc, const wxRect &amp;rect, int item, int flags) const {
124:         DrawRectangle(dc, item == CUSTOMCOLORIDX ? sys-&gt;customcolor : celltextcolors[item],
125:                       rect.x + 1, rect.y + 1, rect.width - 2, rect.height - 2);
126:         if (item == CUSTOMCOLORIDX) {
127:             dc.SetTextForeground(sys-&gt;darkmode ? *wxWHITE : *wxBLACK);
128:             dc.SetFont(wxFont(9, wxFONTFAMILY_DEFAULT, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL,
129:                               false, L&quot;&quot;));
130:             dc.DrawText(L&quot;Custom&quot;, rect.x + 1, rect.y + 1);
131:         }
132:     }
133: };
134: static uint PickColor(wxWindow *parent, uint defaultcolor) {
135:     auto color = wxGetColourFromUser(parent, wxColour(defaultcolor));
136:     if (color.IsOk()) return (color.Blue() &lt;&lt; 16) + (color.Green() &lt;&lt; 8) + color.Red();
137:     return -1;
138: }
139: static uint LightColor(uint color) {
140:     if (sys-&gt;darkmode) color ^= 0x00FFFFFF;
141:     return color;
142: }
143: #define dd_icon_res_scale 3.0
144: struct ImagePopup : wxVListBoxComboPopup {
145:     void OnComboDoubleClick() {
146:         auto filename = GetString(GetSelection());
147:         sys-&gt;frame-&gt;GetCurrentTab()-&gt;doc-&gt;ImageChange(filename, dd_icon_res_scale);
148:     }
149: };
150: struct ImageDropdown : wxOwnerDrawnComboBox {
151:     vector&lt;unique_ptr&lt;wxBitmap&gt;&gt; bitmaps_display;
152:     wxArrayString filenames;
153:     const int image_space = 22;
154:     ImageDropdown(wxWindow *parent, const wxString &amp;directory) {
155:         FillBitmapVector(directory);
156:         Create(parent, A_DDIMAGE, L&quot;&quot;, wxDefaultPosition,
157:                FromDIP(wxSize(image_space * 2, image_space)), filenames,
158:                wxCB_READONLY | wxCC_SPECIAL_DCLICK);
159:         SetPopupControl(new ImagePopup());
160:         SetSelection(0);
161:         SetPopupMaxHeight(wxDisplay().GetGeometry().GetHeight() * 3 / 4);
162:     }
163:     wxCoord OnMeasureItem(size_t item) const { return FromDIP(image_space); }
164:     wxCoord OnMeasureItemWidth(size_t item) const { return FromDIP(image_space); }
165:     void OnDrawBackground(wxDC &amp;dc, const wxRect &amp;rect, int item, int flags) const {
166:         DrawRectangle(dc, 0xFFFFFF, rect.x, rect.y, rect.width, rect.height);
167:     }
168:     void OnDrawItem(wxDC &amp;dc, const wxRect &amp;rect, int item, int flags) const {
169:         sys-&gt;ImageDraw(bitmaps_display[item].get(), dc, rect.x + FromDIP(3), rect.y + FromDIP(3));
170:     }
171:     void FillBitmapVector(const wxString &amp;directory) {
172:         if (!bitmaps_display.empty()) bitmaps_display.resize(0);
173:         auto filename = wxFindFirstFile(directory + L&quot;*.*&quot;);
174:         while (!filename.empty()) {
175:             wxBitmap bitmap;
176:             if (bitmap.LoadFile(filename, wxBITMAP_TYPE_PNG)) {
177:                 auto scaledbitmap = make_unique&lt;wxBitmap&gt;();
178:                 ScaleBitmap(bitmap, FromDIP(1.0) / dd_icon_res_scale, *scaledbitmap);
179:                 bitmaps_display.push_back(std::move(scaledbitmap));
180:                 filenames.Add(filename);
181:             }
182:             filename = wxFindNextFile();
183:         }
184:     }
185: };
186: static void ScaleBitmap(const wxBitmap &amp;source, double scale, wxBitmap &amp;destination) {
187:     destination = wxBitmap(source.ConvertToImage().Scale(
188:         source.GetWidth() * scale, source.GetHeight() * scale, wxIMAGE_QUALITY_HIGH));
189: }
190: static vector&lt;uint8_t&gt; ConvertWxImageToBuffer(const wxImage &amp;image, wxBitmapType bitmaptype) {
191:     wxMemoryOutputStream imageoutputstream(NULL, 0);
192:     image.SaveFile(imageoutputstream, bitmaptype);
193:     auto size = imageoutputstream.TellO();
194:     vector&lt;uint8_t&gt; buffer(size);
195:     imageoutputstream.CopyTo(buffer.data(), size);
196:     return buffer;
197: }
198: static wxImage ConvertBufferToWxImage(const vector&lt;uint8_t&gt; &amp;buffer, wxBitmapType bitmaptype) {
199:     wxMemoryInputStream imageinputstream(buffer.data(), buffer.size());
200:     wxImage image(imageinputstream, bitmaptype);
201:     if (!image.IsOk()) {
202:         int size = 32;
203:         image.Create(size, size, false);
204:         image.SetRGB(wxRect(0, 0, size, size), 0xFF, 0, 0);
205:         // Set to red to indicate error.
206:     }
207:     return image;
208: }
209: static wxBitmap ConvertBufferToWxBitmap(const vector&lt;uint8_t&gt; &amp;buffer, wxBitmapType bmt) {
210:     auto image = ConvertBufferToWxImage(buffer, bmt);
211:     wxBitmap bitmap(image, 32);
212:     return bitmap;
213: }
214: static uint64_t CalculateHash(vector&lt;uint8_t&gt; &amp;buffer) {
215:     return FNV1A64(buffer.data(), buffer.size());
216: }
217: static void GetFilesFromUser(wxArrayString &amp;filenames, wxWindow *parent, const wxChar *title,
218:                              const wxChar *filter) {
219:     wxFileDialog filedialog(parent, title, L&quot;&quot;, L&quot;&quot;, filter,
220:                             wxFD_OPEN | wxFD_FILE_MUST_EXIST | wxFD_CHANGE_DIR | wxFD_MULTIPLE);
221:     if (filedialog.ShowModal() == wxID_OK) filedialog.GetPaths(filenames);
222: }
223: static void HintIMELocation(Document *doc, int bx, int by, int bh, int stylebits) {
224:     // TODO: implement on other platforms
225:     #ifdef __WXMSW__
226:         HWND hwnd = doc-&gt;canvas-&gt;GetHandle();
227:         if (hwnd == 0) return;
228:         int scrollx, scrolly;
229:         doc-&gt;canvas-&gt;GetViewStart(&amp;scrollx, &amp;scrolly);
230:         int imx = doc-&gt;centerx + (bx + doc-&gt;hierarchysize) * doc-&gt;currentviewscale - scrollx;
231:         int imy = doc-&gt;centery + (by + doc-&gt;hierarchysize) * doc-&gt;currentviewscale - scrolly;
232:         if (HIMC himc = ImmGetContext(hwnd)) {
233:             COMPOSITIONFORM cof = {.dwStyle = CFS_FORCE_POSITION,
234:                                    .ptCurrentPos = {.x = imx, .y = imy}};
235:             ImmSetCompositionWindow(himc, &amp;cof);
236:             LOGFONT lf = {.lfHeight = static_cast&lt;LONG&gt;(-bh * doc-&gt;currentviewscale),
237:                           .lfWeight = stylebits &amp; STYLE_BOLD ? FW_BOLD : FW_REGULAR,
238:                           .lfItalic = static_cast&lt;BYTE&gt;(stylebits &amp; STYLE_ITALIC),
239:                           .lfUnderline = static_cast&lt;BYTE&gt;(stylebits &amp; STYLE_UNDERLINE),
240:                           .lfStrikeOut = static_cast&lt;BYTE&gt;(stylebits &amp; STYLE_STRIKETHRU),
241:                           .lfPitchAndFamily = static_cast&lt;BYTE&gt;(stylebits &amp; STYLE_FIXED
242:                                                                     ? FIXED_PITCH | FF_MODERN
243:                                                                     : VARIABLE_PITCH | FF_SWISS)};
244:             ImmSetCompositionFont(himc, &amp;lf);
245:             CANDIDATEFORM caf = {.dwStyle = CFS_CANDIDATEPOS, .ptCurrentPos = {.x = imx, .y = imy}};
246:             ImmSetCandidateWindow(himc, &amp;caf);
247:             ImmReleaseContext(hwnd, himc);
248:         }
249:     #endif
250: }</file><file path="thirdparty/StackWalker/StackWalker.cpp">   1: /**********************************************************************
   2:  * 
   3:  * StackWalker.cpp
   4:  * http://stackwalker.codeplex.com/
   5:  *
   6:  *
   7:  * History:
   8:  *  2005-07-27   v1    - First public release on http://www.codeproject.com/
   9:  *                       http://www.codeproject.com/threads/StackWalker.asp
  10:  *  2005-07-28   v2    - Changed the params of the constructor and ShowCallstack
  11:  *                       (to simplify the usage)
  12:  *  2005-08-01   v3    - Changed to use &apos;CONTEXT_FULL&apos; instead of CONTEXT_ALL 
  13:  *                       (should also be enough)
  14:  *                     - Changed to compile correctly with the PSDK of VC7.0
  15:  *                       (GetFileVersionInfoSizeA and GetFileVersionInfoA is wrongly defined:
  16:  *                        it uses LPSTR instead of LPCSTR as first paremeter)
  17:  *                     - Added declarations to support VC5/6 without using &apos;dbghelp.h&apos;
  18:  *                     - Added a &apos;pUserData&apos; member to the ShowCallstack function and the 
  19:  *                       PReadProcessMemoryRoutine declaration (to pass some user-defined data, 
  20:  *                       which can be used in the readMemoryFunction-callback)
  21:  *  2005-08-02   v4    - OnSymInit now also outputs the OS-Version by default
  22:  *                     - Added example for doing an exception-callstack-walking in main.cpp
  23:  *                       (thanks to owillebo: http://www.codeproject.com/script/profile/whos_who.asp?id=536268)
  24:  *  2005-08-05   v5    - Removed most Lint (http://www.gimpel.com/) errors... thanks to Okko Willeboordse!
  25:  *  2008-08-04   v6    - Fixed Bug: Missing LEAK-end-tag
  26:  *                       http://www.codeproject.com/KB/applications/leakfinder.aspx?msg=2502890#xx2502890xx
  27:  *                       Fixed Bug: Compiled with &quot;WIN32_LEAN_AND_MEAN&quot;
  28:  *                       http://www.codeproject.com/KB/applications/leakfinder.aspx?msg=1824718#xx1824718xx
  29:  *                       Fixed Bug: Compiling with &quot;/Wall&quot;
  30:  *                       http://www.codeproject.com/KB/threads/StackWalker.aspx?msg=2638243#xx2638243xx
  31:  *                       Fixed Bug: Now checking SymUseSymSrv
  32:  *                       http://www.codeproject.com/KB/threads/StackWalker.aspx?msg=1388979#xx1388979xx
  33:  *                       Fixed Bug: Support for recursive function calls
  34:  *                       http://www.codeproject.com/KB/threads/StackWalker.aspx?msg=1434538#xx1434538xx
  35:  *                       Fixed Bug: Missing FreeLibrary call in &quot;GetModuleListTH32&quot;
  36:  *                       http://www.codeproject.com/KB/threads/StackWalker.aspx?msg=1326923#xx1326923xx
  37:  *                       Fixed Bug: SymDia is number 7, not 9!
  38:  *  2008-09-11   v7      For some (undocumented) reason, dbhelp.h is needing a packing of 8!
  39:  *                       Thanks to Teajay which reported the bug...
  40:  *                       http://www.codeproject.com/KB/applications/leakfinder.aspx?msg=2718933#xx2718933xx
  41:  *  2008-11-27   v8      Debugging Tools for Windows are now stored in a different directory
  42:  *                       Thanks to Luiz Salamon which reported this &quot;bug&quot;...
  43:  *                       http://www.codeproject.com/KB/threads/StackWalker.aspx?msg=2822736#xx2822736xx
  44:  *  2009-04-10   v9      License slihtly corrected (&lt;ORGANIZATION&gt; replaced)
  45:  *  2009-11-01   v10     Moved to http://stackwalker.codeplex.com/
  46:  *  2009-11-02   v11     Now try to use IMAGEHLP_MODULE64_V3 if available
  47:  *  2010-04-15   v12     Added support for VS2010 RTM
  48:  *  2010-05-25   v13     Now using secure MyStrcCpy. Thanks to luke.simon:
  49:  *                       http://www.codeproject.com/KB/applications/leakfinder.aspx?msg=3477467#xx3477467xx
  50:  *  2013-01-07   v14     Runtime Check Error VS2010 Debug Builds fixed:
  51:  *                       http://stackwalker.codeplex.com/workitem/10511
  52:  *
  53:  *
  54:  * LICENSE (http://www.opensource.org/licenses/bsd-license.php)
  55:  *
  56:  *   Copyright (c) 2005-2013, Jochen Kalmbach
  57:  *   All rights reserved.
  58:  *
  59:  *   Redistribution and use in source and binary forms, with or without modification, 
  60:  *   are permitted provided that the following conditions are met:
  61:  *
  62:  *   Redistributions of source code must retain the above copyright notice, 
  63:  *   this list of conditions and the following disclaimer. 
  64:  *   Redistributions in binary form must reproduce the above copyright notice, 
  65:  *   this list of conditions and the following disclaimer in the documentation 
  66:  *   and/or other materials provided with the distribution. 
  67:  *   Neither the name of Jochen Kalmbach nor the names of its contributors may be 
  68:  *   used to endorse or promote products derived from this software without 
  69:  *   specific prior written permission. 
  70:  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
  71:  *   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
  72:  *   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
  73:  *   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE 
  74:  *   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
  75:  *   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
  76:  *   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
  77:  *   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
  78:  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
  79:  *   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  80:  *
  81:  **********************************************************************/
  82: #include &lt;windows.h&gt;
  83: #include &lt;tchar.h&gt;
  84: #include &lt;stdio.h&gt;
  85: #include &lt;stdlib.h&gt;
  86: #pragma comment(lib, &quot;version.lib&quot;)  // for &quot;VerQueryValue&quot;
  87: #pragma warning(disable:4826)
  88: #include &quot;StackWalker.h&quot;
  89: // If VC7 and later, then use the shipped &apos;dbghelp.h&apos;-file
  90: #pragma pack(push,8)
  91: #if _MSC_VER &gt;= 1300
  92: #include &lt;dbghelp.h&gt;
  93: #else
  94: // inline the important dbghelp.h-declarations...
  95: typedef enum {
  96:     SymNone = 0,
  97:     SymCoff,
  98:     SymCv,
  99:     SymPdb,
 100:     SymExport,
 101:     SymDeferred,
 102:     SymSym,
 103:     SymDia,
 104:     SymVirtual,
 105:     NumSymTypes
 106: } SYM_TYPE;
 107: typedef struct _IMAGEHLP_LINE64 {
 108:     DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_LINE64)
 109:     PVOID                       Key;                    // internal
 110:     DWORD                       LineNumber;             // line number in file
 111:     PCHAR                       FileName;               // full filename
 112:     DWORD64                     Address;                // first instruction of line
 113: } IMAGEHLP_LINE64, *PIMAGEHLP_LINE64;
 114: typedef struct _IMAGEHLP_MODULE64 {
 115:     DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
 116:     DWORD64                     BaseOfImage;            // base load address of module
 117:     DWORD                       ImageSize;              // virtual size of the loaded module
 118:     DWORD                       TimeDateStamp;          // date/time stamp from pe header
 119:     DWORD                       CheckSum;               // checksum from the pe header
 120:     DWORD                       NumSyms;                // number of symbols in the symbol table
 121:     SYM_TYPE                    SymType;                // type of symbols loaded
 122:     CHAR                        ModuleName[32];         // module name
 123:     CHAR                        ImageName[256];         // image name
 124:     CHAR                        LoadedImageName[256];   // symbol file name
 125: } IMAGEHLP_MODULE64, *PIMAGEHLP_MODULE64;
 126: typedef struct _IMAGEHLP_SYMBOL64 {
 127:     DWORD                       SizeOfStruct;           // set to sizeof(IMAGEHLP_SYMBOL64)
 128:     DWORD64                     Address;                // virtual address including dll base address
 129:     DWORD                       Size;                   // estimated size of symbol, can be zero
 130:     DWORD                       Flags;                  // info about the symbols, see the SYMF defines
 131:     DWORD                       MaxNameLength;          // maximum size of symbol name in &apos;Name&apos;
 132:     CHAR                        Name[1];                // symbol name (null terminated string)
 133: } IMAGEHLP_SYMBOL64, *PIMAGEHLP_SYMBOL64;
 134: typedef enum {
 135:     AddrMode1616,
 136:     AddrMode1632,
 137:     AddrModeReal,
 138:     AddrModeFlat
 139: } ADDRESS_MODE;
 140: typedef struct _tagADDRESS64 {
 141:     DWORD64       Offset;
 142:     WORD          Segment;
 143:     ADDRESS_MODE  Mode;
 144: } ADDRESS64, *LPADDRESS64;
 145: typedef struct _KDHELP64 {
 146:     DWORD64   Thread;
 147:     DWORD   ThCallbackStack;
 148:     DWORD   ThCallbackBStore;
 149:     DWORD   NextCallback;
 150:     DWORD   FramePointer;
 151:     DWORD64   KiCallUserMode;
 152:     DWORD64   KeUserCallbackDispatcher;
 153:     DWORD64   SystemRangeStart;
 154:     DWORD64  Reserved[8];
 155: } KDHELP64, *PKDHELP64;
 156: typedef struct _tagSTACKFRAME64 {
 157:     ADDRESS64   AddrPC;               // program counter
 158:     ADDRESS64   AddrReturn;           // return address
 159:     ADDRESS64   AddrFrame;            // frame pointer
 160:     ADDRESS64   AddrStack;            // stack pointer
 161:     ADDRESS64   AddrBStore;           // backing store pointer
 162:     PVOID       FuncTableEntry;       // pointer to pdata/fpo or NULL
 163:     DWORD64     Params[4];            // possible arguments to the function
 164:     BOOL        Far;                  // WOW far call
 165:     BOOL        Virtual;              // is this a virtual frame?
 166:     DWORD64     Reserved[3];
 167:     KDHELP64    KdHelp;
 168: } STACKFRAME64, *LPSTACKFRAME64;
 169: typedef
 170: BOOL
 171: (__stdcall *PREAD_PROCESS_MEMORY_ROUTINE64)(
 172:     HANDLE      hProcess,
 173:     DWORD64     qwBaseAddress,
 174:     PVOID       lpBuffer,
 175:     DWORD       nSize,
 176:     LPDWORD     lpNumberOfBytesRead
 177:     );
 178: typedef
 179: PVOID
 180: (__stdcall *PFUNCTION_TABLE_ACCESS_ROUTINE64)(
 181:     HANDLE  hProcess,
 182:     DWORD64 AddrBase
 183:     );
 184: typedef
 185: DWORD64
 186: (__stdcall *PGET_MODULE_BASE_ROUTINE64)(
 187:     HANDLE  hProcess,
 188:     DWORD64 Address
 189:     );
 190: typedef
 191: DWORD64
 192: (__stdcall *PTRANSLATE_ADDRESS_ROUTINE64)(
 193:     HANDLE    hProcess,
 194:     HANDLE    hThread,
 195:     LPADDRESS64 lpaddr
 196:     );
 197: #define SYMOPT_CASE_INSENSITIVE         0x00000001
 198: #define SYMOPT_UNDNAME                  0x00000002
 199: #define SYMOPT_DEFERRED_LOADS           0x00000004
 200: #define SYMOPT_NO_CPP                   0x00000008
 201: #define SYMOPT_LOAD_LINES               0x00000010
 202: #define SYMOPT_OMAP_FIND_NEAREST        0x00000020
 203: #define SYMOPT_LOAD_ANYTHING            0x00000040
 204: #define SYMOPT_IGNORE_CVREC             0x00000080
 205: #define SYMOPT_NO_UNQUALIFIED_LOADS     0x00000100
 206: #define SYMOPT_FAIL_CRITICAL_ERRORS     0x00000200
 207: #define SYMOPT_EXACT_SYMBOLS            0x00000400
 208: #define SYMOPT_ALLOW_ABSOLUTE_SYMBOLS   0x00000800
 209: #define SYMOPT_IGNORE_NT_SYMPATH        0x00001000
 210: #define SYMOPT_INCLUDE_32BIT_MODULES    0x00002000
 211: #define SYMOPT_PUBLICS_ONLY             0x00004000
 212: #define SYMOPT_NO_PUBLICS               0x00008000
 213: #define SYMOPT_AUTO_PUBLICS             0x00010000
 214: #define SYMOPT_NO_IMAGE_SEARCH          0x00020000
 215: #define SYMOPT_SECURE                   0x00040000
 216: #define SYMOPT_DEBUG                    0x80000000
 217: #define UNDNAME_COMPLETE                 (0x0000)  // Enable full undecoration
 218: #define UNDNAME_NAME_ONLY                (0x1000)  // Crack only the name for primary declaration;
 219: #endif  // _MSC_VER &lt; 1300
 220: #pragma pack(pop)
 221: // Some missing defines (for VC5/6):
 222: #ifndef INVALID_FILE_ATTRIBUTES
 223: #define INVALID_FILE_ATTRIBUTES ((DWORD)-1)
 224: #endif  
 225: // secure-CRT_functions are only available starting with VC8
 226: #if _MSC_VER &lt; 1400
 227: #define strcpy_s(dst, len, src) strcpy(dst, src)
 228: #define strncpy_s(dst, len, src, maxLen) strncpy(dst, len, src)
 229: #define strcat_s(dst, len, src) strcat(dst, src)
 230: #define _snprintf_s _snprintf
 231: #define _tcscat_s _tcscat
 232: #endif
 233: static void MyStrCpy(char* szDest, size_t nMaxDestSize, const char* szSrc)
 234: {
 235:   if (nMaxDestSize &lt;= 0) return;
 236:   strncpy_s(szDest, nMaxDestSize, szSrc, _TRUNCATE);
 237:   szDest[nMaxDestSize-1] = 0;  // INFO: _TRUNCATE will ensure that it is nul-terminated; but with older compilers (&lt;1400) it uses &quot;strncpy&quot; and this does not!)
 238: }  // MyStrCpy
 239: // Normally it should be enough to use &apos;CONTEXT_FULL&apos; (better would be &apos;CONTEXT_ALL&apos;)
 240: #define USED_CONTEXT_FLAGS CONTEXT_FULL
 241: class StackWalkerInternal
 242: {
 243: public:
 244:   StackWalkerInternal(StackWalker *parent, HANDLE hProcess)
 245:   {
 246:     m_parent = parent;
 247:     m_hDbhHelp = NULL;
 248:     pSC = NULL;
 249:     m_hProcess = hProcess;
 250:     m_szSymPath = NULL;
 251:     pSFTA = NULL;
 252:     pSGLFA = NULL;
 253:     pSGMB = NULL;
 254:     pSGMI = NULL;
 255:     pSGO = NULL;
 256:     pSGSFA = NULL;
 257:     pSI = NULL;
 258:     pSLM = NULL;
 259:     pSSO = NULL;
 260:     pSW = NULL;
 261:     pUDSN = NULL;
 262:     pSGSP = NULL;
 263:   }
 264:   ~StackWalkerInternal()
 265:   {
 266:     if (pSC != NULL)
 267:       pSC(m_hProcess);  // SymCleanup
 268:     if (m_hDbhHelp != NULL)
 269:       FreeLibrary(m_hDbhHelp);
 270:     m_hDbhHelp = NULL;
 271:     m_parent = NULL;
 272:     if(m_szSymPath != NULL)
 273:       free(m_szSymPath);
 274:     m_szSymPath = NULL;
 275:   }
 276:   BOOL Init(LPCSTR szSymPath)
 277:   {
 278:     if (m_parent == NULL)
 279:       return FALSE;
 280:     // Dynamically load the Entry-Points for dbghelp.dll:
 281:     // First try to load the newsest one from
 282:     TCHAR szTemp[4096];
 283:     // But before wqe do this, we first check if the &quot;.local&quot; file exists
 284:     if (GetModuleFileName(NULL, szTemp, 4096) &gt; 0)
 285:     {
 286:       _tcscat_s(szTemp, _T(&quot;.local&quot;));
 287:       if (GetFileAttributes(szTemp) == INVALID_FILE_ATTRIBUTES)
 288:       {
 289:         // &quot;.local&quot; file does not exist, so we can try to load the dbghelp.dll from the &quot;Debugging Tools for Windows&quot;
 290:         // Ok, first try the new path according to the archtitecture:
 291: #ifdef _M_IX86
 292:         if ( (m_hDbhHelp == NULL) &amp;&amp; (GetEnvironmentVariable(_T(&quot;ProgramFiles&quot;), szTemp, 4096) &gt; 0) )
 293:         {
 294:           _tcscat_s(szTemp, _T(&quot;\\Debugging Tools for Windows (x86)\\dbghelp.dll&quot;));
 295:           // now check if the file exists:
 296:           if (GetFileAttributes(szTemp) != INVALID_FILE_ATTRIBUTES)
 297:           {
 298:             m_hDbhHelp = LoadLibrary(szTemp);
 299:           }
 300:         }
 301: #elif _M_X64
 302:         if ( (m_hDbhHelp == NULL) &amp;&amp; (GetEnvironmentVariable(_T(&quot;ProgramFiles&quot;), szTemp, 4096) &gt; 0) )
 303:         {
 304:           _tcscat_s(szTemp, _T(&quot;\\Debugging Tools for Windows (x64)\\dbghelp.dll&quot;));
 305:           // now check if the file exists:
 306:           if (GetFileAttributes(szTemp) != INVALID_FILE_ATTRIBUTES)
 307:           {
 308:             m_hDbhHelp = LoadLibrary(szTemp);
 309:           }
 310:         }
 311: #elif _M_IA64
 312:         if ( (m_hDbhHelp == NULL) &amp;&amp; (GetEnvironmentVariable(_T(&quot;ProgramFiles&quot;), szTemp, 4096) &gt; 0) )
 313:         {
 314:           _tcscat_s(szTemp, _T(&quot;\\Debugging Tools for Windows (ia64)\\dbghelp.dll&quot;));
 315:           // now check if the file exists:
 316:           if (GetFileAttributes(szTemp) != INVALID_FILE_ATTRIBUTES)
 317:           {
 318:             m_hDbhHelp = LoadLibrary(szTemp);
 319:           }
 320:         }
 321: #endif
 322:         // If still not found, try the old directories...
 323:         if ( (m_hDbhHelp == NULL) &amp;&amp; (GetEnvironmentVariable(_T(&quot;ProgramFiles&quot;), szTemp, 4096) &gt; 0) )
 324:         {
 325:           _tcscat_s(szTemp, _T(&quot;\\Debugging Tools for Windows\\dbghelp.dll&quot;));
 326:           // now check if the file exists:
 327:           if (GetFileAttributes(szTemp) != INVALID_FILE_ATTRIBUTES)
 328:           {
 329:             m_hDbhHelp = LoadLibrary(szTemp);
 330:           }
 331:         }
 332: #if defined _M_X64 || defined _M_IA64
 333:         // Still not found? Then try to load the (old) 64-Bit version:
 334:         if ( (m_hDbhHelp == NULL) &amp;&amp; (GetEnvironmentVariable(_T(&quot;ProgramFiles&quot;), szTemp, 4096) &gt; 0) )
 335:         {
 336:           _tcscat_s(szTemp, _T(&quot;\\Debugging Tools for Windows 64-Bit\\dbghelp.dll&quot;));
 337:           if (GetFileAttributes(szTemp) != INVALID_FILE_ATTRIBUTES)
 338:           {
 339:             m_hDbhHelp = LoadLibrary(szTemp);
 340:           }
 341:         }
 342: #endif
 343:       }
 344:     }
 345:     if (m_hDbhHelp == NULL)  // if not already loaded, try to load a default-one
 346:       m_hDbhHelp = LoadLibrary( _T(&quot;dbghelp.dll&quot;) );
 347:     if (m_hDbhHelp == NULL)
 348:       return FALSE;
 349:     pSI = (tSI) GetProcAddress(m_hDbhHelp, &quot;SymInitialize&quot; );
 350:     pSC = (tSC) GetProcAddress(m_hDbhHelp, &quot;SymCleanup&quot; );
 351:     pSW = (tSW) GetProcAddress(m_hDbhHelp, &quot;StackWalk64&quot; );
 352:     pSGO = (tSGO) GetProcAddress(m_hDbhHelp, &quot;SymGetOptions&quot; );
 353:     pSSO = (tSSO) GetProcAddress(m_hDbhHelp, &quot;SymSetOptions&quot; );
 354:     pSFTA = (tSFTA) GetProcAddress(m_hDbhHelp, &quot;SymFunctionTableAccess64&quot; );
 355:     pSGLFA = (tSGLFA) GetProcAddress(m_hDbhHelp, &quot;SymGetLineFromAddr64&quot; );
 356:     pSGMB = (tSGMB) GetProcAddress(m_hDbhHelp, &quot;SymGetModuleBase64&quot; );
 357:     pSGMI = (tSGMI) GetProcAddress(m_hDbhHelp, &quot;SymGetModuleInfo64&quot; );
 358:     pSGSFA = (tSGSFA) GetProcAddress(m_hDbhHelp, &quot;SymGetSymFromAddr64&quot; );
 359:     pUDSN = (tUDSN) GetProcAddress(m_hDbhHelp, &quot;UnDecorateSymbolName&quot; );
 360:     pSLM = (tSLM) GetProcAddress(m_hDbhHelp, &quot;SymLoadModule64&quot; );
 361:     pSGSP =(tSGSP) GetProcAddress(m_hDbhHelp, &quot;SymGetSearchPath&quot; );
 362:     if ( pSC == NULL || pSFTA == NULL || pSGMB == NULL || pSGMI == NULL ||
 363:       pSGO == NULL || pSGSFA == NULL || pSI == NULL || pSSO == NULL ||
 364:       pSW == NULL || pUDSN == NULL || pSLM == NULL )
 365:     {
 366:       FreeLibrary(m_hDbhHelp);
 367:       m_hDbhHelp = NULL;
 368:       pSC = NULL;
 369:       return FALSE;
 370:     }
 371:     // SymInitialize
 372:     if (szSymPath != NULL)
 373:       m_szSymPath = _strdup(szSymPath);
 374:     if (this-&gt;pSI(m_hProcess, m_szSymPath, FALSE) == FALSE)
 375:       this-&gt;m_parent-&gt;OnDbgHelpErr(&quot;SymInitialize&quot;, GetLastError(), 0);
 376:     DWORD symOptions = this-&gt;pSGO();  // SymGetOptions
 377:     symOptions |= SYMOPT_LOAD_LINES;
 378:     symOptions |= SYMOPT_FAIL_CRITICAL_ERRORS;
 379:     //symOptions |= SYMOPT_NO_PROMPTS;
 380:     // SymSetOptions
 381:     symOptions = this-&gt;pSSO(symOptions);
 382:     char buf[StackWalker::STACKWALK_MAX_NAMELEN] = {0};
 383:     if (this-&gt;pSGSP != NULL)
 384:     {
 385:       if (this-&gt;pSGSP(m_hProcess, buf, StackWalker::STACKWALK_MAX_NAMELEN) == FALSE)
 386:         this-&gt;m_parent-&gt;OnDbgHelpErr(&quot;SymGetSearchPath&quot;, GetLastError(), 0);
 387:     }
 388:     char szUserName[1024] = {0};
 389:     DWORD dwSize = 1024;
 390:     GetUserNameA(szUserName, &amp;dwSize);
 391:     this-&gt;m_parent-&gt;OnSymInit(buf, symOptions, szUserName);
 392:     return TRUE;
 393:   }
 394:   StackWalker *m_parent;
 395:   HMODULE m_hDbhHelp;
 396:   HANDLE m_hProcess;
 397:   LPSTR m_szSymPath;
 398: #pragma pack(push,8)
 399: typedef struct IMAGEHLP_MODULE64_V3 {
 400:     DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
 401:     DWORD64  BaseOfImage;            // base load address of module
 402:     DWORD    ImageSize;              // virtual size of the loaded module
 403:     DWORD    TimeDateStamp;          // date/time stamp from pe header
 404:     DWORD    CheckSum;               // checksum from the pe header
 405:     DWORD    NumSyms;                // number of symbols in the symbol table
 406:     SYM_TYPE SymType;                // type of symbols loaded
 407:     CHAR     ModuleName[32];         // module name
 408:     CHAR     ImageName[256];         // image name
 409:     CHAR     LoadedImageName[256];   // symbol file name
 410:     // new elements: 07-Jun-2002
 411:     CHAR     LoadedPdbName[256];     // pdb file name
 412:     DWORD    CVSig;                  // Signature of the CV record in the debug directories
 413:     CHAR     CVData[MAX_PATH * 3];   // Contents of the CV record
 414:     DWORD    PdbSig;                 // Signature of PDB
 415:     GUID     PdbSig70;               // Signature of PDB (VC 7 and up)
 416:     DWORD    PdbAge;                 // DBI age of pdb
 417:     BOOL     PdbUnmatched;           // loaded an unmatched pdb
 418:     BOOL     DbgUnmatched;           // loaded an unmatched dbg
 419:     BOOL     LineNumbers;            // we have line number information
 420:     BOOL     GlobalSymbols;          // we have internal symbol information
 421:     BOOL     TypeInfo;               // we have type information
 422:     // new elements: 17-Dec-2003
 423:     BOOL     SourceIndexed;          // pdb supports source server
 424:     BOOL     Publics;                // contains public symbols
 425: };
 426: typedef struct IMAGEHLP_MODULE64_V2 {
 427:     DWORD    SizeOfStruct;           // set to sizeof(IMAGEHLP_MODULE64)
 428:     DWORD64  BaseOfImage;            // base load address of module
 429:     DWORD    ImageSize;              // virtual size of the loaded module
 430:     DWORD    TimeDateStamp;          // date/time stamp from pe header
 431:     DWORD    CheckSum;               // checksum from the pe header
 432:     DWORD    NumSyms;                // number of symbols in the symbol table
 433:     SYM_TYPE SymType;                // type of symbols loaded
 434:     CHAR     ModuleName[32];         // module name
 435:     CHAR     ImageName[256];         // image name
 436:     CHAR     LoadedImageName[256];   // symbol file name
 437: };
 438: #pragma pack(pop)
 439:   // SymCleanup()
 440:   typedef BOOL (__stdcall *tSC)( IN HANDLE hProcess );
 441:   tSC pSC;
 442:   // SymFunctionTableAccess64()
 443:   typedef PVOID (__stdcall *tSFTA)( HANDLE hProcess, DWORD64 AddrBase );
 444:   tSFTA pSFTA;
 445:   // SymGetLineFromAddr64()
 446:   typedef BOOL (__stdcall *tSGLFA)( IN HANDLE hProcess, IN DWORD64 dwAddr,
 447:     OUT PDWORD pdwDisplacement, OUT PIMAGEHLP_LINE64 Line );
 448:   tSGLFA pSGLFA;
 449:   // SymGetModuleBase64()
 450:   typedef DWORD64 (__stdcall *tSGMB)( IN HANDLE hProcess, IN DWORD64 dwAddr );
 451:   tSGMB pSGMB;
 452:   // SymGetModuleInfo64()
 453:   typedef BOOL (__stdcall *tSGMI)( IN HANDLE hProcess, IN DWORD64 dwAddr, OUT IMAGEHLP_MODULE64_V3 *ModuleInfo );
 454:   tSGMI pSGMI;
 455:   // SymGetOptions()
 456:   typedef DWORD (__stdcall *tSGO)( VOID );
 457:   tSGO pSGO;
 458:   // SymGetSymFromAddr64()
 459:   typedef BOOL (__stdcall *tSGSFA)( IN HANDLE hProcess, IN DWORD64 dwAddr,
 460:     OUT PDWORD64 pdwDisplacement, OUT PIMAGEHLP_SYMBOL64 Symbol );
 461:   tSGSFA pSGSFA;
 462:   // SymInitialize()
 463:   typedef BOOL (__stdcall *tSI)( IN HANDLE hProcess, IN PSTR UserSearchPath, IN BOOL fInvadeProcess );
 464:   tSI pSI;
 465:   // SymLoadModule64()
 466:   typedef DWORD64 (__stdcall *tSLM)( IN HANDLE hProcess, IN HANDLE hFile,
 467:     IN PSTR ImageName, IN PSTR ModuleName, IN DWORD64 BaseOfDll, IN DWORD SizeOfDll );
 468:   tSLM pSLM;
 469:   // SymSetOptions()
 470:   typedef DWORD (__stdcall *tSSO)( IN DWORD SymOptions );
 471:   tSSO pSSO;
 472:   // StackWalk64()
 473:   typedef BOOL (__stdcall *tSW)( 
 474:     DWORD MachineType, 
 475:     HANDLE hProcess,
 476:     HANDLE hThread, 
 477:     LPSTACKFRAME64 StackFrame, 
 478:     PVOID ContextRecord,
 479:     PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine,
 480:     PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine,
 481:     PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine,
 482:     PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress );
 483:   tSW pSW;
 484:   // UnDecorateSymbolName()
 485:   typedef DWORD (__stdcall WINAPI *tUDSN)( PCSTR DecoratedName, PSTR UnDecoratedName,
 486:     DWORD UndecoratedLength, DWORD Flags );
 487:   tUDSN pUDSN;
 488:   typedef BOOL (__stdcall WINAPI *tSGSP)(HANDLE hProcess, PSTR SearchPath, DWORD SearchPathLength);
 489:   tSGSP pSGSP;
 490: private:
 491:   // **************************************** ToolHelp32 ************************
 492:   #define MAX_MODULE_NAME32 255
 493:   #define TH32CS_SNAPMODULE   0x00000008
 494:   #pragma pack( push, 8 )
 495:   typedef struct tagMODULEENTRY32
 496:   {
 497:       DWORD   dwSize;
 498:       DWORD   th32ModuleID;       // This module
 499:       DWORD   th32ProcessID;      // owning process
 500:       DWORD   GlblcntUsage;       // Global usage count on the module
 501:       DWORD   ProccntUsage;       // Module usage count in th32ProcessID&apos;s context
 502:       BYTE  * modBaseAddr;        // Base address of module in th32ProcessID&apos;s context
 503:       DWORD   modBaseSize;        // Size in bytes of module starting at modBaseAddr
 504:       HMODULE hModule;            // The hModule of this module in th32ProcessID&apos;s context
 505:       char    szModule[MAX_MODULE_NAME32 + 1];
 506:       char    szExePath[MAX_PATH];
 507:   } MODULEENTRY32;
 508:   typedef MODULEENTRY32 *  PMODULEENTRY32;
 509:   typedef MODULEENTRY32 *  LPMODULEENTRY32;
 510:   #pragma pack( pop )
 511:   BOOL GetModuleListTH32(HANDLE hProcess, DWORD pid)
 512:   {
 513:     // CreateToolhelp32Snapshot()
 514:     typedef HANDLE (__stdcall *tCT32S)(DWORD dwFlags, DWORD th32ProcessID);
 515:     // Module32First()
 516:     typedef BOOL (__stdcall *tM32F)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
 517:     // Module32Next()
 518:     typedef BOOL (__stdcall *tM32N)(HANDLE hSnapshot, LPMODULEENTRY32 lpme);
 519:     // try both dlls...
 520:     const TCHAR *dllname[] = { _T(&quot;kernel32.dll&quot;), _T(&quot;tlhelp32.dll&quot;) };
 521:     HINSTANCE hToolhelp = NULL;
 522:     tCT32S pCT32S = NULL;
 523:     tM32F pM32F = NULL;
 524:     tM32N pM32N = NULL;
 525:     HANDLE hSnap;
 526:     MODULEENTRY32 me;
 527:     me.dwSize = sizeof(me);
 528:     BOOL keepGoing;
 529:     size_t i;
 530:     for (i = 0; i&lt;(sizeof(dllname) / sizeof(dllname[0])); i++ )
 531:     {
 532:       hToolhelp = LoadLibrary( dllname[i] );
 533:       if (hToolhelp == NULL)
 534:         continue;
 535:       pCT32S = (tCT32S) GetProcAddress(hToolhelp, &quot;CreateToolhelp32Snapshot&quot;);
 536:       pM32F = (tM32F) GetProcAddress(hToolhelp, &quot;Module32First&quot;);
 537:       pM32N = (tM32N) GetProcAddress(hToolhelp, &quot;Module32Next&quot;);
 538:       if ( (pCT32S != NULL) &amp;&amp; (pM32F != NULL) &amp;&amp; (pM32N != NULL) )
 539:         break; // found the functions!
 540:       FreeLibrary(hToolhelp);
 541:       hToolhelp = NULL;
 542:     }
 543:     if (hToolhelp == NULL)
 544:       return FALSE;
 545:     hSnap = pCT32S( TH32CS_SNAPMODULE, pid );
 546:     if (hSnap == (HANDLE) -1)
 547:     {
 548:       FreeLibrary(hToolhelp);
 549:       return FALSE;
 550:     }
 551:     keepGoing = !!pM32F( hSnap, &amp;me );
 552:     int cnt = 0;
 553:     while (keepGoing)
 554:     {
 555:       this-&gt;LoadModule(hProcess, me.szExePath, me.szModule, (DWORD64) me.modBaseAddr, me.modBaseSize);
 556:       cnt++;
 557:       keepGoing = !!pM32N( hSnap, &amp;me );
 558:     }
 559:     CloseHandle(hSnap);
 560:     FreeLibrary(hToolhelp);
 561:     if (cnt &lt;= 0)
 562:       return FALSE;
 563:     return TRUE;
 564:   }  // GetModuleListTH32
 565:   // **************************************** PSAPI ************************
 566:   typedef struct _MODULEINFO {
 567:       LPVOID lpBaseOfDll;
 568:       DWORD SizeOfImage;
 569:       LPVOID EntryPoint;
 570:   } MODULEINFO, *LPMODULEINFO;
 571:   BOOL GetModuleListPSAPI(HANDLE hProcess)
 572:   {
 573:     // EnumProcessModules()
 574:     typedef BOOL (__stdcall *tEPM)(HANDLE hProcess, HMODULE *lphModule, DWORD cb, LPDWORD lpcbNeeded );
 575:     // GetModuleFileNameEx()
 576:     typedef DWORD (__stdcall *tGMFNE)(HANDLE hProcess, HMODULE hModule, LPSTR lpFilename, DWORD nSize );
 577:     // GetModuleBaseName()
 578:     typedef DWORD (__stdcall *tGMBN)(HANDLE hProcess, HMODULE hModule, LPSTR lpFilename, DWORD nSize );
 579:     // GetModuleInformation()
 580:     typedef BOOL (__stdcall *tGMI)(HANDLE hProcess, HMODULE hModule, LPMODULEINFO pmi, DWORD nSize );
 581:     HINSTANCE hPsapi;
 582:     tEPM pEPM;
 583:     tGMFNE pGMFNE;
 584:     tGMBN pGMBN;
 585:     tGMI pGMI;
 586:     DWORD i;
 587:     //ModuleEntry e;
 588:     DWORD cbNeeded;
 589:     MODULEINFO mi;
 590:     HMODULE *hMods = 0;
 591:     char *tt = NULL;
 592:     char *tt2 = NULL;
 593:     const SIZE_T TTBUFLEN = 8096;
 594:     int cnt = 0;
 595:     hPsapi = LoadLibrary( _T(&quot;psapi.dll&quot;) );
 596:     if (hPsapi == NULL)
 597:       return FALSE;
 598:     pEPM = (tEPM) GetProcAddress( hPsapi, &quot;EnumProcessModules&quot; );
 599:     pGMFNE = (tGMFNE) GetProcAddress( hPsapi, &quot;GetModuleFileNameExA&quot; );
 600:     pGMBN = (tGMFNE) GetProcAddress( hPsapi, &quot;GetModuleBaseNameA&quot; );
 601:     pGMI = (tGMI) GetProcAddress( hPsapi, &quot;GetModuleInformation&quot; );
 602:     if ( (pEPM == NULL) || (pGMFNE == NULL) || (pGMBN == NULL) || (pGMI == NULL) )
 603:     {
 604:       // we couldnt find all functions
 605:       FreeLibrary(hPsapi);
 606:       return FALSE;
 607:     }
 608:     hMods = (HMODULE*) malloc(sizeof(HMODULE) * (TTBUFLEN / sizeof(HMODULE)));
 609:     tt = (char*) malloc(sizeof(char) * TTBUFLEN);
 610:     tt2 = (char*) malloc(sizeof(char) * TTBUFLEN);
 611:     if ( (hMods == NULL) || (tt == NULL) || (tt2 == NULL) )
 612:       goto cleanup;
 613:     if ( ! pEPM( hProcess, hMods, TTBUFLEN, &amp;cbNeeded ) )
 614:     {
 615:       //_ftprintf(fLogFile, _T(&quot;%lu: EPM failed, GetLastError = %lu\n&quot;), g_dwShowCount, gle );
 616:       goto cleanup;
 617:     }
 618:     if ( cbNeeded &gt; TTBUFLEN )
 619:     {
 620:       //_ftprintf(fLogFile, _T(&quot;%lu: More than %lu module handles. Huh?\n&quot;), g_dwShowCount, lenof( hMods ) );
 621:       goto cleanup;
 622:     }
 623:     for ( i = 0; i &lt; cbNeeded / sizeof(hMods[0]); i++ )
 624:     {
 625:       // base address, size
 626:       pGMI(hProcess, hMods[i], &amp;mi, sizeof(mi));
 627:       // image file name
 628:       tt[0] = 0;
 629:       pGMFNE(hProcess, hMods[i], tt, TTBUFLEN );
 630:       // module name
 631:       tt2[0] = 0;
 632:       pGMBN(hProcess, hMods[i], tt2, TTBUFLEN );
 633:       DWORD dwRes = this-&gt;LoadModule(hProcess, tt, tt2, (DWORD64) mi.lpBaseOfDll, mi.SizeOfImage);
 634:       if (dwRes != ERROR_SUCCESS)
 635:         this-&gt;m_parent-&gt;OnDbgHelpErr(&quot;LoadModule&quot;, dwRes, 0);
 636:       cnt++;
 637:     }
 638:   cleanup:
 639:     if (hPsapi != NULL) FreeLibrary(hPsapi);
 640:     if (tt2 != NULL) free(tt2);
 641:     if (tt != NULL) free(tt);
 642:     if (hMods != NULL) free(hMods);
 643:     return cnt != 0;
 644:   }  // GetModuleListPSAPI
 645:   DWORD LoadModule(HANDLE hProcess, LPCSTR img, LPCSTR mod, DWORD64 baseAddr, DWORD size)
 646:   {
 647:     CHAR *szImg = _strdup(img);
 648:     CHAR *szMod = _strdup(mod);
 649:     DWORD result = ERROR_SUCCESS;
 650:     if ( (szImg == NULL) || (szMod == NULL) )
 651:       result = ERROR_NOT_ENOUGH_MEMORY;
 652:     else
 653:     {
 654:       if (pSLM(hProcess, 0, szImg, szMod, baseAddr, size) == 0)
 655:         result = GetLastError();
 656:     }
 657:     ULONGLONG fileVersion = 0;
 658:     if ( (m_parent != NULL) &amp;&amp; (szImg != NULL) )
 659:     {
 660:       // try to retrive the file-version:
 661:       if ( (this-&gt;m_parent-&gt;m_options &amp; StackWalker::RetrieveFileVersion) != 0)
 662:       {
 663:         VS_FIXEDFILEINFO *fInfo = NULL;
 664:         DWORD dwHandle;
 665:         DWORD dwSize = GetFileVersionInfoSizeA(szImg, &amp;dwHandle);
 666:         if (dwSize &gt; 0)
 667:         {
 668:           LPVOID vData = malloc(dwSize);
 669:           if (vData != NULL)
 670:           {
 671:             if (GetFileVersionInfoA(szImg, dwHandle, dwSize, vData) != 0)
 672:             {
 673:               UINT len;
 674:               TCHAR szSubBlock[] = _T(&quot;\\&quot;);
 675:               if (VerQueryValue(vData, szSubBlock, (LPVOID*) &amp;fInfo, &amp;len) == 0)
 676:                 fInfo = NULL;
 677:               else
 678:               {
 679:                 fileVersion = ((ULONGLONG)fInfo-&gt;dwFileVersionLS) + ((ULONGLONG)fInfo-&gt;dwFileVersionMS &lt;&lt; 32);
 680:               }
 681:             }
 682:             free(vData);
 683:           }
 684:         }
 685:       }
 686:       // Retrive some additional-infos about the module
 687:       IMAGEHLP_MODULE64_V3 Module;
 688:       const char *szSymType = &quot;-unknown-&quot;;
 689:       if (this-&gt;GetModuleInfo(hProcess, baseAddr, &amp;Module) != FALSE)
 690:       {
 691:         switch(Module.SymType)
 692:         {
 693:           case SymNone:
 694:             szSymType = &quot;-nosymbols-&quot;;
 695:             break;
 696:           case SymCoff:  // 1
 697:             szSymType = &quot;COFF&quot;;
 698:             break;
 699:           case SymCv:  // 2
 700:             szSymType = &quot;CV&quot;;
 701:             break;
 702:           case SymPdb:  // 3
 703:             szSymType = &quot;PDB&quot;;
 704:             break;
 705:           case SymExport:  // 4
 706:             szSymType = &quot;-exported-&quot;;
 707:             break;
 708:           case SymDeferred:  // 5
 709:             szSymType = &quot;-deferred-&quot;;
 710:             break;
 711:           case SymSym:  // 6
 712:             szSymType = &quot;SYM&quot;;
 713:             break;
 714:           case 7: // SymDia:
 715:             szSymType = &quot;DIA&quot;;
 716:             break;
 717:           case 8: //SymVirtual:
 718:             szSymType = &quot;Virtual&quot;;
 719:             break;
 720:         }
 721:       }
 722:       LPCSTR pdbName = Module.LoadedImageName;
 723:       if (Module.LoadedPdbName[0] != 0)
 724:         pdbName = Module.LoadedPdbName;
 725:       this-&gt;m_parent-&gt;OnLoadModule(img, mod, baseAddr, size, result, szSymType, pdbName, fileVersion);
 726:     }
 727:     if (szImg != NULL) free(szImg);
 728:     if (szMod != NULL) free(szMod);
 729:     return result;
 730:   }
 731: public:
 732:   BOOL LoadModules(HANDLE hProcess, DWORD dwProcessId)
 733:   {
 734:     // first try toolhelp32
 735:     if (GetModuleListTH32(hProcess, dwProcessId))
 736:       return true;
 737:     // then try psapi
 738:     return GetModuleListPSAPI(hProcess);
 739:   }
 740:   BOOL GetModuleInfo(HANDLE hProcess, DWORD64 baseAddr, IMAGEHLP_MODULE64_V3 *pModuleInfo)
 741:   {
 742:     memset(pModuleInfo, 0, sizeof(IMAGEHLP_MODULE64_V3));
 743:     if(this-&gt;pSGMI == NULL)
 744:     {
 745:       SetLastError(ERROR_DLL_INIT_FAILED);
 746:       return FALSE;
 747:     }
 748:     // First try to use the larger ModuleInfo-Structure
 749:     pModuleInfo-&gt;SizeOfStruct = sizeof(IMAGEHLP_MODULE64_V3);
 750:     void *pData = malloc(4096); // reserve enough memory, so the bug in v6.3.5.1 does not lead to memory-overwrites...
 751:     if (pData == NULL)
 752:     {
 753:       SetLastError(ERROR_NOT_ENOUGH_MEMORY);
 754:       return FALSE;
 755:     }
 756:     memcpy(pData, pModuleInfo, sizeof(IMAGEHLP_MODULE64_V3));
 757:     static bool s_useV3Version = true;
 758:     if (s_useV3Version)
 759:     {
 760:       if (this-&gt;pSGMI(hProcess, baseAddr, (IMAGEHLP_MODULE64_V3*) pData) != FALSE)
 761:       {
 762:         // only copy as much memory as is reserved...
 763:         memcpy(pModuleInfo, pData, sizeof(IMAGEHLP_MODULE64_V3));
 764:         pModuleInfo-&gt;SizeOfStruct = sizeof(IMAGEHLP_MODULE64_V3);
 765:         free(pData);
 766:         return TRUE;
 767:       }
 768:       s_useV3Version = false;  // to prevent unneccessarry calls with the larger struct...
 769:     }
 770:     // could not retrive the bigger structure, try with the smaller one (as defined in VC7.1)...
 771:     pModuleInfo-&gt;SizeOfStruct = sizeof(IMAGEHLP_MODULE64_V2);
 772:     memcpy(pData, pModuleInfo, sizeof(IMAGEHLP_MODULE64_V2));
 773:     if (this-&gt;pSGMI(hProcess, baseAddr, (IMAGEHLP_MODULE64_V3*) pData) != FALSE)
 774:     {
 775:       // only copy as much memory as is reserved...
 776:       memcpy(pModuleInfo, pData, sizeof(IMAGEHLP_MODULE64_V2));
 777:       pModuleInfo-&gt;SizeOfStruct = sizeof(IMAGEHLP_MODULE64_V2);
 778:       free(pData);
 779:       return TRUE;
 780:     }
 781:     free(pData);
 782:     SetLastError(ERROR_DLL_INIT_FAILED);
 783:     return FALSE;
 784:   }
 785: };
 786: // #############################################################
 787: StackWalker::StackWalker(DWORD dwProcessId, HANDLE hProcess)
 788: {
 789:   this-&gt;m_options = OptionsAll;
 790:   this-&gt;m_modulesLoaded = FALSE;
 791:   this-&gt;m_hProcess = hProcess;
 792:   this-&gt;m_sw = new StackWalkerInternal(this, this-&gt;m_hProcess);
 793:   this-&gt;m_dwProcessId = dwProcessId;
 794:   this-&gt;m_szSymPath = NULL;
 795:   this-&gt;m_MaxRecursionCount = 1000;
 796: }
 797: StackWalker::StackWalker(int options, LPCSTR szSymPath, DWORD dwProcessId, HANDLE hProcess)
 798: {
 799:   this-&gt;m_options = options;
 800:   this-&gt;m_modulesLoaded = FALSE;
 801:   this-&gt;m_hProcess = hProcess;
 802:   this-&gt;m_sw = new StackWalkerInternal(this, this-&gt;m_hProcess);
 803:   this-&gt;m_dwProcessId = dwProcessId;
 804:   if (szSymPath != NULL)
 805:   {
 806:     this-&gt;m_szSymPath = _strdup(szSymPath);
 807:     this-&gt;m_options |= SymBuildPath;
 808:   }
 809:   else
 810:     this-&gt;m_szSymPath = NULL;
 811:   this-&gt;m_MaxRecursionCount = 1000;
 812: }
 813: StackWalker::~StackWalker()
 814: {
 815:   if (m_szSymPath != NULL)
 816:     free(m_szSymPath);
 817:   m_szSymPath = NULL;
 818:   if (this-&gt;m_sw != NULL)
 819:     delete this-&gt;m_sw;
 820:   this-&gt;m_sw = NULL;
 821: }
 822: BOOL StackWalker::LoadModules()
 823: {
 824:   if (this-&gt;m_sw == NULL)
 825:   {
 826:     SetLastError(ERROR_DLL_INIT_FAILED);
 827:     return FALSE;
 828:   }
 829:   if (m_modulesLoaded != FALSE)
 830:     return TRUE;
 831:   // Build the sym-path:
 832:   char *szSymPath = NULL;
 833:   if ( (this-&gt;m_options &amp; SymBuildPath) != 0)
 834:   {
 835:     const size_t nSymPathLen = 4096;
 836:     szSymPath = (char*) malloc(nSymPathLen);
 837:     if (szSymPath == NULL)
 838:     {
 839:       SetLastError(ERROR_NOT_ENOUGH_MEMORY);
 840:       return FALSE;
 841:     }
 842:     szSymPath[0] = 0;
 843:     // Now first add the (optional) provided sympath:
 844:     if (this-&gt;m_szSymPath != NULL)
 845:     {
 846:       strcat_s(szSymPath, nSymPathLen, this-&gt;m_szSymPath);
 847:       strcat_s(szSymPath, nSymPathLen, &quot;;&quot;);
 848:     }
 849:     strcat_s(szSymPath, nSymPathLen, &quot;.;&quot;);
 850:     const size_t nTempLen = 1024;
 851:     char szTemp[nTempLen];
 852:     // Now add the current directory:
 853:     if (GetCurrentDirectoryA(nTempLen, szTemp) &gt; 0)
 854:     {
 855:       szTemp[nTempLen-1] = 0;
 856:       strcat_s(szSymPath, nSymPathLen, szTemp);
 857:       strcat_s(szSymPath, nSymPathLen, &quot;;&quot;);
 858:     }
 859:     // Now add the path for the main-module:
 860:     if (GetModuleFileNameA(NULL, szTemp, nTempLen) &gt; 0)
 861:     {
 862:       szTemp[nTempLen-1] = 0;
 863:       for (char *p = (szTemp+strlen(szTemp)-1); p &gt;= szTemp; --p)
 864:       {
 865:         // locate the rightmost path separator
 866:         if ( (*p == &apos;\\&apos;) || (*p == &apos;/&apos;) || (*p == &apos;:&apos;) )
 867:         {
 868:           *p = 0;
 869:           break;
 870:         }
 871:       }  // for (search for path separator...)
 872:       if (strlen(szTemp) &gt; 0)
 873:       {
 874:         strcat_s(szSymPath, nSymPathLen, szTemp);
 875:         strcat_s(szSymPath, nSymPathLen, &quot;;&quot;);
 876:       }
 877:     }
 878:     if (GetEnvironmentVariableA(&quot;_NT_SYMBOL_PATH&quot;, szTemp, nTempLen) &gt; 0)
 879:     {
 880:       szTemp[nTempLen-1] = 0;
 881:       strcat_s(szSymPath, nSymPathLen, szTemp);
 882:       strcat_s(szSymPath, nSymPathLen, &quot;;&quot;);
 883:     }
 884:     if (GetEnvironmentVariableA(&quot;_NT_ALTERNATE_SYMBOL_PATH&quot;, szTemp, nTempLen) &gt; 0)
 885:     {
 886:       szTemp[nTempLen-1] = 0;
 887:       strcat_s(szSymPath, nSymPathLen, szTemp);
 888:       strcat_s(szSymPath, nSymPathLen, &quot;;&quot;);
 889:     }
 890:     if (GetEnvironmentVariableA(&quot;SYSTEMROOT&quot;, szTemp, nTempLen) &gt; 0)
 891:     {
 892:       szTemp[nTempLen-1] = 0;
 893:       strcat_s(szSymPath, nSymPathLen, szTemp);
 894:       strcat_s(szSymPath, nSymPathLen, &quot;;&quot;);
 895:       // also add the &quot;system32&quot;-directory:
 896:       strcat_s(szTemp, nTempLen, &quot;\\system32&quot;);
 897:       strcat_s(szSymPath, nSymPathLen, szTemp);
 898:       strcat_s(szSymPath, nSymPathLen, &quot;;&quot;);
 899:     }
 900:     if ( (this-&gt;m_options &amp; SymUseSymSrv) != 0)
 901:     {
 902:       if (GetEnvironmentVariableA(&quot;SYSTEMDRIVE&quot;, szTemp, nTempLen) &gt; 0)
 903:       {
 904:         szTemp[nTempLen-1] = 0;
 905:         strcat_s(szSymPath, nSymPathLen, &quot;SRV*&quot;);
 906:         strcat_s(szSymPath, nSymPathLen, szTemp);
 907:         strcat_s(szSymPath, nSymPathLen, &quot;\\websymbols&quot;);
 908:         strcat_s(szSymPath, nSymPathLen, &quot;*http://msdl.microsoft.com/download/symbols;&quot;);
 909:       }
 910:       else
 911:         strcat_s(szSymPath, nSymPathLen, &quot;SRV*c:\\websymbols*http://msdl.microsoft.com/download/symbols;&quot;);
 912:     }
 913:   }  // if SymBuildPath
 914:   // First Init the whole stuff...
 915:   BOOL bRet = this-&gt;m_sw-&gt;Init(szSymPath);
 916:   if (szSymPath != NULL) free(szSymPath); szSymPath = NULL;
 917:   if (bRet == FALSE)
 918:   {
 919:     this-&gt;OnDbgHelpErr(&quot;Error while initializing dbghelp.dll&quot;, 0, 0);
 920:     SetLastError(ERROR_DLL_INIT_FAILED);
 921:     return FALSE;
 922:   }
 923:   bRet = this-&gt;m_sw-&gt;LoadModules(this-&gt;m_hProcess, this-&gt;m_dwProcessId);
 924:   if (bRet != FALSE)
 925:     m_modulesLoaded = TRUE;
 926:   return bRet;
 927: }
 928: // The following is used to pass the &quot;userData&quot;-Pointer to the user-provided readMemoryFunction
 929: // This has to be done due to a problem with the &quot;hProcess&quot;-parameter in x64...
 930: // Because this class is in no case multi-threading-enabled (because of the limitations 
 931: // of dbghelp.dll) it is &quot;safe&quot; to use a static-variable
 932: static StackWalker::PReadProcessMemoryRoutine s_readMemoryFunction = NULL;
 933: static LPVOID s_readMemoryFunction_UserData = NULL;
 934: BOOL StackWalker::ShowCallstack(HANDLE hThread, const CONTEXT *context, PReadProcessMemoryRoutine readMemoryFunction, LPVOID pUserData)
 935: {
 936:   CONTEXT c;
 937:   CallstackEntry csEntry;
 938:   IMAGEHLP_SYMBOL64 *pSym = NULL;
 939:   StackWalkerInternal::IMAGEHLP_MODULE64_V3 Module;
 940:   IMAGEHLP_LINE64 Line;
 941:   int frameNum;
 942:   bool bLastEntryCalled = true;
 943:   int curRecursionCount = 0;
 944:   if (m_modulesLoaded == FALSE)
 945:     this-&gt;LoadModules();  // ignore the result...
 946:   if (this-&gt;m_sw-&gt;m_hDbhHelp == NULL)
 947:   {
 948:     SetLastError(ERROR_DLL_INIT_FAILED);
 949:     return FALSE;
 950:   }
 951:   s_readMemoryFunction = readMemoryFunction;
 952:   s_readMemoryFunction_UserData = pUserData;
 953:   if (context == NULL)
 954:   {
 955:     // If no context is provided, capture the context
 956:     // See: https://stackwalker.codeplex.com/discussions/446958
 957: #if true || _WIN32_WINNT &lt;= 0x0501
 958:       // If we need to support XP, we need to use the &quot;old way&quot;, because &quot;GetThreadId&quot; is not available!
 959:     if (hThread == GetCurrentThread())
 960: #else
 961:     if (GetThreadId(hThread) == GetCurrentThreadId())
 962: #endif
 963:     {
 964:       GET_CURRENT_CONTEXT_STACKWALKER_CODEPLEX(c, USED_CONTEXT_FLAGS);
 965:     }
 966:     else
 967:     {
 968:       SuspendThread(hThread);
 969:       memset(&amp;c, 0, sizeof(CONTEXT));
 970:       c.ContextFlags = USED_CONTEXT_FLAGS;
 971:       if (GetThreadContext(hThread, &amp;c) == FALSE)
 972:       {
 973:         ResumeThread(hThread);
 974:         return FALSE;
 975:       }
 976:     }
 977:   }
 978:   else
 979:     c = *context;
 980:   // init STACKFRAME for first call
 981:   STACKFRAME64 s; // in/out stackframe
 982:   memset(&amp;s, 0, sizeof(s));
 983:   DWORD imageType;
 984: #ifdef _M_IX86
 985:   // normally, call ImageNtHeader() and use machine info from PE header
 986:   imageType = IMAGE_FILE_MACHINE_I386;
 987:   s.AddrPC.Offset = c.Eip;
 988:   s.AddrPC.Mode = AddrModeFlat;
 989:   s.AddrFrame.Offset = c.Ebp;
 990:   s.AddrFrame.Mode = AddrModeFlat;
 991:   s.AddrStack.Offset = c.Esp;
 992:   s.AddrStack.Mode = AddrModeFlat;
 993: #elif _M_X64
 994:   imageType = IMAGE_FILE_MACHINE_AMD64;
 995:   s.AddrPC.Offset = c.Rip;
 996:   s.AddrPC.Mode = AddrModeFlat;
 997:   s.AddrFrame.Offset = c.Rsp;
 998:   s.AddrFrame.Mode = AddrModeFlat;
 999:   s.AddrStack.Offset = c.Rsp;
1000:   s.AddrStack.Mode = AddrModeFlat;
1001: #elif _M_IA64
1002:   imageType = IMAGE_FILE_MACHINE_IA64;
1003:   s.AddrPC.Offset = c.StIIP;
1004:   s.AddrPC.Mode = AddrModeFlat;
1005:   s.AddrFrame.Offset = c.IntSp;
1006:   s.AddrFrame.Mode = AddrModeFlat;
1007:   s.AddrBStore.Offset = c.RsBSP;
1008:   s.AddrBStore.Mode = AddrModeFlat;
1009:   s.AddrStack.Offset = c.IntSp;
1010:   s.AddrStack.Mode = AddrModeFlat;
1011: #else
1012: #error &quot;Platform not supported!&quot;
1013: #endif
1014:   pSym = (IMAGEHLP_SYMBOL64 *) malloc(sizeof(IMAGEHLP_SYMBOL64) + STACKWALK_MAX_NAMELEN);
1015:   if (!pSym) goto cleanup;  // not enough memory...
1016:   memset(pSym, 0, sizeof(IMAGEHLP_SYMBOL64) + STACKWALK_MAX_NAMELEN);
1017:   pSym-&gt;SizeOfStruct = sizeof(IMAGEHLP_SYMBOL64);
1018:   pSym-&gt;MaxNameLength = STACKWALK_MAX_NAMELEN;
1019:   memset(&amp;Line, 0, sizeof(Line));
1020:   Line.SizeOfStruct = sizeof(Line);
1021:   memset(&amp;Module, 0, sizeof(Module));
1022:   Module.SizeOfStruct = sizeof(Module);
1023:   for (frameNum = 0; ; ++frameNum )
1024:   {
1025:     // get next stack frame (StackWalk64(), SymFunctionTableAccess64(), SymGetModuleBase64())
1026:     // if this returns ERROR_INVALID_ADDRESS (487) or ERROR_NOACCESS (998), you can
1027:     // assume that either you are done, or that the stack is so hosed that the next
1028:     // deeper frame could not be found.
1029:     // CONTEXT need not to be suplied if imageTyp is IMAGE_FILE_MACHINE_I386!
1030:     if ( ! this-&gt;m_sw-&gt;pSW(imageType, this-&gt;m_hProcess, hThread, &amp;s, &amp;c, myReadProcMem, this-&gt;m_sw-&gt;pSFTA, this-&gt;m_sw-&gt;pSGMB, NULL) )
1031:     {
1032:       // INFO: &quot;StackWalk64&quot; does not set &quot;GetLastError&quot;...
1033:       this-&gt;OnDbgHelpErr(&quot;StackWalk64&quot;, 0, s.AddrPC.Offset);
1034:       break;
1035:     }
1036:     csEntry.offset = s.AddrPC.Offset;
1037:     csEntry.name[0] = 0;
1038:     csEntry.undName[0] = 0;
1039:     csEntry.undFullName[0] = 0;
1040:     csEntry.offsetFromSmybol = 0;
1041:     csEntry.offsetFromLine = 0;
1042:     csEntry.lineFileName[0] = 0;
1043:     csEntry.lineNumber = 0;
1044:     csEntry.loadedImageName[0] = 0;
1045:     csEntry.moduleName[0] = 0;
1046:     if (s.AddrPC.Offset == s.AddrReturn.Offset)
1047:     {
1048:       if ( (this-&gt;m_MaxRecursionCount &gt; 0) &amp;&amp; (curRecursionCount &gt; m_MaxRecursionCount) )
1049:       {
1050:         this-&gt;OnDbgHelpErr(&quot;StackWalk64-Endless-Callstack!&quot;, 0, s.AddrPC.Offset);
1051:         break;
1052:       }
1053:       curRecursionCount++;
1054:     }
1055:     else
1056:       curRecursionCount = 0;
1057:     if (s.AddrPC.Offset != 0)
1058:     {
1059:       // we seem to have a valid PC
1060:       // show procedure info (SymGetSymFromAddr64())
1061:       if (this-&gt;m_sw-&gt;pSGSFA(this-&gt;m_hProcess, s.AddrPC.Offset, &amp;(csEntry.offsetFromSmybol), pSym) != FALSE)
1062:       {
1063:         MyStrCpy(csEntry.name, STACKWALK_MAX_NAMELEN, pSym-&gt;Name);
1064:         // UnDecorateSymbolName()
1065:         this-&gt;m_sw-&gt;pUDSN( pSym-&gt;Name, csEntry.undName, STACKWALK_MAX_NAMELEN, UNDNAME_NAME_ONLY );
1066:         this-&gt;m_sw-&gt;pUDSN( pSym-&gt;Name, csEntry.undFullName, STACKWALK_MAX_NAMELEN, UNDNAME_COMPLETE );
1067:       }
1068:       else
1069:       {
1070:         this-&gt;OnDbgHelpErr(&quot;SymGetSymFromAddr64&quot;, GetLastError(), s.AddrPC.Offset);
1071:       }
1072:       // show line number info, NT5.0-method (SymGetLineFromAddr64())
1073:       if (this-&gt;m_sw-&gt;pSGLFA != NULL )
1074:       { // yes, we have SymGetLineFromAddr64()
1075:         if (this-&gt;m_sw-&gt;pSGLFA(this-&gt;m_hProcess, s.AddrPC.Offset, &amp;(csEntry.offsetFromLine), &amp;Line) != FALSE)
1076:         {
1077:           csEntry.lineNumber = Line.LineNumber;
1078:           MyStrCpy(csEntry.lineFileName, STACKWALK_MAX_NAMELEN, Line.FileName);
1079:         }
1080:         else
1081:         {
1082:           this-&gt;OnDbgHelpErr(&quot;SymGetLineFromAddr64&quot;, GetLastError(), s.AddrPC.Offset);
1083:         }
1084:       } // yes, we have SymGetLineFromAddr64()
1085:       // show module info (SymGetModuleInfo64())
1086:       if (this-&gt;m_sw-&gt;GetModuleInfo(this-&gt;m_hProcess, s.AddrPC.Offset, &amp;Module ) != FALSE)
1087:       { // got module info OK
1088:         switch ( Module.SymType )
1089:         {
1090:         case SymNone:
1091:           csEntry.symTypeString = &quot;-nosymbols-&quot;;
1092:           break;
1093:         case SymCoff:
1094:           csEntry.symTypeString = &quot;COFF&quot;;
1095:           break;
1096:         case SymCv:
1097:           csEntry.symTypeString = &quot;CV&quot;;
1098:           break;
1099:         case SymPdb:
1100:           csEntry.symTypeString = &quot;PDB&quot;;
1101:           break;
1102:         case SymExport:
1103:           csEntry.symTypeString = &quot;-exported-&quot;;
1104:           break;
1105:         case SymDeferred:
1106:           csEntry.symTypeString = &quot;-deferred-&quot;;
1107:           break;
1108:         case SymSym:
1109:           csEntry.symTypeString = &quot;SYM&quot;;
1110:           break;
1111: #if API_VERSION_NUMBER &gt;= 9
1112:         case SymDia:
1113:           csEntry.symTypeString = &quot;DIA&quot;;
1114:           break;
1115: #endif
1116:         case 8: //SymVirtual:
1117:           csEntry.symTypeString = &quot;Virtual&quot;;
1118:           break;
1119:         default:
1120:           //_snprintf( ty, sizeof(ty), &quot;symtype=%ld&quot;, (long) Module.SymType );
1121:           csEntry.symTypeString = NULL;
1122:           break;
1123:         }
1124:         MyStrCpy(csEntry.moduleName, STACKWALK_MAX_NAMELEN, Module.ModuleName);
1125:         csEntry.baseOfImage = Module.BaseOfImage;
1126:         MyStrCpy(csEntry.loadedImageName, STACKWALK_MAX_NAMELEN, Module.LoadedImageName);
1127:       } // got module info OK
1128:       else
1129:       {
1130:         this-&gt;OnDbgHelpErr(&quot;SymGetModuleInfo64&quot;, GetLastError(), s.AddrPC.Offset);
1131:       }
1132:     } // we seem to have a valid PC
1133:     CallstackEntryType et = nextEntry;
1134:     if (frameNum == 0)
1135:       et = firstEntry;
1136:     bLastEntryCalled = false;
1137:     this-&gt;OnCallstackEntry(et, csEntry);
1138:     if (s.AddrReturn.Offset == 0)
1139:     {
1140:       bLastEntryCalled = true;
1141:       this-&gt;OnCallstackEntry(lastEntry, csEntry);
1142:       SetLastError(ERROR_SUCCESS);
1143:       break;
1144:     }
1145:   } // for ( frameNum )
1146:   cleanup:
1147:     if (pSym) free( pSym );
1148:   if (bLastEntryCalled == false)
1149:       this-&gt;OnCallstackEntry(lastEntry, csEntry);
1150:   if (context == NULL)
1151:     ResumeThread(hThread);
1152:   return TRUE;
1153: }
1154: BOOL __stdcall StackWalker::myReadProcMem(
1155:     HANDLE      hProcess,
1156:     DWORD64     qwBaseAddress,
1157:     PVOID       lpBuffer,
1158:     DWORD       nSize,
1159:     LPDWORD     lpNumberOfBytesRead
1160:     )
1161: {
1162:   if (s_readMemoryFunction == NULL)
1163:   {
1164:     SIZE_T st;
1165:     BOOL bRet = ReadProcessMemory(hProcess, (LPVOID) qwBaseAddress, lpBuffer, nSize, &amp;st);
1166:     *lpNumberOfBytesRead = (DWORD) st;
1167:     //printf(&quot;ReadMemory: hProcess: %p, baseAddr: %p, buffer: %p, size: %d, read: %d, result: %d\n&quot;, hProcess, (LPVOID) qwBaseAddress, lpBuffer, nSize, (DWORD) st, (DWORD) bRet);
1168:     return bRet;
1169:   }
1170:   else
1171:   {
1172:     return s_readMemoryFunction(hProcess, qwBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead, s_readMemoryFunction_UserData);
1173:   }
1174: }
1175: void StackWalker::OnLoadModule(LPCSTR img, LPCSTR mod, DWORD64 baseAddr, DWORD size, DWORD result, LPCSTR symType, LPCSTR pdbName, ULONGLONG fileVersion)
1176: {
1177:   CHAR buffer[STACKWALK_MAX_NAMELEN];
1178:   if (fileVersion == 0)
1179:     _snprintf_s(buffer, STACKWALK_MAX_NAMELEN, &quot;%s:%s (%p), size: %d (result: %d), SymType: &apos;%s&apos;, PDB: &apos;%s&apos;\n&quot;, img, mod, (LPVOID) baseAddr, size, result, symType, pdbName);
1180:   else
1181:   {
1182:     DWORD v4 = (DWORD) (fileVersion &amp; 0xFFFF);
1183:     DWORD v3 = (DWORD) ((fileVersion&gt;&gt;16) &amp; 0xFFFF);
1184:     DWORD v2 = (DWORD) ((fileVersion&gt;&gt;32) &amp; 0xFFFF);
1185:     DWORD v1 = (DWORD) ((fileVersion&gt;&gt;48) &amp; 0xFFFF);
1186:     _snprintf_s(buffer, STACKWALK_MAX_NAMELEN, &quot;%s:%s (%p), size: %d (result: %d), SymType: &apos;%s&apos;, PDB: &apos;%s&apos;, fileVersion: %d.%d.%d.%d\n&quot;, img, mod, (LPVOID) baseAddr, size, result, symType, pdbName, v1, v2, v3, v4);
1187:   }
1188:   OnOutput(buffer);
1189: }
1190: void StackWalker::OnCallstackEntry(CallstackEntryType eType, CallstackEntry &amp;entry)
1191: {
1192:   CHAR buffer[STACKWALK_MAX_NAMELEN];
1193:   if ( (eType != lastEntry) &amp;&amp; (entry.offset != 0) )
1194:   {
1195:     if (entry.name[0] == 0)
1196:       MyStrCpy(entry.name, STACKWALK_MAX_NAMELEN, &quot;(function-name not available)&quot;);
1197:     if (entry.undName[0] != 0)
1198:       MyStrCpy(entry.name, STACKWALK_MAX_NAMELEN, entry.undName);
1199:     if (entry.undFullName[0] != 0)
1200:       MyStrCpy(entry.name, STACKWALK_MAX_NAMELEN, entry.undFullName);
1201:     if (entry.lineFileName[0] == 0)
1202:     {
1203:       MyStrCpy(entry.lineFileName, STACKWALK_MAX_NAMELEN, &quot;(filename not available)&quot;);
1204:       if (entry.moduleName[0] == 0)
1205:         MyStrCpy(entry.moduleName, STACKWALK_MAX_NAMELEN, &quot;(module-name not available)&quot;);
1206:       _snprintf_s(buffer, STACKWALK_MAX_NAMELEN, &quot;%p (%s): %s: %s\n&quot;, (LPVOID) entry.offset, entry.moduleName, entry.lineFileName, entry.name);
1207:     }
1208:     else
1209:       _snprintf_s(buffer, STACKWALK_MAX_NAMELEN, &quot;%s (%d): %s\n&quot;, entry.lineFileName, entry.lineNumber, entry.name);
1210:     buffer[STACKWALK_MAX_NAMELEN-1] = 0;
1211:     OnOutput(buffer);
1212:   }
1213: }
1214: void StackWalker::OnDbgHelpErr(LPCSTR szFuncName, DWORD gle, DWORD64 addr)
1215: {
1216:   CHAR buffer[STACKWALK_MAX_NAMELEN];
1217:   _snprintf_s(buffer, STACKWALK_MAX_NAMELEN, &quot;ERROR: %s, GetLastError: %d (Address: %p)\n&quot;, szFuncName, gle, (LPVOID) addr);
1218:   OnOutput(buffer);
1219: }
1220: void StackWalker::OnSymInit(LPCSTR szSearchPath, DWORD symOptions, LPCSTR szUserName)
1221: {
1222:   CHAR buffer[STACKWALK_MAX_NAMELEN];
1223:   _snprintf_s(buffer, STACKWALK_MAX_NAMELEN, &quot;SymInit: Symbol-SearchPath: &apos;%s&apos;, symOptions: %d, UserName: &apos;%s&apos;\n&quot;, szSearchPath, symOptions, szUserName);
1224:   OnOutput(buffer);
1225:   // Also display the OS-version
1226: #if _MSC_VER &lt;= 1200
1227:   OSVERSIONINFOA ver;
1228:   ZeroMemory(&amp;ver, sizeof(OSVERSIONINFOA));
1229:   ver.dwOSVersionInfoSize = sizeof(ver);
1230:   if (GetVersionExA(&amp;ver) != FALSE)
1231:   {
1232:     _snprintf_s(buffer, STACKWALK_MAX_NAMELEN, &quot;OS-Version: %d.%d.%d (%s)\n&quot;, 
1233:       ver.dwMajorVersion, ver.dwMinorVersion, ver.dwBuildNumber,
1234:       ver.szCSDVersion);
1235:     OnOutput(buffer);
1236:   }
1237: #else
1238:   OSVERSIONINFOEXA ver;
1239:   ZeroMemory(&amp;ver, sizeof(OSVERSIONINFOEXA));
1240:   ver.dwOSVersionInfoSize = sizeof(ver);
1241:   if (GetVersionExA( (OSVERSIONINFOA*) &amp;ver) != FALSE)
1242:   {
1243:     _snprintf_s(buffer, STACKWALK_MAX_NAMELEN, &quot;OS-Version: %d.%d.%d (%s) 0x%x-0x%x\n&quot;, 
1244:       ver.dwMajorVersion, ver.dwMinorVersion, ver.dwBuildNumber,
1245:       ver.szCSDVersion, ver.wSuiteMask, ver.wProductType);
1246:     OnOutput(buffer);
1247:   }
1248: #endif
1249: }
1250: void StackWalker::OnOutput(LPCSTR buffer)
1251: {
1252:   OutputDebugStringA(buffer);
1253: }</file><file path="thirdparty/StackWalker/StackWalker.h">  1: /**********************************************************************
  2:  * 
  3:  * StackWalker.h
  4:  *
  5:  *
  6:  *
  7:  * LICENSE (http://www.opensource.org/licenses/bsd-license.php)
  8:  *
  9:  *   Copyright (c) 2005-2009, Jochen Kalmbach
 10:  *   All rights reserved.
 11:  *
 12:  *   Redistribution and use in source and binary forms, with or without modification, 
 13:  *   are permitted provided that the following conditions are met:
 14:  *
 15:  *   Redistributions of source code must retain the above copyright notice, 
 16:  *   this list of conditions and the following disclaimer. 
 17:  *   Redistributions in binary form must reproduce the above copyright notice, 
 18:  *   this list of conditions and the following disclaimer in the documentation 
 19:  *   and/or other materials provided with the distribution. 
 20:  *   Neither the name of Jochen Kalmbach nor the names of its contributors may be 
 21:  *   used to endorse or promote products derived from this software without 
 22:  *   specific prior written permission. 
 23:  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; 
 24:  *   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
 25:  *   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
 26:  *   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE 
 27:  *   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 28:  *   (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
 29:  *   LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND 
 30:  *   ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 31:  *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS 
 32:  *   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 33:  *
 34:  * **********************************************************************/
 35: // #pragma once is supported starting with _MCS_VER 1000, 
 36: // so we need not to check the version (because we only support _MSC_VER &gt;= 1100)!
 37: #pragma once
 38: #include &lt;windows.h&gt;
 39: // special defines for VC5/6 (if no actual PSDK is installed):
 40: #if _MSC_VER &lt; 1300
 41: typedef unsigned __int64 DWORD64, *PDWORD64;
 42: #if defined(_WIN64)
 43: typedef unsigned __int64 SIZE_T, *PSIZE_T;
 44: #else
 45: typedef unsigned long SIZE_T, *PSIZE_T;
 46: #endif
 47: #endif  // _MSC_VER &lt; 1300
 48: class StackWalkerInternal;  // forward
 49: class StackWalker
 50: {
 51: public:
 52:   typedef enum StackWalkOptions
 53:   {
 54:     // No addition info will be retrived 
 55:     // (only the address is available)
 56:     RetrieveNone = 0,
 57:     // Try to get the symbol-name
 58:     RetrieveSymbol = 1,
 59:     // Try to get the line for this symbol
 60:     RetrieveLine = 2,
 61:     // Try to retrieve the module-infos
 62:     RetrieveModuleInfo = 4,
 63:     // Also retrieve the version for the DLL/EXE
 64:     RetrieveFileVersion = 8,
 65:     // Contains all the abouve
 66:     RetrieveVerbose = 0xF,
 67:     // Generate a &quot;good&quot; symbol-search-path
 68:     SymBuildPath = 0x10,
 69:     // Also use the public Microsoft-Symbol-Server
 70:     SymUseSymSrv = 0x20,
 71:     // Contains all the abouve &quot;Sym&quot;-options
 72:     SymAll = 0x30,
 73:     // Contains all options (default)
 74:     OptionsAll = 0x3F
 75:   } StackWalkOptions;
 76:   StackWalker(
 77:     int options = OptionsAll, // &apos;int&apos; is by design, to combine the enum-flags
 78:     LPCSTR szSymPath = NULL, 
 79:     DWORD dwProcessId = GetCurrentProcessId(), 
 80:     HANDLE hProcess = GetCurrentProcess()
 81:     );
 82:   StackWalker(DWORD dwProcessId, HANDLE hProcess);
 83:   virtual ~StackWalker();
 84:   typedef BOOL (__stdcall *PReadProcessMemoryRoutine)(
 85:     HANDLE      hProcess,
 86:     DWORD64     qwBaseAddress,
 87:     PVOID       lpBuffer,
 88:     DWORD       nSize,
 89:     LPDWORD     lpNumberOfBytesRead,
 90:     LPVOID      pUserData  // optional data, which was passed in &quot;ShowCallstack&quot;
 91:     );
 92:   BOOL LoadModules();
 93:   BOOL ShowCallstack(
 94:     HANDLE hThread = GetCurrentThread(), 
 95:     const CONTEXT *context = NULL, 
 96:     PReadProcessMemoryRoutine readMemoryFunction = NULL,
 97:     LPVOID pUserData = NULL  // optional to identify some data in the &apos;readMemoryFunction&apos;-callback
 98:     );
 99: #if _MSC_VER &gt;= 1300
100: // due to some reasons, the &quot;STACKWALK_MAX_NAMELEN&quot; must be declared as &quot;public&quot; 
101: // in older compilers in order to use it... starting with VC7 we can declare it as &quot;protected&quot;
102: protected:
103: #endif
104: 	enum { STACKWALK_MAX_NAMELEN = 1024 }; // max name length for found symbols
105: protected:
106:   // Entry for each Callstack-Entry
107:   typedef struct CallstackEntry
108:   {
109:     DWORD64 offset;  // if 0, we have no valid entry
110:     CHAR name[STACKWALK_MAX_NAMELEN];
111:     CHAR undName[STACKWALK_MAX_NAMELEN];
112:     CHAR undFullName[STACKWALK_MAX_NAMELEN];
113:     DWORD64 offsetFromSmybol;
114:     DWORD offsetFromLine;
115:     DWORD lineNumber;
116:     CHAR lineFileName[STACKWALK_MAX_NAMELEN];
117:     DWORD symType;
118:     LPCSTR symTypeString;
119:     CHAR moduleName[STACKWALK_MAX_NAMELEN];
120:     DWORD64 baseOfImage;
121:     CHAR loadedImageName[STACKWALK_MAX_NAMELEN];
122:   } CallstackEntry;
123:   typedef enum CallstackEntryType {firstEntry, nextEntry, lastEntry};
124:   virtual void OnSymInit(LPCSTR szSearchPath, DWORD symOptions, LPCSTR szUserName);
125:   virtual void OnLoadModule(LPCSTR img, LPCSTR mod, DWORD64 baseAddr, DWORD size, DWORD result, LPCSTR symType, LPCSTR pdbName, ULONGLONG fileVersion);
126:   virtual void OnCallstackEntry(CallstackEntryType eType, CallstackEntry &amp;entry);
127:   virtual void OnDbgHelpErr(LPCSTR szFuncName, DWORD gle, DWORD64 addr);
128:   virtual void OnOutput(LPCSTR szText);
129:   StackWalkerInternal *m_sw;
130:   HANDLE m_hProcess;
131:   DWORD m_dwProcessId;
132:   BOOL m_modulesLoaded;
133:   LPSTR m_szSymPath;
134:   int m_options;
135:   int m_MaxRecursionCount;
136:   static BOOL __stdcall myReadProcMem(HANDLE hProcess, DWORD64 qwBaseAddress, PVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead);
137:   friend StackWalkerInternal;
138: };  // class StackWalker
139: // The &quot;ugly&quot; assembler-implementation is needed for systems before XP
140: // If you have a new PSDK and you only compile for XP and later, then you can use 
141: // the &quot;RtlCaptureContext&quot;
142: // Currently there is no define which determines the PSDK-Version... 
143: // So we just use the compiler-version (and assumes that the PSDK is 
144: // the one which was installed by the VS-IDE)
145: // INFO: If you want, you can use the RtlCaptureContext if you only target XP and later...
146: //       But I currently use it in x64/IA64 environments...
147: //#if defined(_M_IX86) &amp;&amp; (_WIN32_WINNT &lt;= 0x0500) &amp;&amp; (_MSC_VER &lt; 1400)
148: #if defined(_M_IX86)
149: #ifdef CURRENT_THREAD_VIA_EXCEPTION
150: // TODO: The following is not a &quot;good&quot; implementation, 
151: // because the callstack is only valid in the &quot;__except&quot; block...
152: #define GET_CURRENT_CONTEXT_STACKWALKER_CODEPLEX(c, contextFlags) \
153:   do { \
154:     memset(&amp;c, 0, sizeof(CONTEXT)); \
155:     EXCEPTION_POINTERS *pExp = NULL; \
156:     __try { \
157:       throw 0; \
158:     } __except( ( (pExp = GetExceptionInformation()) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_EXECUTE_HANDLER)) {} \
159:     if (pExp != NULL) \
160:       memcpy(&amp;c, pExp-&gt;ContextRecord, sizeof(CONTEXT)); \
161:       c.ContextFlags = contextFlags; \
162:   } while(0);
163: #else
164: // The following should be enough for walking the callstack...
165: #define GET_CURRENT_CONTEXT_STACKWALKER_CODEPLEX(c, contextFlags) \
166:   do { \
167:     memset(&amp;c, 0, sizeof(CONTEXT)); \
168:     c.ContextFlags = contextFlags; \
169:     __asm    call x \
170:     __asm x: pop eax \
171:     __asm    mov c.Eip, eax \
172:     __asm    mov c.Ebp, ebp \
173:     __asm    mov c.Esp, esp \
174:   } while(0);
175: #endif
176: #else
177: // The following is defined for x86 (XP and higher), x64 and IA64:
178: #define GET_CURRENT_CONTEXT_STACKWALKER_CODEPLEX(c, contextFlags) \
179:   do { \
180:     memset(&amp;c, 0, sizeof(CONTEXT)); \
181:     c.ContextFlags = contextFlags; \
182:     RtlCaptureContext(&amp;c); \
183: } while(0);
184: #endif</file><file path="thirdparty/StackWalker/StackWalkerHelpers.cpp">  1: /**********************************************************************
  2:  *
  3:  * main.cpp
  4:  *
  5:  *
  6:  * History:
  7:  *  2008-11-27   v1    - Header added
  8:  *                       Samples for Exception-Crashes added...
  9:  *  2009-11-01   v2    - Moved to stackwalker.codeplex.com
 10:  *
 11:  **********************************************************************/
 12: #include &lt;stdio.h&gt;
 13: #include &lt;tchar.h&gt;
 14: #include &quot;stackwalker.h&quot;
 15: static TCHAR s_szExceptionLogFileName[_MAX_PATH] = _T(&quot;\\exceptions.log&quot;);  // default
 16: static BOOL s_bUnhandledExeptionFilterSet = FALSE;
 17: static int argc = 0;
 18: static char **argv = nullptr;
 19: // Specialized stackwalker-output classes
 20: class CustomStackWalker : public StackWalker {
 21:     public:
 22:     virtual void OnOutput(LPCSTR szText) {
 23:         auto hAppend = CreateFile(TEXT(s_szExceptionLogFileName),
 24:                                   FILE_APPEND_DATA,       // open for writing
 25:                                   FILE_SHARE_READ,        // allow multiple readers
 26:                                   NULL,                   // no security
 27:                                   OPEN_ALWAYS,            // open or create
 28:                                   FILE_ATTRIBUTE_NORMAL,  // normal file
 29:                                   NULL);                  // no attr. template
 30:         WriteFile(hAppend, szText, strlen(szText), nullptr, nullptr);
 31:         CloseHandle(hAppend);
 32:     }
 33:     // Don&apos;t care about all the module ouput.
 34:     void OnLoadModule(LPCSTR, LPCSTR, DWORD64, DWORD, DWORD, LPCSTR, LPCSTR, ULONGLONG) {}
 35: };
 36: // For more info about &quot;PreventSetUnhandledExceptionFilter&quot; see:
 37: // &quot;SetUnhandledExceptionFilter&quot; and VC8
 38: // http://blog.kalmbachnet.de/?postid=75
 39: // and
 40: // Unhandled exceptions in VC8 and above for x86 and x64
 41: // http://blog.kalmbach-software.de/2008/04/02/unhandled-exceptions-in-vc8-and-above-for-x86-and-x64/
 42: // Even better:
 43: // http://blog.kalmbach-software.de/2013/05/23/improvedpreventsetunhandledexceptionfilter/
 44: #if defined _M_X64 || defined _M_IX86
 45: static BOOL PreventSetUnhandledExceptionFilter() {
 46:     HMODULE hKernel32 = LoadLibrary(_T(&quot;kernel32.dll&quot;));
 47:     if (hKernel32 == NULL) return FALSE;
 48:     void *pOrgEntry = GetProcAddress(hKernel32, &quot;SetUnhandledExceptionFilter&quot;);
 49:     if (pOrgEntry == NULL) return FALSE;
 50: #   ifdef _M_IX86
 51:     // Code for x86:
 52:     // 33 C0                xor         eax,eax
 53:     // C2 04 00             ret         4
 54:     unsigned char szExecute[] = { 0x33, 0xC0, 0xC2, 0x04, 0x00 };
 55: #   elif _M_X64
 56:     // 33 C0                xor         eax,eax
 57:     // C3                   ret
 58:     unsigned char szExecute[] = { 0x33, 0xC0, 0xC3 };
 59: #   else
 60: #        error &quot;The following code only works for x86 and x64!&quot;
 61: #   endif
 62:     DWORD dwOldProtect = 0;
 63:     BOOL bProt =
 64:         VirtualProtect(pOrgEntry, sizeof(szExecute), PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);
 65:     SIZE_T bytesWritten = 0;
 66:     BOOL bRet = WriteProcessMemory(GetCurrentProcess(), pOrgEntry, szExecute, sizeof(szExecute),
 67:                                    &amp;bytesWritten);
 68:     if ((bProt != FALSE) &amp;&amp; (dwOldProtect != PAGE_EXECUTE_READWRITE)) {
 69:         DWORD dwBuf;
 70:         VirtualProtect(pOrgEntry, sizeof(szExecute), dwOldProtect, &amp;dwBuf);
 71:     }
 72:     return bRet;
 73: }
 74: #else
 75: #    pragma message(&quot;This code works only for x86 and x64!&quot;)
 76: #endif
 77: static LONG __stdcall CrashHandlerExceptionFilter(EXCEPTION_POINTERS *pExPtrs) {
 78: #   ifdef _M_IX86
 79:     if (pExPtrs-&gt;ExceptionRecord-&gt;ExceptionCode == EXCEPTION_STACK_OVERFLOW) {
 80:         static char MyStack[1024 * 128];  // be sure that we have enought space...
 81:         // it assumes that DS and SS are the same!!! (this is the case for Win32)
 82:         // change the stack only if the selectors are the same (this is the case for Win32)
 83:         //__asm push offset MyStack[1024*128];
 84:         //__asm pop esp;
 85:         __asm mov eax, offset MyStack[1024 * 128];
 86:         __asm mov esp, eax;
 87:     }
 88: #   endif
 89:     CustomStackWalker sw;  // output to console
 90:     sw.OnOutput(&quot;===== Crash Log =====\n&quot;);
 91:     SYSTEMTIME st;
 92:     GetSystemTime(&amp;st);
 93:     const size_t buflen = 1024;
 94:     TCHAR lString[buflen] = { 0 };
 95:     sprintf_s(lString, buflen, _T(&quot;Date: %d-%02d-%02d, Time: %02d:%02d:%02d\n&quot;),
 96:                 st.wYear, st.wMonth, st.wDay, st.wHour, st.wMinute, st.wSecond);
 97:     sw.OnOutput(lString);
 98:     sw.OnOutput(&quot;CMD: &quot;);
 99:     for (int i = 0; i &lt; argc; i++) {
100:         sw.OnOutput(argv[i]);
101:         sw.OnOutput(&quot; &quot;);
102:     }
103:     sw.OnOutput(&quot;\n&quot;);
104:     sprintf_s(lString, buflen, _T(&quot;ExpCode: 0x%8.8X, ExpFlags: %d, ExpAddress: 0x%8.8X\n&quot;),
105:                 pExPtrs-&gt;ExceptionRecord-&gt;ExceptionCode, pExPtrs-&gt;ExceptionRecord-&gt;ExceptionFlags,
106:                 pExPtrs-&gt;ExceptionRecord-&gt;ExceptionAddress);
107:     sw.OnOutput(lString);
108:     sw.ShowCallstack(GetCurrentThread(), pExPtrs-&gt;ContextRecord);
109:     sw.OnOutput(&quot;\n&quot;);
110:     sprintf_s(lString, buflen, _T(&quot;Please send %s to the developer!\n&quot;), s_szExceptionLogFileName);
111:     for (int i = 1; i &lt; argc; i++) {
112:         strcat_s(lString, buflen, argv[i]);
113:         strcat_s(lString, buflen, &quot; &quot;);
114:     }
115:     strcat_s(lString, buflen, &quot;\n&quot;);
116:     FatalAppExit(-1, lString);
117:     return EXCEPTION_CONTINUE_SEARCH;
118: }
119: void InitUnhandledExceptionFilter(int _argc, char *_argv[]) {
120:     argc = _argc;
121:     argv = _argv;
122:     TCHAR szModName[_MAX_PATH];
123:     if (GetModuleFileName(NULL, szModName, sizeof(szModName) / sizeof(TCHAR)) != 0) {
124:         _tcscpy_s(s_szExceptionLogFileName, szModName);
125:         _tcscat_s(s_szExceptionLogFileName, _T(&quot;.exp.log&quot;));
126:     }
127:     if (s_bUnhandledExeptionFilterSet == FALSE) {
128:         // set global exception handler (for handling all unhandled exceptions)
129:         SetUnhandledExceptionFilter(CrashHandlerExceptionFilter);
130: #   if defined _M_X64 || defined _M_IX86
131:         PreventSetUnhandledExceptionFilter();
132: #   endif
133:         s_bUnhandledExeptionFilterSet = TRUE;
134:     }
135: }</file><file path="TS/docs/donations.html"> 1: &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
 2: &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
 3: &lt;html&gt;
 4: &lt;head&gt;
 5: &lt;title&gt;TreeSheets Donations &amp;amp; Sponsors&lt;/title&gt;
 6: &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
 7: &lt;style type=&quot;text/css&quot;&gt;
 8: &lt;!--
 9: body {
10: 	background-color: #666666;
11: }
12: .style13 {
13: 	font-size: normal
14: }
15: .style13l {
16: 	font-size: large
17: }
18: div#rounded{
19: 	background: #FFF;
20: 	width: 580px;
21: 	margin-left: auto;
22: 	margin-right: auto;
23: }
24: div#roundedcontent{
25: 	padding: 20px;
26: }
27: b.rtop, b.rbottom{display:block;background: #666}
28: b.rtop b, b.rbottom b{display:block;height: 1px; overflow: hidden; background: #FFF}
29: b.r1{margin: 0 5px}
30: b.r2{margin: 0 3px}
31: b.r3{margin: 0 2px}
32: b.rtop b.r4, b.rbottom b.r4{margin: 0 1px;height: 2px}
33: .style15 {font-family: Verdana, Arial, Helvetica, sans-serif}
34: .style16 {font-size: small}
35: --&gt;
36: &lt;/style&gt;
37: &lt;/head&gt;
38: &lt;body&gt;
39: &lt;div id=&quot;rounded&quot;&gt;&lt;b class=&quot;rtop&quot;&gt;&lt;b class=&quot;r1&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r2&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r3&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r4&quot;&gt;&lt;/b&gt;&lt;/b&gt;&lt;div class=&quot;style15&quot; id=&quot;roundedcontent&quot;&gt;
40: &lt;p align=&quot;center&quot; class=&quot;style13&quot;&gt;&lt;img src=&quot;images/treesheets_logo.png&quot; width=&quot;507&quot; height=&quot;156&quot;&gt;&lt;/p&gt;
41: &lt;p align=&quot;center&quot; class=&quot;style13l&quot;&gt;Donations&lt;/p&gt;
42: &lt;p class=&quot;style13&quot;&gt;The following generous people have donated to TreeSheets:&lt;/p&gt;
43: &lt;p class=&quot;style16&quot;&gt;(Highest donations first):&lt;/p&gt;
44: &lt;p class=&quot;style13&quot;&gt;
45: Pierre van Male de Ghorain, David Lynch, Michael Wicher, Alexander Deliyannis, Hunter Elofson, James McGuire,
46: NameAction Chile S. A., Dietmar Bellersheim, Infolution B.V., Xavier Masson, dotpeople, Matthew Probst,
47: Francisco Gracia, Roland Breuer, Yechen Mao, Jeffrey Goatcher, Eric Raible, Gnter Marangoni,
48: Zdenek Krejci, Daniel Kimblad, Carsten Heitmann, Robert Mischke, Nasul Magallanes, Yango Pohl,
49: Tab Hockamier, More Addin, Alistair McGhee, Thorsten Schwesig, QuantumFlux42, Frank Salinas, Tobias Skarman,
50: Olav Schettler, iliis, Adam Glowalla, One Man Talking, Amy Young, Ulrich Benzing, Dragan Espenschied,
51: Alberto Egidi, Kevin Whitaker, BTWReviews.com, Dnes Harmath, Aleksis Doma, Arthur Koks, Matthias Knoefel,
52: Tikhonov Aleksey, Danylo Dubinin, Howard, Daniel Rosenberg, Asish Kar-Roy, Keith Haddad.
53: &lt;/p&gt;
54: &lt;p class=&quot;style13&quot;&gt;(+ quite a few anonymous donations).&lt;p&gt;
55: &lt;p class=&quot;style16&quot;&gt;I am no longer requesting donations at this point. While I am grateful for the support
56: of the above people, the total amount donated so far from 2008 to 2018 is $2007, or about $16 per month.&lt;/p&gt;
57: &lt;/div&gt;&lt;b class=&quot;rbottom&quot;&gt;&lt;b class=&quot;r4&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r3&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r2&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r1&quot;&gt;&lt;/b&gt;&lt;/b&gt;&lt;/div&gt;
58: &lt;/body&gt;
59: &lt;/html&gt;</file><file path="TS/docs/file_format_spec.txt"> 1: File format spec for TreeSheets .cts files, version 23. This should be enough for a programmer to write an importer/exporter.
 2: 
 3: struct File     // not really a struct, i.e. no alignment, read an element at a time
 4: {
 5:     char magic[4] = &quot;TSFF&quot;;
 6:     char version = 23;
 7:     // TreeSheets saves the selection and the zoom level when the file is saved.
 8:     int xs; // xs is the number of cells within the selection in x direction
 9:     int ys; // ys is the number of cells within the selection in y direction
10:     int zoomlevel; // zoom level of the document
11:     
12:     Image images[0 or more];
13: 
14:     char ident = &apos;D&apos;;   // marks start of document, and end of list of images
15: 
16:     // the remainder of the file from here is written as a zlib compressed stream
17:     Cell root;
18: 
19:     for (;;) {
20:         String tagname; // terminated by empty string];
21:         int tagcolor;
22:     }
23: }
24: 
25: struct Image
26: {
27:     char ident;   // marks start of image
28:     // Character value depends on image type, i.e. &apos;I&apos; for PNG and &apos;J&apos; for JPEG
29:     double display_scale; // display scale of image
30:     int64_t imagelen; // length of image (8 bytes)
31:     char image_data[len]; // whatever format wxImage::LoadFile uses
32: }
33: 
34: struct Cell
35: {
36:     uchar celltype;     // enum { CT_DATA = 0, CT_CODE, CT_VARD, CT_VIEWH, CT_VARU, CT_VIEWV };
37:     uint cellcolor;
38:     uint textcolor;
39:     uchar drawstyle;    // enum { DS_GRID, DS_BLOBSHIER, DS_BLOBLINE };
40:     uchar cellcontents; // enum { TS_TEXT = 0, TS_GRID, TS_BOTH, TS_NEITHER };
41:     // The first cell that is within the selection is marked with the highest bit set to 1 (1 x x x x x x x) in cellcontents.
42:     if (TS_TEXT or TS_BOTH)
43:     {
44:         String text;
45:         uint relativesize;
46:         uint imageindex; // or 0xFFFFFFFF for no image
47:         uint stylebits;   // enum { STYLE_BOLD = 1, STYLE_ITALIC = 2, STYLE_FIXED = 4, STYLE_UNDERLINE = 8, STYLE_STRIKETHRU = 16 };
48:         uint64 lastedit;    // internal representation of wxDateTime
49:     }
50:     if (TS_GRID or TS_BOTH)
51:     {
52:         uint xs, ys;
53:         uint bordercolor;
54:         uint user_grid_outer_spacing;
55:         uchar verticaltextandgrid;
56:         uchar folded;
57:         uint columnwidths[xs];
58:         Cell cells[xs * ys]; // row major
59:     }
60: }
61: 
62: struct String  // as wxDataOutputStream::WriteString writes it, apparently UTF-8 prefixed by length</file><file path="TS/docs/history.txt">  1: since development moved to GitHub, the list of changes here may not be up to date.
  2: The most accurate list of changes will be GitHub commit history:
  3: https://github.com/aardappel/treesheets/commits/master
  4: 
  5: 2013-06-02:
  6: - TreeSheets is now open source! https://github.com/aardappel/treesheets
  7: - you can now set the background color on a per document basis
  8: - you can now turn off cursor key navigation of in between cell locations
  9: - integrated new wxWidgets 2.9.4, which probably fixed a lot of problems, particularly on OS X (which has now graduated from Alpha to Beta :).
 10: - you can now pick a default font size when you pick a default font. This is a per user setting, not per document, other users will open your documents at their preferred size.
 11: - Edit -&gt; Copy As Continuous Text puts a single line of text merged from any selection into the clipboard. Useful for merging the text of multiple small cells, 
 12:   or making a paragraph out of many cells for use in another application.
 13: - home/end now move within a line, whereas ctrl+home/end move within the entire text of the cell
 14: - improved rendering of line rendering style and background color picking
 15: - added additional space to cell margins
 16: - hover over wasn&apos;t updated during mousewheel scroll
 17: - optimized drag &amp; drop of external files to not scroll/select while dragging
 18: - fixed ALT+F etc. not popping up the File menu
 19: - improved editing of search/replace boxes supporting shift+cursor/home/end etc.
 20: - on Linux, the Fold operation is now SHIFT+F10 instead of F10 to not clash with Ubuntu pre-defined keys.
 21: 
 22: 2012-04-07:
 23: - fixed bug caused by right-clicking on a modified selection
 24: - possibly fixed problem related to &quot;automatically reload files&quot; popping up multiple dialogs at once
 25: 
 26: 2011-08-25:
 27: - fixed missing UTF-8 charset header in HTML export
 28: - fixed fold not being preserved on copy/past and undo
 29: - Now detects when a file that is loaded has been modified on disk by another program / computer,
 30:   and reloads the file automatically (if it hasn&apos;t been changed) or asks (if it has).
 31:   This allows multiple computers to seamlessly work with 1 treesheets file over services like DropBox.
 32:   This functionality is by default turned OFF (see Options -&gt; Auto reload documents) because it is
 33:   potentially expensive if the treesheets file is in a folder with lots of subfolders. 
 34:   Also not working on network drives at the moment.
 35: - HOME &amp; END now change selection in a grid
 36: - INS on a cell that already has a grid now selects the last line of that grid, ready for inserting an item
 37: - fixed INS not unfolding a folded cell
 38: - fix for broken OSX clipboard functionality
 39: - added menu keyboard navigation accellerators
 40: - fixed bug in CTRL+x on empty text selection
 41: - fixed bug in CTRL+up/down in text edit mode
 42: 
 43: 2011-04-30:
 44: - fixed bug in horizontal cell layout text selection
 45: - clear status message when switching tabs or entering search
 46: - fixed bug in shift+cursor selection
 47: - fixed semi-colon CSV import
 48: - fixed loading a tmp file not marking the document as modified
 49: 
 50: 2011-04-19:
 51: - folding of grids: Edit -&gt; Toggle Fold (F10) on cell(s) hides the grids they contain.
 52:   Folded cells will be marked with a &apos;+&apos; symbol in front of them
 53:   If you zoom into them, you will see the full grid, without having to fold/unfold.
 54:   A nice alternative to shrinking text if your sheet gets too big.
 55: - Redo (CTRL+y) now works.
 56: - an image drop down menu provides a convenient set of images you can quickly add to selected cells
 57: - there&apos;s now a strikethrough style (useful for todo/task lists!) using the CTRL+t shortcut (previously transpose)
 58: - added alternative (black &amp; white) toolbar icon set (see options menu)
 59: - &quot;Sort&quot; now sorts on subsequent columns if data in the current column is equal
 60: - &quot;Sort&quot; can now be either ascending or descending
 61: - outputs statistics on file when loading
 62: - added commands to reset text sizes, styles, colors and column widths within the current selection (see Edit menu)
 63: - [making a lot of edits to a single cell will now set multiple undo points rather than just a single one] -&gt; removed in favor of Redo
 64: - added shift+del, shift+insert and ctrl+insert as alternatives for ctrl+x, ctrl+v, ctrl+c
 65: - double clicking grid boundaries now selects that entire grid, not the parent cell
 66: - option: render document centered or not
 67: - option: minimize on close
 68: - option: single click maximize from tray
 69: - images in front of text rendered centered
 70: - improved toolbar dropdown rendering &amp; size
 71: - images don&apos;t resize anymore when changing the text size of a cell,
 72:   instead there&apos;s now a function to change the size of an image (Edit -&gt; Images -&gt; Scale)
 73: - cells shrunks to tiny size don&apos;t show images
 74: - documents always show a small gutter, regardless of size
 75: - CTRL+f now selects any previous text in the search box, CTRL+a selects all, and HOME/END work too
 76: - made the interactive tutorial the default help (F1), both it and the old html tutorial available from the menu
 77: - selects the parent if you cut or delete all children &amp; doesn&apos;t allow deleting of all children of the root of the current view
 78: - fixed filtering making everything tiny if cell text of grid was filtered, now doesn&apos;t minimize cells with grids, just greys them out
 79: - fixed text selection not showing correctly with image in front
 80: - fixed failing autosave popping up endless dialog boxes
 81: - fixed undo causing file to be marked as not modified
 82: - fixed horizontal layout being reset by some operations
 83: - fixed line style rendering sometimes having wrong background color
 84: - fixed style settings on &quot;Wrap in new parent&quot;
 85: - fixed statusbar items not showing fully on some systems
 86: - fixed bug with badly formatted indented text not being pasted/imported properly
 87: - fixed selection being off in scaled presentation mode
 88: - fixed bug with international characters in filenames
 89: 
 90: 2010-11-14:
 91: - fixed selection box being rendered in the wrong location after switching resolutions
 92: - fixed it repeatedly trying to save temp files when temp file saving fails
 93: 
 94: 2010-10-15:
 95: - fixed crash in &quot;Hierarchy Swap&quot; operation on leaf cells
 96: - &quot;escape&quot; did not exit edit mode, as it used to
 97: - new cells sometimes would not get applied the correct rendering style (from siblings or parent)
 98: - changing fonts could leave other open documents with incorrect rendering
 99: - transpose now keeps a selection
100: 
101: 2010-10-10:
102: - fixed bug where text background would not be set correctly, mostly resulting in incorrect printouts
103: 
104: 2010-09-28:
105: - fixed bug that would stop certain operations work on single cell grids (such as browse)
106: 
107: 2010-09-20:
108: - Added new rendering options for grids, see tutorial.cts for examples, or todo_calendar.cts
109: - on multi line text, cursor up &amp; down now moves line by line before moving to the next cell
110: - new tabs that have individual close buttons, can be reordered, and by default are at the bottom (use option to move them to the top)
111:   CTRL+TAB cycles thru all tabs
112: - CTRL+mouse drag moves a cell to a destination (like Cut + Paste)
113:   ALT+mouse drag copies a cell to a destination (like Copy + Paste)
114: - minimum size of sizing cells is now relative to the current view rather than the root of the document, allowing you to make extremely
115:   hierarchical documents (important for presentations).
116: - Some operations that work on grids and required you to select the parent cell to operate now also work if you simply select all cells of the grid.
117:   This is more intuitive to some people, and also allows these actions on the root grid, which didn&apos;t work before.
118:   Affected operations sofar: transpose, flatten, hierarchify, and the cell rendering options
119: - when loading a file that is already open, instead of the &quot;this file is already loaded&quot; dialog it now simply switches to the open document
120: - Added option to swap mousewheel scrolling and zooming operations (make scrolling require CTRL instead of zooming)
121: - Made top toolbar more compact to fit on netbook screens better
122: - Ctrl+W (close) or closing last tab now simply quits TreeSheets. CTRL+q quits / closes all tabs.
123: - When clearing a cell with delete/backspace, it now keeps its colors/styling
124: - Statusbar now shows date of last edit of cell you hover over. The furthest these dates go back is cells edited since the 2010-03-10 release
125:   of TreeSheets, since older versions didn&apos;t record this information.
126: - Fixed pasting of NxN grid selections into grids, it behaves much more logical now
127: - Fixed potential crash bug in closing tabs
128: - On paste, cursor is at the end of the pasted string
129: - New grids take default column width from their parent
130: - Added column sizing method that does not size any sub grids
131: - Improved line-splitting for ( and )
132: - Added remove image operation
133: - Added seperators to the menus for clarity, and moved some lesser used editing operations into submenus.
134:   The roundness setting now shows its current value.
135: - Fixed rendering of editing in presentation view
136: - Status bar updates even if mouse pointer doesn&apos;t move
137: - Fixed refresh error in Hierarchy Swap operation, and one related to scrolling
138: - Fixed filename being reset on a cancelled Save As
139: - Single instance check file under linux is now hidden
140: - Rewrote some of the column width related code to make it more robust, fixed several bugs in it
141: 
142: 2010-03-22:
143: - &quot;Paste Style Only&quot; pastes only the color/style/image from the copied cell into the destination cells, not the text
144: - dragging middle mouse button (mousewheel down) now pans
145: - Scrolling smoother on &quot;continous&quot; mousewheels
146: - Fixed undo resetting column width to default
147: - Fixed zoomed in views sometimes not rendering correct background color
148: 
149: 2010-03-10:
150: - Grid borders can now be rendered with round corners. The &quot;roundness&quot; can be set in the options menu.
151: - Added &quot;tags&quot;. Tags make cell texts that are used repeatedly easier to assign, recognize, and keep consistent. See menu edit/tags.
152: - Added &quot;Toggle Grid Below/Next to Text&quot; (F7) for yet more flexible layout possibilities
153: - Added &quot;Hierarchify&quot; and &quot;Flatten&quot; operations that simplify data portability between TreeSheets and spreadsheets
154: - Added export to &quot;CSV&quot; format.
155: - Added &quot;Hierarchy Swap&quot; (F8) operation (see tutorial)
156: - Added &quot;Wrap in new parent&quot; (F9) operation to easily create new hierarchy (works on any selection)
157: - Added &quot;filters&quot; (see View menu). A filter forces all cells not included to be shown as 1 pixel characters in lighter grey,
158:   so its easy to focus visually on whats important in really large TreeSheets files. Currently, there&apos;s filters for the search
159:   results, and for a % percent of last edited cells. This feature works because TreeSheets now records the last edit time for
160:   each cell. Since older TreeSheets files do not have this information, it may take a while of editing before this feature becomes useful.
161: - Completely reworked how columns are sized. Now every column in a grid simply has a character width which can be resized by
162:   SHIFT+mousewheel as before, instead of the clumsy per cell linecount. Column width is shown in the statusbar.
163:   Resizing affects the column(s) spanning the current selection, and any grids inside of it. Layout is quicker and more
164:   predictable. Default column width is 80 characters, so you may have to resize some old treesheets files.
165: - When zooming in, now shows you the &quot;context&quot; of what you&apos;re looking at in light grey text (the text of all the parent cells)
166: - Added &quot;Open File&quot; (F4), which loads a filename in the associated application (paths relative to where the .cts is stored).
167: - Improved the UI to be more like other applications and more consistent. Primarily, the mousewheel and PgUp/PgDn now
168:   always work the same, without modifiers they scroll, with CTRL they zoom, with SHIFT they change text size, and with
169:   ALT they change column size.
170: - Support for mousewheel scrolling horizontally (on mice that support it) has been added (NOT TESTED).
171: - fixed bug where &quot;replace&quot; could loop indefinitely if the replacement string contained an occurrence of the search string :)
172: - Tabs are shown on the left by default (change in options)
173: - small improvements to the builtin programming language
174: - Option for faster line rendering (useful if you have very complex sheets, or lots of 1 pixel text)
175: - text rendering is lots faster on windows now
176: - Fixed bug in CVS import where it wouldn&apos;t parse linefeeds inside &quot;&quot; correctly
177: - Fixed bug where closing some but not all documents could make TreeSheets confused as to which document it is looking at
178: - Fixed bug where it could display the wrong filename on tabs/window title due to autosave
179: - Linux bug related to unicode keystrokes workaround 
180: - Linux now has wxwidgets 2.9 statically linked, so doesn&apos;t require that to be installed anymore
181: 
182: 2009-11-05:
183: - You can now change both the color and width of grid borders
184: - Added fullscreen toggle (F11), and scaling toggle (F12): useful for presentations.
185:   TreeSheets can do better presentations than powerpoint this way, as you can structure your presentation
186:   around hierarchical zooming, which is much more coherent than a sequential set of slides
187: - HTML export now sets colors &amp; styles
188: - HTML/XML/TXT export now always export the current view instead of the entire document (much like image export)
189: - Now remembers all open files when you re-start TreeSheets
190: - Added option to show file tabs on the left instead of on top (to save vertical space)
191: - The &quot;Open link in browser&quot; and &quot;Go to matching cell&quot; functions now also work on text selections rather than just whole cells
192: - Added SHIFT + Home/End operations for text editing (extends selection)
193: - improved grid rendering to have a tiny margin
194: - improved the way it scrolls the selected cell into view if it is partially out of view
195: - find next (F3) zoom in automatically if cell is too small to read
196: - Extend Selection to Full Rows/Columns of current selection
197: - fixed: deleting the top level grid on a zoomed in view would crash
198: - fixed: cancelling new file dialog would crash treesheets
199: - fixed: icon did not show in the window frame
200: - fixed: filenames could get confused when switching tabs
201: - fixed: text editing in both search controls
202: - fixed: possible hang in rendering with truely huge treesheets files
203: - made the automatic text sizing at zoom a bit more reliable
204: - removed the &quot;remove grid&quot; (CTRL+r), &quot;replace parent&quot; and &quot;merge with parent&quot; (CTRL+m) operations,
205:   as simply using copy/paste/delete on the cells instead is much more intuitive
206: - window now de-minimizes from tray if app is launched again or a treesheets file is launched from explorer
207: - shows filename on &quot;discard changes?&quot; dialog
208: - updated the tutorial with some recent features, and the spreadsheet language
209: - shows &lt;unnamed&gt; on new tabs
210: - linux fixes
211: 
212: 2009-06-30:
213: - Prevents multiple instances being opened, instead files launched will open in the existing instance
214: - Will notify you if you accidentally try to open the same file
215: - empty cells are now at least square in size
216: - shows a &quot;+&quot; instead of a &quot;*&quot; when a file has been modified but has been autosaved
217: - fixed ENTER stopped working (caused by tabs)
218: - fixed bug that could cause characters to be missing on a multiline rendering
219: 
220: 2009-06-25:
221: - Multiple documents can now be open in a single TreeSheets instance.
222:   - Tabs allow you to switch between them.
223:   - copy/paste between seperate files within the same instance of TreeSheets now retain layout and images faithfully.
224: - Search functionality:
225:   - CTRL+F focuses on search box
226:   - press F3 to cycle through all search results
227:   - Replace box, type text in here, and then use:
228:     - Replace All to replace all occurrences of the current search
229:     - Replace in Current Selection: either work in combination with F3 to selectively replace search results,
230:       or you can even select a hierarchical subset of all search results and then replace all in that.
231: - autosave: saves files that have unsaved modifications to a .tmp whenever the file hasn&apos;t been saved for 5 minutes,
232:   you go idle for 1 minute, you minimize or deactivate the window, whichever comes first. This file gets removed if you do an explicit save,
233:   and you can restore it should your machine crash (TreeSheets will ask you). Does not activate for &quot;new&quot; files that have never been saved before.
234: - made multi-cell Paste (and Merge with Parent) not insert unnecessary cells when blank cells are available at the target location
235: - added &quot;Minimize to Tray&quot; option
236: - added Sort operation: make a 1xN to indicate what column to sort on, and what rows to affect
237: - drag &amp; drop of files now works, currently only image files supported (anything else appears as the filename). May support other formats in the future.
238: - added seperate XML with attributes import mode (for formats that store their data there, like OPML)
239: - CTRL+SHIFT+cursor left &amp; right now select words at a time in edit mode (much like any text editor)
240: - automatically increases the number of lines in a cell if text insertions cause it to go over N characters average, configurable from the menu.
241: - fixed status bar not updating when changing text size on a cell
242: - you can now undo past the point of your last save, all the way to how you loaded it
243: - added menu option to disable writing of .bak files on save
244: - &quot;Set Print Scale&quot; allows simplistic scaling of print output. No multi-page output yet.
245: - fixed image export not clearing background correctly
246: - fixed tutorial file not being added to the file history correctly
247: 
248: 2009-04-26:
249: - fixed thin selections not centering on zoom
250: - fixed cursor keys &amp; tab on linux
251: 
252: 2009-04-25:
253: - can now copy/paste and drag&amp;drop images and text directly from other apps into a treesheet (e.g. web browser, photoshop, etc).
254: - you can now select a custom color, and assign it to cells from the color menu
255: - improved color/style picking for new rows/columns inserted
256: - automatically scrolls &amp; zooms out to bring the current selection in view for most operations (keyboard movement, etc).
257: - optimized the screen refreshing
258: - when copying a single cell, now properly remembers number of lines, color/style
259: - ENTER on grid line selections now inserts a cell
260: - SHIFT+leftmouse now enlarges the selection, same as if you had dragged to that location.
261: - Export current view as PNG file
262: - fixed bug in printer scaling
263: - made mousewheel accumulative, to hopefully make zooming work better on continuous mousewheels.
264: 
265: 2009-04-19:
266: - Added &quot;Go To Matching Cell&quot; (F6) function: will select whatever cell has the same text. If multiple other cells are
267:   available, will prefer to go to a cell that has different formatting (color/style) than the current cell (this is
268:   to allow this feature to be used as specially marked &quot;links&quot; to a reference cell).
269: - as a temporary solution, added a &quot;simple rendering mode&quot; that does not make use of XOR to show selections, and
270:   thus renders correctly on on MaxOSX and Linux. It is slower to refresh and does not give hovering feedback, but at
271:   least it works. More advanced rendering on these platforms will have to wait until wxWidgets supports wxOverlay&apos;s
272:   with blending.
273: - fixed several issues where the linux version of the wxWidgets behaves differently
274: - Made some improvements to make the UI more compliant on the Mac (about/exit menus, drag &amp; drop, some shortcuts)
275: - fixed crash bug related to right-clicking outside the treesheet
276: - added a &quot;traditional mousewheel&quot; option that swaps the zoom &amp; scroll functions
277: - removed the floating grey cursor (it was confusing)
278: - the text cursor is now a blinking black line (as in Excel)
279: 
280: 2009-04-02:
281: - XML export now writes text size/color/style information
282: - XML import now recognizes its own XML code (grid sizes, text size/color/style), thus can reconstruct a treesheets file 1:1
283: - rewrote the line splitting algorithm to allow more characters to be the splitting point
284: - rewrote the column resizing algorithm to work more accurately
285: - Added semi-colon CSV format as an alternative to comma CSV import
286: - ESC now selects the parent cell of the current selection if not in text edit mode, and SHIFT+ENTER selects the first child
287: - added underlined style
288: - no longer creates a new selection if you right-click inside an existing selection
289: - added keyboard shortcuts for text size and line count (CTRL/SHIFT + PGUP/PGDN)
290: - double clicking the current color assigns it directly to the selection, as intended
291: - fixed line rendering bug when using colored grids
292: 
293: 2009-03-20:
294: - every cell can now have its own background and text color
295: - shows an edit mouse cursor in text edit mode
296: - made ctrl+p mean print rather than replace parent
297: - created work-around for cursor left/right &amp; delete not working in the search box
298: - fixed bug in Undo coalescing that could cause crash
299: 
300: 2009-02-27:
301: - automated column resizing! SHIFT+mousewheel now finds the widest (or thinnest) cell in a column instead of just resizing the current cell.
302:   Even works on multiple columns at once or hierarchically.
303: - added CSV (comma seperated values, for use with Excel), tab delimited text and indented text as import options
304: - added outline html export, which loads into Word as an hierarchical set of headers
305: - Search box in the toolbar: shows all text that matches the search in red. May add more featureful search &amp; replace in the future
306: - ALT + cursor keys or mousewheel scrolls the view
307: - Undo undoes all edits in a single cell all at once, and ESC is the same as Undo + leave text mode, when in text mode (just like Excel)
308: - Select all (CTRL+a) expands the current selection to the entire grid it is in
309: - shift+tab goes to previous cell
310: - added &quot;launch in browser&quot; for cells with urls in them (F5)
311: - added F2 (rename in my many apps) as an alternative to ENTER to enter text edit mode
312: - fixed bug where backspace wouldn&apos;t delete entire cell selection
313: - fixed unusued special keys (such as F1) showing up as random characters
314: 
315: 2009-02-24:
316: - doubleclick to select a word (when already in text edit mode), and doubleclick+drag to select a range of words
317: - TAB now advanced to the next cell (to the right, or down, or back again to the top) and also selects its contents in text mode.
318: - Any cell can now have a &quot;style&quot;, sofar available: bold/italic/typewriter
319: - increased maximum font size
320: - fixed XML export doctype
321: 
322: 2009-02-20:
323: - initial &quot;polished&quot; release (history below this point deleted)
324: 
325: 2009-01-25:
326: - initial public release
327: 
328: 2009-01-19:
329: - closed beta release</file><file path="TS/docs/screenshots.html"> 1: &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
 2: &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
 3: &lt;html&gt;
 4: &lt;head&gt;
 5: &lt;title&gt;TreeSheets Screenshots&lt;/title&gt;
 6: &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=iso-8859-1&quot;&gt;
 7: &lt;style type=&quot;text/css&quot;&gt;
 8: &lt;!--
 9: .style10 {
10: 	font-size: xx-large;
11: 	font-family: Verdana, Arial, Helvetica, sans-serif;
12: }
13: .style11 {font-family: Verdana, Arial, Helvetica, sans-serif; font-size: large; }
14: body {
15: 	background-color: #666666;
16: }
17: .style12 {font-family: Verdana, Arial, Helvetica, sans-serif}
18: div#rounded{
19: 	background: #FFF;
20: 	width: 1260px;
21: 	margin-left: auto;
22: 	margin-right: auto;
23: }
24: div#roundedcontent{
25: 	padding: 20px;
26: }
27: b.rtop, b.rbottom{display:block;background: #666}
28: b.rtop b, b.rbottom b{display:block;height: 1px; overflow: hidden; background: #FFF}
29: b.r1{margin: 0 5px}
30: b.r2{margin: 0 3px}
31: b.r3{margin: 0 2px}
32: b.rtop b.r4, b.rbottom b.r4{margin: 0 1px;height: 2px}
33: --&gt;
34: &lt;/style&gt;
35: &lt;/head&gt;
36: &lt;body&gt;
37: &lt;div id=&quot;rounded&quot;&gt;&lt;b class=&quot;rtop&quot;&gt;&lt;b class=&quot;r1&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r2&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r3&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r4&quot;&gt;&lt;/b&gt;&lt;/b&gt;&lt;div id=&quot;roundedcontent&quot;&gt;
38: &lt;p align=&quot;center&quot; class=&quot;style10&quot;&gt;&lt;img src=&quot;images/treesheets_logo.png&quot; width=&quot;507&quot; height=&quot;156&quot;&gt;&lt;/p&gt;
39: &lt;p align=&quot;center&quot; class=&quot;style10&quot;&gt;Screenshots&lt;/p&gt;
40: &lt;p align=&quot;center&quot; class=&quot;style11&quot;&gt;&lt;img src=&quot;images/screenshots/screenshot_todo.png&quot; width=&quot;1214&quot; height=&quot;995&quot;&gt;        &lt;/p&gt;
41:     &lt;p align=&quot;center&quot; class=&quot;style11&quot;&gt;&lt;img src=&quot;images/screenshots/screenshot_unicode.png&quot; width=&quot;842&quot; height=&quot;1087&quot;&gt;&lt;/p&gt;
42:     &lt;p align=&quot;center&quot; class=&quot;style11&quot;&gt;&lt;img src=&quot;images/screenshots/screenshot_personel.png&quot; width=&quot;1021&quot; height=&quot;714&quot;&gt;&lt;/p&gt;
43:     &lt;p align=&quot;center&quot; class=&quot;style11&quot;&gt;&lt;img src=&quot;images/screenshots/screenshot_sales.png&quot; width=&quot;635&quot; height=&quot;427&quot;&gt;&lt;/p&gt;
44:     &lt;p align=&quot;center&quot; class=&quot;style11&quot;&gt;&lt;img src=&quot;images/screenshots/screenshot_tutorial.png&quot; width=&quot;1029&quot; height=&quot;1161&quot;&gt;&lt;/p&gt;
45:         &lt;p align=&quot;center&quot; class=&quot;style11&quot;&gt;&lt;img src=&quot;images/screenshots/screenshot_tutorial2.png&quot; width=&quot;959&quot; height=&quot;446&quot;&gt;&lt;/p&gt;
46:         &lt;p align=&quot;center&quot; class=&quot;style11&quot;&gt;&lt;img src=&quot;images/screenshots/screenshot_todo_linux.png&quot; width=&quot;1145&quot; height=&quot;757&quot;&gt;        &lt;/p&gt;
47:         &lt;p align=&quot;center&quot; class=&quot;style11&quot;&gt;&lt;img src=&quot;images/screenshots/screenshot_todo_mac.png&quot; width=&quot;831&quot; height=&quot;687&quot;&gt;        &lt;/p&gt;
48: &lt;/div&gt;&lt;b class=&quot;rbottom&quot;&gt;&lt;b class=&quot;r4&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r3&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r2&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r1&quot;&gt;&lt;/b&gt;&lt;/b&gt;&lt;/div&gt;
49: &lt;/body&gt;
50: &lt;/html&gt;</file><file path="TS/docs/script_reference_update.bat">1: rem NOTE: this uses the Release mode executable!
2: ..\TreeSheets.exe -d
3: del script_reference.html
4: move ..\scripts\builtin_functions_reference.html script_reference.html
5: pause</file><file path="TS/docs/script_reference.html">  1: &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2 Final//EN&quot;&gt;
  2: &lt;html&gt;
  3: &lt;head&gt;
  4: &lt;title&gt;lobster builtin function reference&lt;/title&gt;
  5: &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
  6: &lt;style type=&quot;text/css&quot;&gt;table.a, tr.a, td.a {font-size: 10pt;border: 1pt solid #DDDDDD; border-Collapse: collapse; max-width: 88em}&lt;/style&gt;
  7: &lt;/head&gt;
  8: &lt;body&gt;&lt;center&gt;&lt;table border=0&gt;&lt;tr&gt;&lt;td&gt;
  9: &lt;p&gt;lobster builtin functions:(file auto generated by compiler, do not modify)&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr class=&quot;a&quot; valign=top&gt;&lt;td&gt;&lt;h3&gt;treesheets&lt;/h3&gt;&lt;/td&gt;&lt;/tr&gt;
 10: &lt;tr&gt;&lt;td&gt;&lt;table class=&quot;a&quot; border=1 cellspacing=0 cellpadding=4&gt;&lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.goto_root&lt;/b&gt;()&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;makes the root of the document the current cell. this is the default at the start of any script, so this function is only needed to return there.&lt;/td&gt;
 11: &lt;/tr&gt;
 12: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.goto_view&lt;/b&gt;()&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;makes what the user has zoomed into the current cell&lt;/td&gt;
 13: &lt;/tr&gt;
 14: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.has_selection&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;whether there is a selection&lt;/td&gt;
 15: &lt;/tr&gt;
 16: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.goto_selection&lt;/b&gt;()&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;makes the current cell the one selected, or the first of a selection&lt;/td&gt;
 17: &lt;/tr&gt;
 18: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.has_parent&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;whether the current cell has a parent (is the root cell)&lt;/td&gt;
 19: &lt;/tr&gt;
 20: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.goto_parent&lt;/b&gt;()&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;makes the current cell the parent of the current cell, if any&lt;/td&gt;
 21: &lt;/tr&gt;
 22: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.num_children&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns the total number of children of the current cell (rows * columns). returns 0 if this cell doesn&apos;t have a sub-grid at all.&lt;/td&gt;
 23: &lt;/tr&gt;
 24: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.num_columns_rows&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int2&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns the number of columns and rows in the current cell&lt;/td&gt;
 25: &lt;/tr&gt;
 26: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.selection&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int2&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int2&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns the (xs,ys) and (x,y) of the current selection, or zeroes if none&lt;/td&gt;
 27: &lt;/tr&gt;
 28: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.goto_child&lt;/b&gt;(n&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;makes the current cell the nth child of the current cell&lt;/td&gt;
 29: &lt;/tr&gt;
 30: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.goto_column_row&lt;/b&gt;(col&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, row&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;makes the current cell the child at col / row&lt;/td&gt;
 31: &lt;/tr&gt;
 32: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.get_text&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;gets the text of the current cell.&lt;/td&gt;
 33: &lt;/tr&gt;
 34: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.set_text&lt;/b&gt;(text&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;sets the text of the current cell&lt;/td&gt;
 35: &lt;/tr&gt;
 36: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.create_grid&lt;/b&gt;(cols&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, rows&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;creates a grid in the current cell if there is not one yet&lt;/td&gt;
 37: &lt;/tr&gt;
 38: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.insert_column&lt;/b&gt;(c&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;inserts a column before column c in an existing grid&lt;/td&gt;
 39: &lt;/tr&gt;
 40: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.insert_row&lt;/b&gt;(r&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;inserts a row before row r in an existing grid&lt;/td&gt;
 41: &lt;/tr&gt;
 42: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.delete&lt;/b&gt;(position&lt;font color=&quot;#666666&quot;&gt;: int2&lt;/font&gt;, size&lt;font color=&quot;#666666&quot;&gt;: int2&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;clears the cells denoted by position/size. also removes columns/rows if they become completely empty, or the entire grid.&lt;/td&gt;
 43: &lt;/tr&gt;
 44: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.set_background_color&lt;/b&gt;(color&lt;font color=&quot;#666666&quot;&gt;: float4&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;sets the background color of the current cell&lt;/td&gt;
 45: &lt;/tr&gt;
 46: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.set_text_color&lt;/b&gt;(color&lt;font color=&quot;#666666&quot;&gt;: float4&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;sets the text color of the current cell&lt;/td&gt;
 47: &lt;/tr&gt;
 48: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.set_text_filtered&lt;/b&gt;(filtered&lt;font color=&quot;#666666&quot;&gt;: bool&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;sets the text filtered of the current cell&lt;/td&gt;
 49: &lt;/tr&gt;
 50: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.is_text_filtered&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;whether the text of the current cell is filtered&lt;/td&gt;
 51: &lt;/tr&gt;
 52: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.set_border_color&lt;/b&gt;(color&lt;font color=&quot;#666666&quot;&gt;: float4&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;sets the border color of the current grid&lt;/td&gt;
 53: &lt;/tr&gt;
 54: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.get_relative_size&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns the relative text size of the current cell&lt;/td&gt;
 55: &lt;/tr&gt;
 56: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.set_relative_size&lt;/b&gt;(size&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;sets the relative size (0 is normal, -1 is smaller etc.) of the current cell&lt;/td&gt;
 57: &lt;/tr&gt;
 58: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.set_style_bits&lt;/b&gt;(stylebits&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;sets one or more styles (bold = 1, italic = 2, fixed = 4, underline = 8, strikethru = 16) on the current cell&lt;/td&gt;
 59: &lt;/tr&gt;
 60: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.get_style_bits&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns the stylebits of the current cell&lt;/td&gt;
 61: &lt;/tr&gt;
 62: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.set_status_message&lt;/b&gt;(message&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;sets the status message in TreeSheets&lt;/td&gt;
 63: &lt;/tr&gt;
 64: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.get_filename_from_user&lt;/b&gt;(is_save&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;gets a filename using a file dialog. empty string if cancelled.&lt;/td&gt;
 65: &lt;/tr&gt;
 66: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.get_filename&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;gets the current documents file name&lt;/td&gt;
 67: &lt;/tr&gt;
 68: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.load_document&lt;/b&gt;(filename&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;loads a document, and makes it the active one. returns false if failed.&lt;/td&gt;
 69: &lt;/tr&gt;
 70: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.set_window_size&lt;/b&gt;(width&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, height&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;resizes the window&lt;/td&gt;
 71: &lt;/tr&gt;
 72: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.get_last_edit&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;gets the timestamp of the last edit in milliseconds since the Unix/C epoch&lt;/td&gt;
 73: &lt;/tr&gt;
 74: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.get_current_time&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;gets the current timestamp in milliseconds since the Unix/C epoch&lt;/td&gt;
 75: &lt;/tr&gt;
 76: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.is_tag&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;whether the current cell text is a tag&lt;/td&gt;
 77: &lt;/tr&gt;
 78: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.get_column_width&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;get the column width of the current cell&lt;/td&gt;
 79: &lt;/tr&gt;
 80: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ts.set_column_width&lt;/b&gt;(width&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;set the column width of the current cell&lt;/td&gt;
 81: &lt;/tr&gt;
 82: &lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;
 83: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td&gt;&lt;h3&gt;builtin&lt;/h3&gt;&lt;/td&gt;&lt;/tr&gt;
 84: &lt;tr&gt;&lt;td&gt;&lt;table class=&quot;a&quot; border=1 cellspacing=0 cellpadding=4&gt;&lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;print&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;output any value to the console (with linefeed).&lt;/td&gt;
 85: &lt;/tr&gt;
 86: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;string&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;convert any value to string&lt;/td&gt;
 87: &lt;/tr&gt;
 88: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;set_print_depth&lt;/b&gt;(depth&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;for printing / string conversion: sets max vectors/objects recursion depth (default 10), returns old value&lt;/td&gt;
 89: &lt;/tr&gt;
 90: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;set_print_length&lt;/b&gt;(len&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;for printing / string conversion: sets max string length (default 100000), returns old value&lt;/td&gt;
 91: &lt;/tr&gt;
 92: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;set_print_quoted&lt;/b&gt;(quoted&lt;font color=&quot;#666666&quot;&gt;: bool&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;for printing / string conversion: if the top level value is a string, whether to convert it with escape codes and quotes (default false), returns old value&lt;/td&gt;
 93: &lt;/tr&gt;
 94: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;set_print_decimals&lt;/b&gt;(decimals&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;for printing / string conversion: number of decimals for any floating point output (default -1, meaning all), returns old value&lt;/td&gt;
 95: &lt;/tr&gt;
 96: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;set_print_indent&lt;/b&gt;(spaces&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;for printing / string conversion: number of spaces to indent with. default is 0: no indent / no multi-line, returns old value&lt;/td&gt;
 97: &lt;/tr&gt;
 98: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;get_line&lt;/b&gt;(prefix&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;reads a string from the console if possible (followed by enter). Prefix will be printed before the input&lt;/td&gt;
 99: &lt;/tr&gt;
100: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;append&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, ys&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[any]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;creates a new vector by appending all elements of 2 input vectors&lt;/td&gt;
101: &lt;/tr&gt;
102: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;append_into&lt;/b&gt;(dest&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, src&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[any]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;appends all elements of the second vector into the first&lt;/td&gt;
103: &lt;/tr&gt;
104: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;vector_capacity&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, len&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[any]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;ensures the vector capacity (number of elements it can contain before re-allocating) is at least &quot;len&quot;. Does not actually add (or remove) elements. This function is just for efficiency in the case the amount of &quot;push&quot; operations is known. returns original vector.&lt;/td&gt;
105: &lt;/tr&gt;
106: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;length&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;length of int (identity function, useful in combination with string/vector version)&lt;/td&gt;
107: &lt;/tr&gt;
108: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;length&lt;/b&gt;(s&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;length of string&lt;/td&gt;
109: &lt;/tr&gt;
110: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;length&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;length of vector&lt;/td&gt;
111: &lt;/tr&gt;
112: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;equal&lt;/b&gt;(a&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;, b&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;structural equality between any two values (recurses into vectors/objects, unlike == which is only true for vectors/objects if they are the same object)&lt;/td&gt;
113: &lt;/tr&gt;
114: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;push&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, x&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[any]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;appends one element to a vector, returns existing vector&lt;/td&gt;
115: &lt;/tr&gt;
116: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;pop&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;any&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;removes last element from vector and returns it&lt;/td&gt;
117: &lt;/tr&gt;
118: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;top&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;any&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns last element from vector&lt;/td&gt;
119: &lt;/tr&gt;
120: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;insert&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, x&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[any]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;inserts a value into a vector at index i, existing elements shift upward, returns original vector&lt;/td&gt;
121: &lt;/tr&gt;
122: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;remove&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;any&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;remove element at index i, following elements shift down. returns the element removed.&lt;/td&gt;
123: &lt;/tr&gt;
124: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;remove_range&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, n&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;remove n elements at index i, following elements shift down.&lt;/td&gt;
125: &lt;/tr&gt;
126: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;remove_obj&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, obj&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;any&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;remove all elements equal to obj (==), returns obj.&lt;/td&gt;
127: &lt;/tr&gt;
128: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;truncate&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;removes all elements starting from index i, does nothing if i &amp;gt;= len&lt;/td&gt;
129: &lt;/tr&gt;
130: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;binary_search&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [int]&lt;/font&gt;, key&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;does a binary search for key in a sorted vector, returns as first return value how many matches were found, and as second the index in the array where the matches start (so you can read them, overwrite them, or remove them), or if none found, where the key could be inserted such that the vector stays sorted. This overload is for int vectors and keys.&lt;/td&gt;
131: &lt;/tr&gt;
132: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;binary_search&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [float]&lt;/font&gt;, key&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;float version.&lt;/td&gt;
133: &lt;/tr&gt;
134: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;binary_search&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [string]&lt;/font&gt;, key&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;string version.&lt;/td&gt;
135: &lt;/tr&gt;
136: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;binary_search_object&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, key&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;object version. compares by reference rather than contents.&lt;/td&gt;
137: &lt;/tr&gt;
138: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;binary_search_first_field_string&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, key&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;object version where key is the first field (must be string, runtime error if it is not)&lt;/td&gt;
139: &lt;/tr&gt;
140: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;binary_search_first_field_object&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, key&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;object version where key is the first field (must be object, runtime error if it is not)&lt;/td&gt;
141: &lt;/tr&gt;
142: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;copy&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;any&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;makes a shallow copy of any object/vector/string.&lt;/td&gt;
143: &lt;/tr&gt;
144: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;deepcopy&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;, depth&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;any&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;makes a deep copy of any object/vector/string. DAGs become trees, and cycles will clone until it reach the given depth. depth == 1 would do the same as copy.&lt;/td&gt;
145: &lt;/tr&gt;
146: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;slice&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, start&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, size&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[any]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns a sub-vector of size elements from index start. size can be negative to indicate the rest of the vector.&lt;/td&gt;
147: &lt;/tr&gt;
148: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;any&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns whether any elements of the vector are true values&lt;/td&gt;
149: &lt;/tr&gt;
150: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;any&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns whether any elements of the numeric struct are true values&lt;/td&gt;
151: &lt;/tr&gt;
152: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;all&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns whether all elements of the vector are true values&lt;/td&gt;
153: &lt;/tr&gt;
154: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;all&lt;/b&gt;(xs&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns whether all elements of the numeric struct are true values&lt;/td&gt;
155: &lt;/tr&gt;
156: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;substring&lt;/b&gt;(s&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, start&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, size&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns a substring of size characters from index start. size can be negative to indicate the rest of the string.&lt;/td&gt;
157: &lt;/tr&gt;
158: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;find_string&lt;/b&gt;(s&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, substr&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, offset&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt; = 0) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;finds the index at which substr first appears, or -1 if none. optionally start at a position other than 0&lt;/td&gt;
159: &lt;/tr&gt;
160: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;find_string_reverse&lt;/b&gt;(s&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, substr&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, offset&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt; = 0) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;finds the index at which substr first appears when searching from the end, or -1 if none. optionally start at a position other than the end of the string&lt;/td&gt;
161: &lt;/tr&gt;
162: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;replace_string&lt;/b&gt;(s&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, a&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, b&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, count&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt; = 0) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns a copy of s where all occurrences of a have been replaced with b. if a is empty, no replacements are made. if count is specified, makes at most that many replacements&lt;/td&gt;
163: &lt;/tr&gt;
164: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;string_to_int&lt;/b&gt;(s&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, base&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt; = 0) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts a string to an int given the base (2..36, e.g. 16 for hex, default is 10).returns 0 if no numeric data could be parsed; second return value is true if allcharacters of the string were parsed.&lt;/td&gt;
165: &lt;/tr&gt;
166: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;string_to_float&lt;/b&gt;(s&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts a string to a float. returns 0.0 if no numeric data could be parsed;second return value is true if all characters of the string were parsed.&lt;/td&gt;
167: &lt;/tr&gt;
168: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;tokenize&lt;/b&gt;(s&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, delimiters&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, whitespace&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, dividing&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt; = 0) -&gt; &lt;font color=&quot;#666666&quot;&gt;[string]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;splits a string into a vector of strings, by splitting into segments upon each dividing or terminating delimiter. Segments are stripped of leading and trailing whitespace. Example: &quot;; A ; B C;; &quot; becomes [ &quot;&quot;, &quot;A&quot;, &quot;B C&quot;, &quot;&quot; ] with &quot;;&quot; as delimiter and &quot; &quot; as whitespace. If dividing was true, there would be a 5th empty string element.&lt;/td&gt;
169: &lt;/tr&gt;
170: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;unicode_to_string&lt;/b&gt;(us&lt;font color=&quot;#666666&quot;&gt;: [int]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts a vector of ints representing unicode values to a UTF-8 string.&lt;/td&gt;
171: &lt;/tr&gt;
172: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;string_to_unicode&lt;/b&gt;(s&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[int]&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts a UTF-8 string into a vector of unicode values. second return value is false if there was a decoding error, and the vector will only contain the characters up to the error&lt;/td&gt;
173: &lt;/tr&gt;
174: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;number_to_string&lt;/b&gt;(number&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, base&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, minchars&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts the (unsigned version) of the input integer number to a string given the base (2..36, e.g. 16 for hex) and outputting a minimum of characters (padding with 0).&lt;/td&gt;
175: &lt;/tr&gt;
176: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;lowercase&lt;/b&gt;(s&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts a UTF-8 string from any case to lower case, affecting only A-Z&lt;/td&gt;
177: &lt;/tr&gt;
178: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;uppercase&lt;/b&gt;(s&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts a UTF-8 string from any case to upper case, affecting only a-z&lt;/td&gt;
179: &lt;/tr&gt;
180: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;escape_string&lt;/b&gt;(s&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, set&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, prefix&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, postfix&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;prefixes &amp;amp; postfixes any occurrences or characters in set in string s&lt;/td&gt;
181: &lt;/tr&gt;
182: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;concat_string&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: [string]&lt;/font&gt;, sep&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;concatenates all elements of the string vector, separated with sep.&lt;/td&gt;
183: &lt;/tr&gt;
184: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;repeat_string&lt;/b&gt;(s&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, n&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns a string consisting of n copies of the input string.&lt;/td&gt;
185: &lt;/tr&gt;
186: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;pow&lt;/b&gt;(a&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, b&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;a raised to the power of b, for integers, using exponentiation by squaring&lt;/td&gt;
187: &lt;/tr&gt;
188: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;pow&lt;/b&gt;(a&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, b&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;a raised to the power of b&lt;/td&gt;
189: &lt;/tr&gt;
190: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;pow&lt;/b&gt;(a&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;, b&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;floatN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;vector elements raised to the power of b&lt;/td&gt;
191: &lt;/tr&gt;
192: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;log&lt;/b&gt;(a&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;natural logaritm of a&lt;/td&gt;
193: &lt;/tr&gt;
194: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;log2&lt;/b&gt;(a&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;base 2 logaritm of a&lt;/td&gt;
195: &lt;/tr&gt;
196: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;sqrt&lt;/b&gt;(f&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;square root&lt;/td&gt;
197: &lt;/tr&gt;
198: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ceiling&lt;/b&gt;(f&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the nearest int &amp;gt;= f&lt;/td&gt;
199: &lt;/tr&gt;
200: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ceiling&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;intN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the nearest ints &amp;gt;= each component of v&lt;/td&gt;
201: &lt;/tr&gt;
202: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;floor&lt;/b&gt;(f&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the nearest int &amp;lt;= f&lt;/td&gt;
203: &lt;/tr&gt;
204: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;floor&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;intN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the nearest ints &amp;lt;= each component of v&lt;/td&gt;
205: &lt;/tr&gt;
206: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;int&lt;/b&gt;(f&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts a float to an int by dropping the fraction&lt;/td&gt;
207: &lt;/tr&gt;
208: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;int&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;intN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts a vector of floats to ints by dropping the fraction&lt;/td&gt;
209: &lt;/tr&gt;
210: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;round&lt;/b&gt;(f&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts a float to the closest int&lt;/td&gt;
211: &lt;/tr&gt;
212: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;round&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;intN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts a vector of floats to the closest ints&lt;/td&gt;
213: &lt;/tr&gt;
214: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;fraction&lt;/b&gt;(f&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns the fractional part of a float: short for f - floor(f)&lt;/td&gt;
215: &lt;/tr&gt;
216: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;fraction&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;floatN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns the fractional part of a vector of floats&lt;/td&gt;
217: &lt;/tr&gt;
218: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;float&lt;/b&gt;(i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts an int to float&lt;/td&gt;
219: &lt;/tr&gt;
220: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;float&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;floatN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts a vector of ints to floats&lt;/td&gt;
221: &lt;/tr&gt;
222: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;sin&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the y coordinate of the normalized vector indicated by angle (in degrees)&lt;/td&gt;
223: &lt;/tr&gt;
224: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;sin&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;floatN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the y coordinates of the normalized vector indicated by the angles (in degrees)&lt;/td&gt;
225: &lt;/tr&gt;
226: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;cos&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the x coordinate of the normalized vector indicated by angle (in degrees)&lt;/td&gt;
227: &lt;/tr&gt;
228: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;cos&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;floatN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the x coordinates of the normalized vector indicated by the angles (in degrees)&lt;/td&gt;
229: &lt;/tr&gt;
230: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;tan&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the tangent of an angle (in degrees)&lt;/td&gt;
231: &lt;/tr&gt;
232: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;tan&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;floatN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the tangents of the angles (in degrees)&lt;/td&gt;
233: &lt;/tr&gt;
234: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;sincos&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float2&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the normalized vector indicated by angle (in degrees), same as float2 { cos(angle), sin(angle) }&lt;/td&gt;
235: &lt;/tr&gt;
236: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;asin&lt;/b&gt;(y&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the angle (in degrees) indicated by the y coordinate projected to the unit circle&lt;/td&gt;
237: &lt;/tr&gt;
238: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;acos&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the angle (in degrees) indicated by the x coordinate projected to the unit circle&lt;/td&gt;
239: &lt;/tr&gt;
240: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;atan&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the angle (in degrees) indicated by the y coordinate of the tangent projected to the unit circle&lt;/td&gt;
241: &lt;/tr&gt;
242: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;radians&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts an angle in degrees to radians&lt;/td&gt;
243: &lt;/tr&gt;
244: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;degrees&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts an angle in radians to degrees&lt;/td&gt;
245: &lt;/tr&gt;
246: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;atan2&lt;/b&gt;(vec&lt;font color=&quot;#666666&quot;&gt;: float2&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the angle (in degrees) corresponding to a normalized 2D vector&lt;/td&gt;
247: &lt;/tr&gt;
248: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;radians&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts an angle in degrees to radians&lt;/td&gt;
249: &lt;/tr&gt;
250: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;degrees&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts an angle in radians to degrees&lt;/td&gt;
251: &lt;/tr&gt;
252: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;normalize&lt;/b&gt;(vec&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;floatN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns a vector of unit length&lt;/td&gt;
253: &lt;/tr&gt;
254: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;dot&lt;/b&gt;(a&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;, b&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the length of vector a when projected onto b (or vice versa)&lt;/td&gt;
255: &lt;/tr&gt;
256: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;magnitude&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the geometric length of a vector&lt;/td&gt;
257: &lt;/tr&gt;
258: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;magnitude_squared&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the geometric length of a vector squared&lt;/td&gt;
259: &lt;/tr&gt;
260: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;magnitude_squared&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the geometric length of a vector squared&lt;/td&gt;
261: &lt;/tr&gt;
262: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;manhattan&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the manhattan distance of a vector&lt;/td&gt;
263: &lt;/tr&gt;
264: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;cross&lt;/b&gt;(a&lt;font color=&quot;#666666&quot;&gt;: float3&lt;/font&gt;, b&lt;font color=&quot;#666666&quot;&gt;: float3&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float3&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;a perpendicular vector to the 2D plane defined by a and b (swap a and b for its inverse)&lt;/td&gt;
265: &lt;/tr&gt;
266: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;volume&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the volume of the area spanned by the vector&lt;/td&gt;
267: &lt;/tr&gt;
268: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;volume&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;the volume of the area spanned by the vector&lt;/td&gt;
269: &lt;/tr&gt;
270: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;rnd&lt;/b&gt;(max&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;a random value [0..max).&lt;/td&gt;
271: &lt;/tr&gt;
272: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;rnd&lt;/b&gt;(max&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;intN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;a random vector within the range of an input vector.&lt;/td&gt;
273: &lt;/tr&gt;
274: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;rnd_float&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;a random float [0..1)&lt;/td&gt;
275: &lt;/tr&gt;
276: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;rnd_gaussian&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;a random float in a gaussian distribution with mean 0 and stddev 1&lt;/td&gt;
277: &lt;/tr&gt;
278: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;rnd_seed&lt;/b&gt;(seed&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;explicitly set a random seed for reproducable randomness&lt;/td&gt;
279: &lt;/tr&gt;
280: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;rnd_select&lt;/b&gt;(index&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;select a different random number generator to be active. default is 0, max is 1000000&lt;/td&gt;
281: &lt;/tr&gt;
282: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;rndm&lt;/b&gt;(max&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;deprecated: old mersenne twister version of the above for backwards compat.&lt;/td&gt;
283: &lt;/tr&gt;
284: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;rndm_seed&lt;/b&gt;(seed&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;deprecated: old mersenne twister version of the above for backwards compat.&lt;/td&gt;
285: &lt;/tr&gt;
286: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;div&lt;/b&gt;(a&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, b&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;forces two ints to be divided as floats&lt;/td&gt;
287: &lt;/tr&gt;
288: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;clamp&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, min&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, max&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;forces an integer to be in the range between min and max (inclusive)&lt;/td&gt;
289: &lt;/tr&gt;
290: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;clamp&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, min&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, max&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;forces a float to be in the range between min and max (inclusive)&lt;/td&gt;
291: &lt;/tr&gt;
292: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;clamp&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;, min&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;, max&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;intN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;forces an integer vector to be in the range between min and max (inclusive)&lt;/td&gt;
293: &lt;/tr&gt;
294: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;clamp&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;, min&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;, max&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;floatN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;forces a float vector to be in the range between min and max (inclusive)&lt;/td&gt;
295: &lt;/tr&gt;
296: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;in_range&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, range&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, bias&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt; = 0) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;checks if an integer is &amp;gt;= bias and &amp;lt; bias + range. Bias defaults to 0.&lt;/td&gt;
297: &lt;/tr&gt;
298: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;in_range&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, range&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, bias&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt; = 0.000000) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;checks if a float is &amp;gt;= bias and &amp;lt; bias + range. Bias defaults to 0.&lt;/td&gt;
299: &lt;/tr&gt;
300: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;in_range&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: int2&lt;/font&gt;, range&lt;font color=&quot;#666666&quot;&gt;: int2&lt;/font&gt;, bias&lt;font color=&quot;#666666&quot;&gt;: int2&lt;/font&gt; = nil) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;checks if a 2d integer vector is &amp;gt;= bias and &amp;lt; bias + range. Bias defaults to 0.&lt;/td&gt;
301: &lt;/tr&gt;
302: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;in_range&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: int3&lt;/font&gt;, range&lt;font color=&quot;#666666&quot;&gt;: int3&lt;/font&gt;, bias&lt;font color=&quot;#666666&quot;&gt;: int3&lt;/font&gt; = nil) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;checks if a 3d integer vector is &amp;gt;= bias and &amp;lt; bias + range. Bias defaults to 0.&lt;/td&gt;
303: &lt;/tr&gt;
304: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;in_range&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float2&lt;/font&gt;, range&lt;font color=&quot;#666666&quot;&gt;: float2&lt;/font&gt;, bias&lt;font color=&quot;#666666&quot;&gt;: float2&lt;/font&gt; = nil) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;checks if a 2d float vector is &amp;gt;= bias and &amp;lt; bias + range. Bias defaults to 0.&lt;/td&gt;
305: &lt;/tr&gt;
306: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;in_range&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float3&lt;/font&gt;, range&lt;font color=&quot;#666666&quot;&gt;: float3&lt;/font&gt;, bias&lt;font color=&quot;#666666&quot;&gt;: float3&lt;/font&gt; = nil) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;checks if a 2d float vector is &amp;gt;= bias and &amp;lt; bias + range. Bias defaults to 0.&lt;/td&gt;
307: &lt;/tr&gt;
308: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;abs&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;absolute value of an integer&lt;/td&gt;
309: &lt;/tr&gt;
310: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;abs&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;absolute value of a float&lt;/td&gt;
311: &lt;/tr&gt;
312: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;abs&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;intN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;absolute value of an int vector&lt;/td&gt;
313: &lt;/tr&gt;
314: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;abs&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;floatN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;absolute value of a float vector&lt;/td&gt;
315: &lt;/tr&gt;
316: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;sign&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;sign (-1, 0, 1) of an integer&lt;/td&gt;
317: &lt;/tr&gt;
318: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;sign&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;sign (-1, 0, 1) of a float&lt;/td&gt;
319: &lt;/tr&gt;
320: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;sign&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;intN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;signs of an int vector&lt;/td&gt;
321: &lt;/tr&gt;
322: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;sign&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;intN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;signs of a float vector&lt;/td&gt;
323: &lt;/tr&gt;
324: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;min&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, y&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;smallest of 2 integers.&lt;/td&gt;
325: &lt;/tr&gt;
326: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;min&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, y&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;smallest of 2 floats.&lt;/td&gt;
327: &lt;/tr&gt;
328: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;min&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;, y&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;intN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;smallest components of 2 int vectors&lt;/td&gt;
329: &lt;/tr&gt;
330: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;min&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;, y&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;floatN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;smallest components of 2 float vectors&lt;/td&gt;
331: &lt;/tr&gt;
332: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;min&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;smallest component of a int vector.&lt;/td&gt;
333: &lt;/tr&gt;
334: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;min&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;smallest component of a float vector.&lt;/td&gt;
335: &lt;/tr&gt;
336: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;min&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: [int]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;smallest component of a int vector, or INT_MAX if length 0.&lt;/td&gt;
337: &lt;/tr&gt;
338: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;min&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: [float]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;smallest component of a float vector, or FLT_MAX if length 0.&lt;/td&gt;
339: &lt;/tr&gt;
340: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;max&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, y&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;largest of 2 integers.&lt;/td&gt;
341: &lt;/tr&gt;
342: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;max&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, y&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;largest of 2 floats.&lt;/td&gt;
343: &lt;/tr&gt;
344: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;max&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;, y&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;intN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;largest components of 2 int vectors&lt;/td&gt;
345: &lt;/tr&gt;
346: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;max&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;, y&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;floatN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;largest components of 2 float vectors&lt;/td&gt;
347: &lt;/tr&gt;
348: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;max&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;largest component of a int vector.&lt;/td&gt;
349: &lt;/tr&gt;
350: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;max&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;largest component of a float vector.&lt;/td&gt;
351: &lt;/tr&gt;
352: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;max&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: [int]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;largest component of a int vector, or INT_MIN if length 0.&lt;/td&gt;
353: &lt;/tr&gt;
354: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;max&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: [float]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;largest component of a float vector, or FLT_MIN if length 0.&lt;/td&gt;
355: &lt;/tr&gt;
356: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;popcount&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;number of bits set in an integer&lt;/td&gt;
357: &lt;/tr&gt;
358: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;lerp&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, y&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, f&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;linearly interpolates between x and y with factor f [0..1]&lt;/td&gt;
359: &lt;/tr&gt;
360: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;lerp&lt;/b&gt;(a&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;, b&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;, f&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;floatN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;linearly interpolates between a and b vectors with factor f [0..1]&lt;/td&gt;
361: &lt;/tr&gt;
362: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;spherical_lerp&lt;/b&gt;(a&lt;font color=&quot;#666666&quot;&gt;: float4&lt;/font&gt;, b&lt;font color=&quot;#666666&quot;&gt;: float4&lt;/font&gt;, f&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float4&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;spherically interpolates between a and b quaternions with factor f [0..1]&lt;/td&gt;
363: &lt;/tr&gt;
364: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;smoothmin&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, y&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, k&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;k is the influence range&lt;/td&gt;
365: &lt;/tr&gt;
366: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;smoothstep&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;input must be in range 0..1, https://en.wikipedia.org/wiki/Smoothstep&lt;/td&gt;
367: &lt;/tr&gt;
368: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;smoothstep&lt;/b&gt;(a&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, b&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, f&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;hermite interpolation between a and b by f [0..1], https://registry.khronos.org/OpenGL-Refpages/gl4/html/smoothstep.xhtml&lt;/td&gt;
369: &lt;/tr&gt;
370: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;smootherstep&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;input must be in range 0..1, https://en.wikipedia.org/wiki/Smoothstep&lt;/td&gt;
371: &lt;/tr&gt;
372: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;cardinal_spline&lt;/b&gt;(z&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;, a&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;, b&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;, c&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;, f&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, tension&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;floatN&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;computes the position between a and b with factor f [0..1], using z (before a) and c (after b) to form a cardinal spline (tension at 0.5 is a good default)&lt;/td&gt;
373: &lt;/tr&gt;
374: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;line_intersect&lt;/b&gt;(line1a&lt;font color=&quot;#666666&quot;&gt;: float2&lt;/font&gt;, line1b&lt;font color=&quot;#666666&quot;&gt;: float2&lt;/font&gt;, line2a&lt;font color=&quot;#666666&quot;&gt;: float2&lt;/font&gt;, line2b&lt;font color=&quot;#666666&quot;&gt;: float2&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;float2&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;computes if there is an intersection point between 2 line segments, with the point as second return value&lt;/td&gt;
375: &lt;/tr&gt;
376: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;circles_within_range&lt;/b&gt;(dist&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;, positions&lt;font color=&quot;#666666&quot;&gt;: [float2]&lt;/font&gt;, radiuses&lt;font color=&quot;#666666&quot;&gt;: [float]&lt;/font&gt;, positions2&lt;font color=&quot;#666666&quot;&gt;: [float2]&lt;/font&gt;, radiuses2&lt;font color=&quot;#666666&quot;&gt;: [float]&lt;/font&gt;, gridsize&lt;font color=&quot;#666666&quot;&gt;: int2&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[[int]]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;Given a vector of 2D positions (and same size vectors of radiuses), returns a vector of vectors of indices (to the second set of positions and radiuses) of the circles that are within dist of eachothers radius. If the second set are [], the first set is used for both (and the self element is excluded). gridsize optionally specifies the size of the grid to use for accellerated lookup of nearby points. This is essential for the algorithm to be fast, too big or too small can cause slowdown. Omit it, and a heuristic will be chosen for you, which is currently sqrt(num_circles) * 2 along each dimension, e.g. 100 elements would use a 20x20 grid. Efficiency wise this algorithm is fastest if there is not too much variance in the radiuses of the second set and/or the second set has smaller radiuses than the first.&lt;/td&gt;
377: &lt;/tr&gt;
378: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;wave_function_collapse&lt;/b&gt;(tilemap&lt;font color=&quot;#666666&quot;&gt;: [string]&lt;/font&gt;, size&lt;font color=&quot;#666666&quot;&gt;: int2&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[string]&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns a tilemap of given size modelled after the possible shapes in the input tilemap. Tilemap should consist of chars in the 0..127 range. Second return value the number of failed neighbor matches, this should ideally be 0, but can be non-0 for larger maps. Simply call this function repeatedly until it is 0&lt;/td&gt;
379: &lt;/tr&gt;
380: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;hash&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;hashes an int value into a positive int; may be the identity function&lt;/td&gt;
381: &lt;/tr&gt;
382: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;hash&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;hashes any ref value into a positive int&lt;/td&gt;
383: &lt;/tr&gt;
384: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;hash&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: function&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;hashes a function value into a positive int&lt;/td&gt;
385: &lt;/tr&gt;
386: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;hash&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;hashes a float value into a positive int&lt;/td&gt;
387: &lt;/tr&gt;
388: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;hash&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: intN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;hashes a int vector into a positive int&lt;/td&gt;
389: &lt;/tr&gt;
390: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;hash&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: floatN&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;hashes a float vector into a positive int&lt;/td&gt;
391: &lt;/tr&gt;
392: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;call_function_value&lt;/b&gt;(x&lt;font color=&quot;#666666&quot;&gt;: function&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;calls a void / no args function value.. you shouldn&apos;t need to use this, it is a demonstration of how native code can call back into Lobster&lt;/td&gt;
393: &lt;/tr&gt;
394: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;type_id&lt;/b&gt;(ref&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;int uniquely representing the type of the given reference (object/vector/string/resource). this is the same as typeof, except dynamic (accounts for subtypes of the static type). useful to compare the types of objects quickly. specializations of a generic type will result in different ids.&lt;/td&gt;
395: &lt;/tr&gt;
396: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;type_string&lt;/b&gt;(ref&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;string representing the type of the given reference (object/vector/string/resource)&lt;/td&gt;
397: &lt;/tr&gt;
398: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;type_element_string&lt;/b&gt;(v&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;string representing the type of the elements of a vector&lt;/td&gt;
399: &lt;/tr&gt;
400: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;type_field_count&lt;/b&gt;(obj&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;number of fields in an object, or 0 for other reference types&lt;/td&gt;
401: &lt;/tr&gt;
402: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;type_field_string&lt;/b&gt;(obj&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;, idx&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;string representing the type of a field in an object, or empty for other reference types&lt;/td&gt;
403: &lt;/tr&gt;
404: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;type_field_name&lt;/b&gt;(obj&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;, idx&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;name of a field in an object, or empty for other reference types&lt;/td&gt;
405: &lt;/tr&gt;
406: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;type_field_value&lt;/b&gt;(obj&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;, idx&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;string representing the value of a field in an object, or empty for other reference types&lt;/td&gt;
407: &lt;/tr&gt;
408: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;type_enum_value_name&lt;/b&gt;(enum_type_id&lt;font color=&quot;#666666&quot;&gt;: typeid(any)&lt;/font&gt;, idx&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;string representing the name of an enum value, belonging to the enum (use typeof)&lt;/td&gt;
409: &lt;/tr&gt;
410: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;program_name&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns the name of the main program (e.g. &quot;foo.lobster&quot;), &quot;&quot; if running from lpak.&lt;/td&gt;
411: &lt;/tr&gt;
412: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;vm_compiled_mode&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns if the VM is running in compiled mode (Lobster -&amp;gt; C++), or false for JIT.&lt;/td&gt;
413: &lt;/tr&gt;
414: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;seconds_elapsed&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;seconds since program start as a float, unlike gl.time() it is calculated every time it is called&lt;/td&gt;
415: &lt;/tr&gt;
416: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;date_time&lt;/b&gt;(utc&lt;font color=&quot;#666666&quot;&gt;: bool&lt;/font&gt; = false) -&gt; &lt;font color=&quot;#666666&quot;&gt;[int]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;a vector of integers representing date &amp;amp; time information (index with date_time.lobster). By default returns local time, pass true for UTC instead.&lt;/td&gt;
417: &lt;/tr&gt;
418: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;date_time_string&lt;/b&gt;(utc&lt;font color=&quot;#666666&quot;&gt;: bool&lt;/font&gt; = false) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;a string representing date &amp;amp; time information in the format: &apos;Www Mmm dd hh:mm:ss yyyy&apos;. By default returns local time, pass true for UTC instead.&lt;/td&gt;
419: &lt;/tr&gt;
420: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;date_time_string_format&lt;/b&gt;(format&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, utc&lt;font color=&quot;#666666&quot;&gt;: bool&lt;/font&gt; = false) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;a string representing date &amp;amp; time information using a formatting string according to https://en.cppreference.com/w/cpp/chrono/c/strftime, for example &quot;%Y_%m_%d_%H_%M_%S&quot;. By default returns local time, pass true for UTC instead.&lt;/td&gt;
421: &lt;/tr&gt;
422: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;date_time_build_info&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;a string representing information from when this program was compiled.&lt;/td&gt;
423: &lt;/tr&gt;
424: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;get_stack_trace&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;gets a stack trace of the current location of the program (needs --runtime-stack-trace) without actually stopping the program.&lt;/td&gt;
425: &lt;/tr&gt;
426: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;get_memory_usage&lt;/b&gt;(n&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;gets a text showing the top n object types that are using the most memory.&lt;/td&gt;
427: &lt;/tr&gt;
428: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;pass&lt;/b&gt;()&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;does nothing. useful for empty bodies of control structures.&lt;/td&gt;
429: &lt;/tr&gt;
430: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;reference_count&lt;/b&gt;(val&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;get the reference count of any value. for compiler debugging, mostly&lt;/td&gt;
431: &lt;/tr&gt;
432: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;set_console&lt;/b&gt;(on&lt;font color=&quot;#666666&quot;&gt;: bool&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;lets you turn on/off the console window (on Windows)&lt;/td&gt;
433: &lt;/tr&gt;
434: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;set_output_level&lt;/b&gt;(level&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;0 = debug, 1 = verbose, 2 = warn (default), 3 = error, 4 = program&lt;/td&gt;
435: &lt;/tr&gt;
436: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;set_exit_code&lt;/b&gt;(code&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;this will be returned when run as a console application&lt;/td&gt;
437: &lt;/tr&gt;
438: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;command_line_arguments&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;[string]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;&lt;/td&gt;
439: &lt;/tr&gt;
440: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;thread_information&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns the number of hardware threads, and the number of cores&lt;/td&gt;
441: &lt;/tr&gt;
442: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;is_worker_thread&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;whether the current thread is a worker thread&lt;/td&gt;
443: &lt;/tr&gt;
444: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;start_worker_threads&lt;/b&gt;(numthreads&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;launch worker threads&lt;/td&gt;
445: &lt;/tr&gt;
446: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;stop_worker_threads&lt;/b&gt;()&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;only needs to be called if you want to stop the worker threads before the end of the program, or if you want to call start_worker_threads again. workers_alive will become false inside the workers, which should then exit.&lt;/td&gt;
447: &lt;/tr&gt;
448: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;workers_alive&lt;/b&gt;() -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;whether workers should continue doing work. returns false after stop_worker_threads() has been called.&lt;/td&gt;
449: &lt;/tr&gt;
450: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;thread_write&lt;/b&gt;(object&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;put this object in the thread queue&lt;/td&gt;
451: &lt;/tr&gt;
452: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;thread_read&lt;/b&gt;(type&lt;font color=&quot;#666666&quot;&gt;: typeid(any)&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;any?&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;get an object from the thread queue. pass the typeof object. blocks if no such objects available. returns object, or nil if this was the result of thread_wake() or stop_worker_threads() was called&lt;/td&gt;
453: &lt;/tr&gt;
454: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;thread_check&lt;/b&gt;(type&lt;font color=&quot;#666666&quot;&gt;: typeid(any)&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;any?&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;tests if an object is available on the thread queue. pass the typeof object. returns object, or nil if none available, or if stop_worker_threads() was called&lt;/td&gt;
455: &lt;/tr&gt;
456: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;thread_wake&lt;/b&gt;(type&lt;font color=&quot;#666666&quot;&gt;: typeid(any)&lt;/font&gt;)&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;wakes up one thread that are currently blocked on a thread_read for this type. this will cause them to return nil since no object is sent. it is similar to thread_write(nil)&lt;/td&gt;
457: &lt;/tr&gt;
458: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;crash_test_cpp_nullptr_exception&lt;/b&gt;()&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;only for testing crash dump functionality, don&apos;t use! :)&lt;/td&gt;
459: &lt;/tr&gt;
460: &lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;
461: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td&gt;&lt;h3&gt;compiler&lt;/h3&gt;&lt;/td&gt;&lt;/tr&gt;
462: &lt;tr&gt;&lt;td&gt;&lt;table class=&quot;a&quot; border=1 cellspacing=0 cellpadding=4&gt;&lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;compile_run_code&lt;/b&gt;(code&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, args&lt;font color=&quot;#666666&quot;&gt;: [string]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;string?&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;compiles and runs lobster source, sandboxed from the current program (in its own VM). the argument is a string of code. returns the return value of the program as a string, with an error string as second return value, or nil if none. using parse_data(), two program can communicate more complex data structures even if they don&apos;t have the same version of struct definitions.&lt;/td&gt;
463: &lt;/tr&gt;
464: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;compile_run_file&lt;/b&gt;(filename&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, args&lt;font color=&quot;#666666&quot;&gt;: [string]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;string?&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;same as compile_run_code(), only now you pass a filename.&lt;/td&gt;
465: &lt;/tr&gt;
466: &lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;
467: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td&gt;&lt;h3&gt;file&lt;/h3&gt;&lt;/td&gt;&lt;/tr&gt;
468: &lt;tr&gt;&lt;td&gt;&lt;table class=&quot;a&quot; border=1 cellspacing=0 cellpadding=4&gt;&lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;format_time&lt;/b&gt;(format&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, time&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, localtime&lt;font color=&quot;#666666&quot;&gt;: bool&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;convert a time in seconds since 00:00:00 UTC, Thursday, 1 January 1970 into a string, using the same format string syntax as POSIX strftime. If localtime is true, then the time will be displayed using the local timezone, otherwise it will use UTC. Returns an empty string on error.&lt;/td&gt;
469: &lt;/tr&gt;
470: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;scan_folder&lt;/b&gt;(folder&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, rel&lt;font color=&quot;#666666&quot;&gt;: bool&lt;/font&gt; = false) -&gt; &lt;font color=&quot;#666666&quot;&gt;[string]?&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;[int]?&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;[int]?&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns three vectors representing all elements in a folder, the first vector containing all names, the second vector containing sizes in bytes (or -1 if a directory), and the third as the number of seconds since 00:00:00 UTC, Thursday, 1 January 1970, not including leap seconds. set rel use a relative path, default is absolute. Returns nil if folder couldn&apos;t be scanned.&lt;/td&gt;
471: &lt;/tr&gt;
472: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_file&lt;/b&gt;(file&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, textmode&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt; = 0) -&gt; &lt;font color=&quot;#666666&quot;&gt;string?&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns the contents of a file as a string, or nil if the file can&apos;t be found. you may use either \ or / as path separators&lt;/td&gt;
473: &lt;/tr&gt;
474: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_file&lt;/b&gt;(file&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, contents&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, textmode&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt; = 0, absolute_path&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt; = 0) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;creates a file with the contents of a string, returns false if writing wasn&apos;t possible&lt;/td&gt;
475: &lt;/tr&gt;
476: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;rename_file&lt;/b&gt;(old_file&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, new_file&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;renames a file, returns false if it wasn&apos;t possible&lt;/td&gt;
477: &lt;/tr&gt;
478: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;delete_file&lt;/b&gt;(file&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;deletes a file, returns false if it wasn&apos;t possible. Will search in all import dirs.&lt;/td&gt;
479: &lt;/tr&gt;
480: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;exists_file&lt;/b&gt;(file&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;checks whether a file exists.&lt;/td&gt;
481: &lt;/tr&gt;
482: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;launch_subprocess&lt;/b&gt;(commandline&lt;font color=&quot;#666666&quot;&gt;: [string]&lt;/font&gt;, stdin&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt; = nil) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;launches a sub process, with optionally a stdin for the process, and returns its return code (or -1 if it couldn&apos;t launch at all), and any output&lt;/td&gt;
483: &lt;/tr&gt;
484: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;vector_to_buffer&lt;/b&gt;(vec&lt;font color=&quot;#666666&quot;&gt;: [any]&lt;/font&gt;, width&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt; = 4) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;converts a vector of ints/floats (or structs of them) to a buffer, where each scalar is written with &quot;width&quot; bytes (1/2/4/8, default 4). Returns nil if the type couldn&apos;t be converted. Uses native endianness.&lt;/td&gt;
485: &lt;/tr&gt;
486: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;ensure_size&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, size&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, char&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, extra&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt; = 0) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;ensures a string is at least size characters. if it is, just returns the existing string, otherwise returns a new string of that size (with optionally extra bytes added), with any new characters set to char. You can specify a negative size to mean relative to the end, i.e. new characters will be added at the start. &lt;/td&gt;
487: &lt;/tr&gt;
488: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_int64_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, val&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;writes a value as little endian to a string at location i. Uses ensure_size to make the string twice as long (with extra 0 bytes) if no space. Returns new string if resized, and the index of the location right after where the value was written. The _back version writes relative to the end (and writes before the index)&lt;/td&gt;
489: &lt;/tr&gt;
490: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_int32_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, val&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see write_int64_le)&lt;/td&gt;
491: &lt;/tr&gt;
492: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_int16_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, val&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see write_int64_le)&lt;/td&gt;
493: &lt;/tr&gt;
494: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_int8_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, val&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see write_int64_le)&lt;/td&gt;
495: &lt;/tr&gt;
496: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_float64_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, val&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see write_int64_le)&lt;/td&gt;
497: &lt;/tr&gt;
498: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_float32_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, val&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see write_int64_le)&lt;/td&gt;
499: &lt;/tr&gt;
500: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_int64_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, val&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see write_int64_le)&lt;/td&gt;
501: &lt;/tr&gt;
502: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_int32_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, val&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see write_int64_le)&lt;/td&gt;
503: &lt;/tr&gt;
504: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_int16_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, val&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see write_int64_le)&lt;/td&gt;
505: &lt;/tr&gt;
506: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_int8_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, val&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see write_int64_le)&lt;/td&gt;
507: &lt;/tr&gt;
508: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_float64_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, val&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see write_int64_le)&lt;/td&gt;
509: &lt;/tr&gt;
510: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_float32_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, val&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see write_int64_le)&lt;/td&gt;
511: &lt;/tr&gt;
512: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_substring&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, substr&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, nullterm&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;writes a substring into another string at i (see also write_int64_le)&lt;/td&gt;
513: &lt;/tr&gt;
514: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;write_substring_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, substr&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, nullterm&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;&lt;/td&gt;
515: &lt;/tr&gt;
516: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;compare_substring&lt;/b&gt;(string_a&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i_a&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, string_b&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i_b&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, len&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns if the two substrings are equal (0), or a &amp;lt; b (-1) or a &amp;gt; b (1).&lt;/td&gt;
517: &lt;/tr&gt;
518: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_int64_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;reads a value as little endian from a string at location i. The value must be within bounds of the string. Returns the value, and the index of the location right after where the value was read. The _back version reads relative to the end (and reads before the index)&lt;/td&gt;
519: &lt;/tr&gt;
520: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_int32_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
521: &lt;/tr&gt;
522: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_int16_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
523: &lt;/tr&gt;
524: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_int8_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
525: &lt;/tr&gt;
526: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_uint64_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;reads a value as little endian from a string at location i. The value must be within bounds of the string. Returns the value, and the index of the location right after where the value was read. The _back version reads relative to the end (and reads before the index)&lt;/td&gt;
527: &lt;/tr&gt;
528: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_uint32_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
529: &lt;/tr&gt;
530: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_uint16_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
531: &lt;/tr&gt;
532: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_uint8_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
533: &lt;/tr&gt;
534: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_float64_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
535: &lt;/tr&gt;
536: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_float32_le&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
537: &lt;/tr&gt;
538: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_int64_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
539: &lt;/tr&gt;
540: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_int32_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
541: &lt;/tr&gt;
542: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_int16_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
543: &lt;/tr&gt;
544: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_int8_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
545: &lt;/tr&gt;
546: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_uint64_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
547: &lt;/tr&gt;
548: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_uint32_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
549: &lt;/tr&gt;
550: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_uint16_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
551: &lt;/tr&gt;
552: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_uint8_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
553: &lt;/tr&gt;
554: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_float64_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
555: &lt;/tr&gt;
556: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;read_float32_le_back&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, i&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see read_int64_le)&lt;/td&gt;
557: &lt;/tr&gt;
558: &lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;
559: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td&gt;&lt;h3&gt;flatbuffers&lt;/h3&gt;&lt;/td&gt;&lt;/tr&gt;
560: &lt;tr&gt;&lt;td&gt;&lt;table class=&quot;a&quot; border=1 cellspacing=0 cellpadding=4&gt;&lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_int64&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, def&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;reads a flatbuffers field from a string at table location tablei, field vtable offset vo, and default value def. The value must be within bounds of the string. Returns the value (or default if the field was not present)&lt;/td&gt;
561: &lt;/tr&gt;
562: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_int32&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, def&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see flatbuffers.field_int64)&lt;/td&gt;
563: &lt;/tr&gt;
564: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_int16&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, def&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see flatbuffers.field_int64)&lt;/td&gt;
565: &lt;/tr&gt;
566: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_int8&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, def&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see flatbuffers.field_int64)&lt;/td&gt;
567: &lt;/tr&gt;
568: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_uint64&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, def&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;reads a flatbuffers field from a string at table location tablei, field vtable offset vo, and default value def. The value must be within bounds of the string. Returns the value (or default if the field was not present)&lt;/td&gt;
569: &lt;/tr&gt;
570: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_uint32&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, def&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see flatbuffers.field_int64)&lt;/td&gt;
571: &lt;/tr&gt;
572: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_uint16&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, def&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see flatbuffers.field_int64)&lt;/td&gt;
573: &lt;/tr&gt;
574: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_uint8&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, def&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see flatbuffers.field_int64)&lt;/td&gt;
575: &lt;/tr&gt;
576: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_float64&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, def&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see flatbuffers.field_int64)&lt;/td&gt;
577: &lt;/tr&gt;
578: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_float32&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, def&lt;font color=&quot;#666666&quot;&gt;: float&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;float&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;(see flatbuffers.field_int64)&lt;/td&gt;
579: &lt;/tr&gt;
580: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_string&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;reads a flatbuffer string field, returns &quot;&quot; if not present&lt;/td&gt;
581: &lt;/tr&gt;
582: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_vector_len&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;reads a flatbuffer vector field length, or 0 if not present&lt;/td&gt;
583: &lt;/tr&gt;
584: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_vector&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns a flatbuffer vector field element start, or 0 if not present&lt;/td&gt;
585: &lt;/tr&gt;
586: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_table&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns a flatbuffer table field start, or 0 if not present&lt;/td&gt;
587: &lt;/tr&gt;
588: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_struct&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns a flatbuffer struct field start, or 0 if not present&lt;/td&gt;
589: &lt;/tr&gt;
590: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.field_present&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, tablei&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;, vo&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns if a flatbuffer field is present (unequal to default)&lt;/td&gt;
591: &lt;/tr&gt;
592: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.indirect&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, index&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;int&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns a flatbuffer offset at index relative to itself&lt;/td&gt;
593: &lt;/tr&gt;
594: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.string&lt;/b&gt;(string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, index&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns a flatbuffer string whose offset is at given index&lt;/td&gt;
595: &lt;/tr&gt;
596: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.binary_to_json&lt;/b&gt;(schemas&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, binary&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, includedirs&lt;font color=&quot;#666666&quot;&gt;: [string]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;string?&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns a JSON string generated from the given binary and corresponding schema.if there was an error parsing the schema, the error will be in the second returnvalue, or nil for no error&lt;/td&gt;
597: &lt;/tr&gt;
598: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flatbuffers.json_to_binary&lt;/b&gt;(schema&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, json&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, includedirs&lt;font color=&quot;#666666&quot;&gt;: [string]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;string?&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;returns a binary flatbuffer generated from the given json and corresponding schema.if there was an error parsing the schema, the error will be in the second returnvalue, or nil for no error&lt;/td&gt;
599: &lt;/tr&gt;
600: &lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;
601: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td&gt;&lt;h3&gt;parsedata&lt;/h3&gt;&lt;/td&gt;&lt;/tr&gt;
602: &lt;tr&gt;&lt;td&gt;&lt;table class=&quot;a&quot; border=1 cellspacing=0 cellpadding=4&gt;&lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;parse_data&lt;/b&gt;(typeid&lt;font color=&quot;#666666&quot;&gt;: typeid(any)&lt;/font&gt;, stringdata&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;any?&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;string?&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;parses a string containing a data structure in lobster syntax (what you get if you convert an arbitrary data structure to a string) back into a data structure. supports int/float/string/vector and classes. classes will be forced to be compatible with their  current definitions, i.e. too many elements will be truncated, missing elements will be set to 0/nil if possible. useful for simple file formats. returns the value and an error string as second return value (or nil if no error)&lt;/td&gt;
603: &lt;/tr&gt;
604: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flexbuffers_value_to_binary&lt;/b&gt;(val&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;, max_nesting&lt;font color=&quot;#666666&quot;&gt;: int&lt;/font&gt; = 0, cycle_detection&lt;font color=&quot;#666666&quot;&gt;: bool&lt;/font&gt; = false) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;turns any reference value into a flexbuffer. max_nesting defaults to 100. cycle_detection is by default off (expensive)&lt;/td&gt;
605: &lt;/tr&gt;
606: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flexbuffers_binary_to_value&lt;/b&gt;(typeid&lt;font color=&quot;#666666&quot;&gt;: typeid(any)&lt;/font&gt;, flex&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;any?&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;string?&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;turns a flexbuffer into a value&lt;/td&gt;
607: &lt;/tr&gt;
608: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flexbuffers_binary_to_json&lt;/b&gt;(flex&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, field_quotes&lt;font color=&quot;#666666&quot;&gt;: bool&lt;/font&gt;, indent_string&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string?&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;string?&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;turns a flexbuffer into a JSON string. If indent_string is empty, will be a single line string&lt;/td&gt;
609: &lt;/tr&gt;
610: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;flexbuffers_json_to_binary&lt;/b&gt;(json&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;, filename_for_errors&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt; = nil) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;string?&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;turns a JSON string into a flexbuffer, second value is error, if any&lt;/td&gt;
611: &lt;/tr&gt;
612: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;lobster_value_to_binary&lt;/b&gt;(val&lt;font color=&quot;#666666&quot;&gt;: any&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;string&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;turns any reference value into a binary using a fast &amp;amp; compact Lobster native serialization format. this is intended for threads/networking, not for storage (since it is not readable by other languages). data structures participating must have been marked by attribute serializable. does not provide protection against cycles, use flexbuffers if that is a concern. &lt;/td&gt;
613: &lt;/tr&gt;
614: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;lobster_binary_to_value&lt;/b&gt;(typeid&lt;font color=&quot;#666666&quot;&gt;: typeid(any)&lt;/font&gt;, bin&lt;font color=&quot;#666666&quot;&gt;: string&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;any?&lt;/font&gt;, &lt;font color=&quot;#666666&quot;&gt;string?&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;turns binary created by lobster_value_to_binary back into a value&lt;/td&gt;
615: &lt;/tr&gt;
616: &lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;
617: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td&gt;&lt;h3&gt;matrix&lt;/h3&gt;&lt;/td&gt;&lt;/tr&gt;
618: &lt;tr&gt;&lt;td&gt;&lt;table class=&quot;a&quot; border=1 cellspacing=0 cellpadding=4&gt;&lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;matrix.multiply&lt;/b&gt;(a&lt;font color=&quot;#666666&quot;&gt;: [float]&lt;/font&gt;, b&lt;font color=&quot;#666666&quot;&gt;: [float]&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[float]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;input matrices must be 4x4 elements&lt;/td&gt;
619: &lt;/tr&gt;
620: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;matrix.rotate_x&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: float2&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[float]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;&lt;/td&gt;
621: &lt;/tr&gt;
622: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;matrix.rotate_y&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: float2&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[float]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;&lt;/td&gt;
623: &lt;/tr&gt;
624: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;matrix.rotate_z&lt;/b&gt;(angle&lt;font color=&quot;#666666&quot;&gt;: float2&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[float]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;&lt;/td&gt;
625: &lt;/tr&gt;
626: &lt;tr class=&quot;a&quot; valign=top&gt;&lt;td class=&quot;a&quot;&gt;&lt;tt&gt;&lt;b&gt;matrix.translation&lt;/b&gt;(trans&lt;font color=&quot;#666666&quot;&gt;: float3&lt;/font&gt;) -&gt; &lt;font color=&quot;#666666&quot;&gt;[float]&lt;/font&gt;&lt;/tt&gt;&lt;/td&gt;&lt;td class=&quot;a&quot;&gt;&lt;/td&gt;
627: &lt;/tr&gt;
628: &lt;/table&gt;&lt;/td&gt;&lt;/tr&gt;
629: &lt;/table&gt;&lt;/center&gt;&lt;/body&gt;
630: &lt;/html&gt;</file><file path="TS/docs/tutorial.html">  1: &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
  2: &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
  3: &lt;html&gt;
  4: &lt;head&gt;
  5: &lt;title&gt;TreeSheets Tutorial&lt;/title&gt;
  6: &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=iso-8859-1&quot;&gt;
  7: &lt;style type=&quot;text/css&quot;&gt;
  8: &lt;!--
  9: .style2 {
 10: 	font-family: Verdana, Arial, Helvetica, sans-serif;
 11: 	font-size: small;
 12: }
 13: .style6 {font-family: &quot;Courier New&quot;, Courier, mono; font-size: medium; font-weight: bold; }
 14: .style8 {font-family: &quot;Courier New&quot;, Courier, mono; font-size: x-large; font-weight: bold; }
 15: .style11 {font-family: Verdana, Arial, Helvetica, sans-serif; font-size: large; }
 16: body {
 17: 	background-color: #666666;
 18: }
 19: .style13 {font-size: xx-large}
 20: div#rounded{
 21: 	background: #FFF;
 22: 	width: 580px;
 23: 	margin-left: auto;
 24: 	margin-right: auto;
 25: }
 26: div#roundedcontent{
 27: 	padding: 20px;
 28: }
 29: b.rtop, b.rbottom{display:block;background: #666}
 30: b.rtop b, b.rbottom b{display:block;height: 1px; overflow: hidden; background: #FFF}
 31: b.r1{margin: 0 5px}
 32: b.r2{margin: 0 3px}
 33: b.r3{margin: 0 2px}
 34: b.rtop b.r4, b.rbottom b.r4{margin: 0 1px;height: 2px}
 35: .style14 {
 36: 	font-family: Verdana, Arial, Helvetica, sans-serif;
 37: 	font-size: small;
 38: 	font-style: italic;
 39: 	color: #F00;
 40: }
 41: --&gt;
 42: &lt;/style&gt;
 43: &lt;/head&gt;
 44: &lt;body&gt;
 45: &lt;div id=&quot;rounded&quot;&gt;&lt;b class=&quot;rtop&quot;&gt;&lt;b class=&quot;r1&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r2&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r3&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r4&quot;&gt;&lt;/b&gt;&lt;/b&gt;&lt;div id=&quot;roundedcontent&quot;&gt;
 46: &lt;p align=&quot;center&quot; class=&quot;style11 style13&quot;&gt;&lt;img src=&quot;images/treesheets_logo.png&quot; width=&quot;507&quot; height=&quot;156&quot;&gt;&lt;/p&gt;
 47: &lt;p align=&quot;center&quot; class=&quot;style11 style13&quot;&gt;Tutorial &amp;amp; Feature description&lt;/p&gt;
 48: &lt;p class=&quot;style2&quot;&gt;There are 3 ways to learn how TreeSheets works:&lt;/p&gt;
 49: &lt;p align=&quot;center&quot; class=&quot;style11&quot;&gt;1. Live In-App Tutorial:&lt;/p&gt;
 50: &lt;p class=&quot;style2&quot;&gt;Try out functionality live while reading about it, in the tutorial document that loads up when you first start the program (or press F1).&lt;/p&gt;
 51: &lt;p align=&quot;center&quot; class=&quot;style11&quot;&gt;2. Watch this video:&lt;/p&gt;
 52: &lt;p class=&quot;style2&quot;&gt;William Ranvaud kindly made a tutorial video:&lt;/p&gt;
 53: &lt;p align=&quot;center&quot; class=&quot;style2&quot;&gt;
 54: &lt;object width=&quot;425&quot; height=&quot;350&quot;&gt;
 55:   &lt;param name=&quot;movie&quot; value=&quot;https://www.youtube.com/v/UB-saQZfrsw&quot; /&gt;
 56:   &lt;param name=&quot;wmode&quot; value=&quot;transparent&quot; /&gt;
 57:   &lt;embed src=&quot;https://www.youtube.com/v/UB-saQZfrsw&quot;
 58:          type=&quot;application/x-shockwave-flash&quot;
 59:          wmode=&quot;transparent&quot; width=&quot;507&quot; height=&quot;400&quot; /&gt;
 60: &lt;/object&gt;
 61: &lt;/p&gt;
 62: &lt;p align=&quot;center&quot; class=&quot;style11&quot;&gt;3. Or, read about it on this page:&lt;/p&gt;
 63: &lt;p class=&quot;style14&quot;&gt;[&lt;strong&gt;Note&lt;/strong&gt;: The text / images below are a bit out of date, but should still give you the general idea.]&lt;/p&gt;
 64: &lt;p class=&quot;style2&quot;&gt;Start by creating a new grid (menu &lt;span class=&quot;style6&quot;&gt;File/New&lt;/span&gt;, or &lt;span class=&quot;style6&quot;&gt;CTRL+N&lt;/span&gt;). Don&apos;t worry too much about dimensions, inserting/deleting rows and columns is the easiest thing.&lt;/p&gt;
 65: &lt;p class=&quot;style2&quot;&gt;&lt;img src=&quot;images/documentation/new.png&quot; width=&quot;59&quot; height=&quot;68&quot;&gt;&lt;/p&gt;
 66:       &lt;p class=&quot;style2&quot;&gt;To enter data, simply &lt;span class=&quot;style6&quot;&gt;LeftClick&lt;/span&gt; inside a cell to select it, and start typing:&lt;/p&gt;
 67:       &lt;p class=&quot;style2&quot;&gt;&lt;img src=&quot;images/documentation/edit.png&quot; width=&quot;81&quot; height=&quot;70&quot;&gt;&lt;/p&gt;
 68:       &lt;p class=&quot;style2&quot;&gt;Once you start typing on a selected cell, a thinner border will indicate that you are in text edit mode (similar to spreadsheets).&lt;/p&gt;
 69:       &lt;p class=&quot;style2&quot;&gt;Select a grid line (&lt;span class=&quot;style6&quot;&gt;LeftClick&lt;/span&gt;):&lt;/p&gt;
 70:     &lt;p class=&quot;style2&quot;&gt;&lt;img src=&quot;images/documentation/gridline.png&quot; width=&quot;88&quot; height=&quot;74&quot;&gt;&lt;/p&gt;
 71:       &lt;p class=&quot;style2&quot;&gt;Now start typing to insert a row or column at that location. The new content will end up at between the cells you clicked at (the thicker part of the line selection):&lt;/p&gt;
 72:       &lt;p class=&quot;style2&quot;&gt;&lt;img src=&quot;images/documentation/insert.png&quot; width=&quot;87&quot; height=&quot;94&quot;&gt;&lt;/p&gt;
 73:       &lt;p class=&quot;style2&quot;&gt;Similarly, we can delete rows or columns by selecting a grid line again:&lt;/p&gt;
 74:       &lt;p class=&quot;style2&quot;&gt;&lt;img src=&quot;images/documentation/gridline2.png&quot; width=&quot;86&quot; height=&quot;95&quot;&gt;&lt;/p&gt;
 75:       &lt;p class=&quot;style2&quot;&gt;and then using the &lt;span class=&quot;style6&quot;&gt;BACKSPACE&lt;/span&gt; key (for the row above, or the column before) or the &lt;span class=&quot;style6&quot;&gt;DELETE&lt;/span&gt; key (for the row below, or the column after) to delete:&lt;/p&gt;
 76:       &lt;p class=&quot;style2&quot;&gt;&lt;img src=&quot;images/documentation/deleted.png&quot; width=&quot;71&quot; height=&quot;96&quot;&gt;&lt;/p&gt;
 77:       &lt;p class=&quot;style2&quot;&gt;This intuititively works much like a text editor, try it out. Don&apos;t worry about accidental deletions, there&apos;s unlimited undo on any actions (&lt;span class=&quot;style6&quot;&gt;Edit/Undo&lt;/span&gt; or &lt;span class=&quot;style6&quot;&gt;CTRL+Z&lt;/span&gt;).&lt;/p&gt;
 78:       &lt;p class=&quot;style2&quot;&gt;Saving (&lt;span class=&quot;style6&quot;&gt;File/Save&lt;/span&gt; or &lt;span class=&quot;style6&quot;&gt;CTRL+S&lt;/span&gt;, &lt;span class=&quot;style6&quot;&gt;File/Save As&lt;/span&gt;) and Loading (&lt;span class=&quot;style6&quot;&gt;File/Open&lt;/span&gt; or &lt;span class=&quot;style6&quot;&gt;CTRL+O&lt;/span&gt;) work as you expect from any productivity application. TreeSheets automatically loads the last saved &lt;span class=&quot;style6&quot;&gt;.cts&lt;/span&gt; file on startup. Use &lt;span class=&quot;style6&quot;&gt;File/Export As XML / HTML / Text&lt;/span&gt; if you need to use your data outside of TreeSheets.&lt;/p&gt;
 79:       &lt;p class=&quot;style2&quot;&gt;These are the basics of editing a single grid, but the real fun only starts when you start organizing your data with grids inside other grids. Simply select a single cell, and use &lt;span class=&quot;style6&quot;&gt;Edit/New Grid&lt;/span&gt; or &lt;span class=&quot;style6&quot;&gt;INSERT&lt;/span&gt;:&lt;/p&gt;
 80:       &lt;p class=&quot;style2&quot;&gt;&lt;img src=&quot;images/documentation/pregrid.png&quot; width=&quot;70&quot; height=&quot;92&quot; align=&quot;middle&quot;&gt; &lt;span class=&quot;style8&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;img src=&quot;images/documentation/postgrid.png&quot; width=&quot;72&quot; height=&quot;120&quot; align=&quot;middle&quot;&gt;&lt;/p&gt;
 81:       &lt;p class=&quot;style2&quot;&gt;The cell you had selected now has a 1x1 subgrid. Edit this cell, and add some additional cells to this new grid to get the hang of how this new grid works in relation to its parent:&lt;/p&gt;
 82:       &lt;p class=&quot;style2&quot;&gt;&lt;img src=&quot;images/documentation/grid.png&quot; width=&quot;129&quot; height=&quot;134&quot;&gt;&lt;/p&gt;
 83:       &lt;p class=&quot;style2&quot;&gt;You can select multiple cells simply by using &lt;span class=&quot;style6&quot;&gt;LeftClick+Drag&lt;/span&gt;, much like in spreadsheets. This even works across grid hierarchy levels, where crossing boundaries will automatically select the entire child:&lt;/p&gt;
 84:       &lt;p class=&quot;style2&quot;&gt;&lt;img src=&quot;images/documentation/gridsel1.png&quot; width=&quot;124&quot; height=&quot;129&quot; align=&quot;middle&quot;&gt; or &lt;img src=&quot;images/documentation/gridsel2.png&quot; width=&quot;127&quot; height=&quot;134&quot; align=&quot;middle&quot;&gt;&lt;/p&gt;
 85:       &lt;p class=&quot;style2&quot;&gt;Some operations work only on single cells (such as inserting new data above), but many also work on these larger selections. For example, you can use &lt;span class=&quot;style6&quot;&gt;DELETE&lt;/span&gt; to clear/remove any sub selection of a grid, and &lt;span class=&quot;style6&quot;&gt;CTRL+LEFT|RIGHT|UP|DOWN&lt;/span&gt; to move a selection around inside a grid:&lt;/p&gt;
 86:     &lt;p class=&quot;style2&quot;&gt;&lt;img src=&quot;images/documentation/gridsel1.png&quot; width=&quot;124&quot; height=&quot;129&quot; align=&quot;middle&quot;&gt; &lt;span class=&quot;style8&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;img src=&quot;images/documentation/gridsel3.png&quot; width=&quot;125&quot; height=&quot;131&quot; align=&quot;middle&quot;&gt;&lt;/p&gt;
 87:       &lt;p class=&quot;style2&quot;&gt;Notice that with every editing operation, resizing to content is automatic. TreeSheets makes organizing data in complex ways really easy, and this way you always get the most compact layout with the ideal usage of space. You can influence how much space anything takes up by using &lt;span class=&quot;style6&quot;&gt;SHIFT+MouseWheel&lt;/span&gt; with any amount of cells selected:&lt;/p&gt;
 88:       &lt;p class=&quot;style2&quot;&gt;&lt;img src=&quot;images/documentation/textsize.png&quot; width=&quot;109&quot; height=&quot;126&quot;&gt;&lt;/p&gt;
 89:       &lt;p class=&quot;style2&quot;&gt;This changes the &lt;em&gt;relative size&lt;/em&gt; of a cell. It is relative to how deeply it is nested (as you saw, a nested grid already had a smaller font). Using relative size is a great tool to make certain important things (such as captions) stand out, and less important data still readable, but very small and thus taking up less space. TreeSheets has been designed with the philosophy that for very large and complex sets of data you should simply be able to shrink data (down to a single pixel per character!) rather than using excessive amounts of space that would require a lot of scrolling around. But once you make something unreadably small, how can you make it readable/editable again? This is where TreeSheets&apos; zooming feature comes in. Simply make any selection, at any level of nesting, and then use the &lt;span class=&quot;style6&quot;&gt;CTRL+MouseWheel&lt;/span&gt; (forward):&lt;/p&gt;
 90:       &lt;p class=&quot;style2&quot;&gt;&lt;img src=&quot;images/documentation/zoomed.png&quot; width=&quot;110&quot; height=&quot;71&quot;&gt;&lt;/p&gt;
 91:       &lt;p class=&quot;style2&quot;&gt;Every click of the MouseWheel will zoom you in one level, so even very deeply nested grids are instantly reachable with a quick flick of the MouseWheel. And since text sizes are relative, the root of what is currently displayed will always be the default font size, making it readable and editable. This system allows you to create TreeSheets containing huge amounts of data, where only the overal structure is visible at the root level, yet everything is quickly within reach.&lt;/p&gt;
 92:       &lt;p class=&quot;style2&quot;&gt;Zooming out back to the root is even easier since it doesn&apos;t even require a selection: just flick your MouseWheel in the backwards direction.&lt;/p&gt;
 93:       &lt;p class=&quot;style2&quot;&gt;(Any use of the MouseWheel can be replaced with &lt;span class=&quot;style6&quot;&gt;PageUp&lt;/span&gt;/&lt;span class=&quot;style6&quot;&gt;PageDown&lt;/span&gt;, which may be more convenient on laptops). &lt;/p&gt;
 94:       &lt;p class=&quot;style2&quot;&gt;TreeSheets will show scrollbars when the current data doesn&apos;t fit on screen, but you are encouraged to find out how much easier it is to work without scrollbars, by shrinking items till they fit. You can shrink unimportant text down to single pixels (!) which is then only readably by zooming in. &lt;/p&gt;
 95:       &lt;p class=&quot;style2&quot;&gt;Another tool to affect the layout of your TreeSheets is the the column width. TreeSheets treats each cell as a single line of text in terms of editing, but you can have that line being word-wrapped across any number of lines you choose. This is useful to stop long lines from stretching the layout of your data. Simply use &lt;span class=&quot;style6&quot;&gt;ALT+ScrollWheel&lt;/span&gt; to increase or decrease the column width:&lt;/p&gt;
 96:       &lt;p class=&quot;style2&quot;&gt;originally: &lt;img src=&quot;images/documentation/long1.png&quot; width=&quot;423&quot; height=&quot;129&quot; align=&quot;middle&quot;&gt;&lt;/p&gt;
 97:       &lt;p class=&quot;style2&quot;&gt;smaller: &lt;img src=&quot;images/documentation/long2.png&quot; width=&quot;275&quot; height=&quot;130&quot; align=&quot;middle&quot;&gt;&lt;/p&gt;
 98:       &lt;p class=&quot;style2&quot;&gt;very small: &lt;img src=&quot;images/documentation/long3.png&quot; width=&quot;174&quot; height=&quot;165&quot; align=&quot;middle&quot;&gt;&lt;/p&gt;
 99:       &lt;p class=&quot;style2&quot;&gt;Cut (&lt;span class=&quot;style6&quot;&gt;Edit/Cut&lt;/span&gt; or &lt;span class=&quot;style6&quot;&gt;CTRL+X&lt;/span&gt;), Copy (&lt;span class=&quot;style6&quot;&gt;Edit/Copy&lt;/span&gt; or &lt;span class=&quot;style6&quot;&gt;CTRL+C&lt;/span&gt;) and Paste (&lt;span class=&quot;style6&quot;&gt;Edit/Paste&lt;/span&gt; or &lt;span class=&quot;style6&quot;&gt;CTRL+V&lt;/span&gt;) work as you expect, though the destination for Paste is expected to be a single cell. Copy and Paste works too and from other applications as well, with any selection being converted to lines of text, with indentation indicating hierarchy levels. Similarly, if you have any text that uses indentention for hierarchy, pasting it into TreeSheets will reproduce that structure.&lt;/p&gt;
100:     &lt;p class=&quot;style2&quot;&gt;Other fun functionality to try:&lt;/p&gt;
101:       &lt;ul&gt;
102:         &lt;li&gt;&lt;p class=&quot;style2&quot;&gt;Use the &lt;span class=&quot;style6&quot;&gt;cursor keys&lt;/span&gt; to move your selection around, or even &lt;span class=&quot;style6&quot;&gt;Enter&lt;/span&gt; to move to the next line&lt;/p&gt;&lt;/li&gt;
103:         &lt;li&gt;&lt;p class=&quot;style2&quot;&gt;Import from XML, or copy paste any ascii text into a cell with indentation will create a tree structure according to the indentation&lt;/p&gt;&lt;/li&gt;
104:         &lt;li&gt;&lt;p class=&quot;style2&quot;&gt;Set your favourite font to view your TreeSheets with (&lt;span class=&quot;style6&quot;&gt;View/Pick Default Font&lt;/span&gt;)&lt;/p&gt;&lt;/li&gt;
105:         &lt;li&gt;
106:           &lt;p class=&quot;style2&quot;&gt;You can add images to any cell (&lt;span class=&quot;style6&quot;&gt;Edit/Images...&lt;/span&gt;). The image will be conveniently stored as part of the file. Once you have loaded an image into a cell once, you can copy paste it to any number of cells within the sheet. Images are always rendered in front of any text that is also part of the cell (and above any subgrid), if you want a different orientation, simply put text and images in seperate cells.&lt;/p&gt;&lt;/li&gt;
107:         &lt;li class=&quot;style2&quot;&gt;TreeSheets has lots of styling and layout options (check out the screenshots page for some examples)&lt;/li&gt;
108:       &lt;/ul&gt;      
109: &lt;/div&gt;&lt;b class=&quot;rbottom&quot;&gt;&lt;b class=&quot;r4&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r3&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r2&quot;&gt;&lt;/b&gt;&lt;b class=&quot;r1&quot;&gt;&lt;/b&gt;&lt;/b&gt;&lt;/div&gt;
110: &lt;/body&gt;
111: &lt;/html&gt;</file><file path="TS/images/material/toolbar/cancel_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;16&quot;
 4:    height=&quot;16&quot;
 5:    viewBox=&quot;0 0 16 16&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;cancel_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;true&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;37.0625&quot;
27:      inkscape:cx=&quot;2.4418212&quot;
28:      inkscape:cy=&quot;7.0961214&quot;
29:      inkscape:window-width=&quot;2560&quot;
30:      inkscape:window-height=&quot;1389&quot;
31:      inkscape:window-x=&quot;0&quot;
32:      inkscape:window-y=&quot;27&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      fill-rule=&quot;evenodd&quot;
37:      clip-rule=&quot;evenodd&quot;
38:      d=&quot;M5.73828 3.31803C4.89437 4.16195 4.42029 5.30657 4.42029 6.50004C4.41987 7.17208 4.57064 7.83558 4.86145 8.44145C5.15226 9.04731 5.57561 9.58001 6.10022 10C6.03062 10.3287 5.99712 10.6641 6.00024 11V11.1701C5.84024 11.0601 5.68027 10.95 5.53027 10.83L1.75024 14.5L1.00024 13.84L4.80029 10.1501C4.21073 9.48341 3.79167 8.6836 3.57922 7.81938C3.36678 6.95515 3.36727 6.05229 3.58057 5.18827C3.79386 4.32426 4.21361 3.52488 4.80383 2.8588C5.39405 2.19273 6.13704 1.67988 6.96912 1.36418C7.80119 1.04847 8.69755 0.939388 9.58105 1.0463C10.4646 1.15322 11.3089 1.473 12.0416 1.97807C12.7744 2.48313 13.3737 3.15845 13.788 3.94608C14.2023 4.73372 14.4192 5.61009 14.4203 6.50004C14.4206 6.76784 14.4005 7.03533 14.3602 7.30009C14.0731 7.03926 13.7579 6.81114 13.4203 6.62003V6.50004C13.4203 5.30657 12.9461 4.16195 12.1022 3.31803C11.2583 2.47412 10.1138 2.00004 8.92029 2.00004C7.72681 2.00004 6.58219 2.47412 5.73828 3.31803ZM8.77793 7.67407C9.43573 7.23455 10.2091 7 11.0002 7C12.0611 7 13.0784 7.42149 13.8286 8.17163C14.5787 8.92178 15.0002 9.93913 15.0002 11C15.0002 11.7911 14.7657 12.5645 14.3261 13.2223C13.8866 13.8801 13.2619 14.3928 12.531 14.6956C11.8001 14.9983 10.9958 15.0774 10.2198 14.9231C9.4439 14.7688 8.73126 14.3878 8.17185 13.8284C7.61244 13.269 7.23147 12.5563 7.07713 11.7804C6.92279 11.0045 7.00191 10.2001 7.30467 9.46924C7.60742 8.73833 8.12014 8.1136 8.77793 7.67407ZM8.87888 13.1213C9.44149 13.6839 10.2046 14 11.0002 14C11.6233 14.0018 12.2314 13.8095 12.7402 13.45L8.55027 9.26001C8.1907 9.76883 7.99843 10.377 8.00022 11C8.00022 11.7956 8.31628 12.5587 8.87888 13.1213ZM9.26023 8.55005L13.4502 12.74C13.8097 12.2312 14.002 11.623 14.0002 11C14.0002 10.2044 13.6842 9.44127 13.1216 8.87866C12.559 8.31605 11.7959 8 11.0002 8C10.3772 7.9982 9.76905 8.19048 9.26023 8.55005Z&quot;
39:      fill=&quot;#424242&quot;
40:      id=&quot;path1&quot;
41:      style=&quot;fill:#ffffff&quot; /&gt;
42: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/cancel.svg">1: &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
2: &lt;path fill-rule=&quot;evenodd&quot; clip-rule=&quot;evenodd&quot; d=&quot;M5.73828 3.31803C4.89437 4.16195 4.42029 5.30657 4.42029 6.50004C4.41987 7.17208 4.57064 7.83558 4.86145 8.44145C5.15226 9.04731 5.57561 9.58001 6.10022 10C6.03062 10.3287 5.99712 10.6641 6.00024 11V11.1701C5.84024 11.0601 5.68027 10.95 5.53027 10.83L1.75024 14.5L1.00024 13.84L4.80029 10.1501C4.21073 9.48341 3.79167 8.6836 3.57922 7.81938C3.36678 6.95515 3.36727 6.05229 3.58057 5.18827C3.79386 4.32426 4.21361 3.52488 4.80383 2.8588C5.39405 2.19273 6.13704 1.67988 6.96912 1.36418C7.80119 1.04847 8.69755 0.939388 9.58105 1.0463C10.4646 1.15322 11.3089 1.473 12.0416 1.97807C12.7744 2.48313 13.3737 3.15845 13.788 3.94608C14.2023 4.73372 14.4192 5.61009 14.4203 6.50004C14.4206 6.76784 14.4005 7.03533 14.3602 7.30009C14.0731 7.03926 13.7579 6.81114 13.4203 6.62003V6.50004C13.4203 5.30657 12.9461 4.16195 12.1022 3.31803C11.2583 2.47412 10.1138 2.00004 8.92029 2.00004C7.72681 2.00004 6.58219 2.47412 5.73828 3.31803ZM8.77793 7.67407C9.43573 7.23455 10.2091 7 11.0002 7C12.0611 7 13.0784 7.42149 13.8286 8.17163C14.5787 8.92178 15.0002 9.93913 15.0002 11C15.0002 11.7911 14.7657 12.5645 14.3261 13.2223C13.8866 13.8801 13.2619 14.3928 12.531 14.6956C11.8001 14.9983 10.9958 15.0774 10.2198 14.9231C9.4439 14.7688 8.73126 14.3878 8.17185 13.8284C7.61244 13.269 7.23147 12.5563 7.07713 11.7804C6.92279 11.0045 7.00191 10.2001 7.30467 9.46924C7.60742 8.73833 8.12014 8.1136 8.77793 7.67407ZM8.87888 13.1213C9.44149 13.6839 10.2046 14 11.0002 14C11.6233 14.0018 12.2314 13.8095 12.7402 13.45L8.55027 9.26001C8.1907 9.76883 7.99843 10.377 8.00022 11C8.00022 11.7956 8.31628 12.5587 8.87888 13.1213ZM9.26023 8.55005L13.4502 12.74C13.8097 12.2312 14.002 11.623 14.0002 11C14.0002 10.2044 13.6842 9.44127 13.1216 8.87866C12.559 8.31605 11.7959 8 11.0002 8C10.3772 7.9982 9.76905 8.19048 9.26023 8.55005Z&quot; fill=&quot;#424242&quot;/&gt;
3: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/editcopy_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;24&quot;
 4:    height=&quot;24&quot;
 5:    viewBox=&quot;0 0 24 24&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;editcopy_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;0&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;49.416667&quot;
27:      inkscape:cx=&quot;12.010118&quot;
28:      inkscape:cy=&quot;12&quot;
29:      inkscape:window-width=&quot;2560&quot;
30:      inkscape:window-height=&quot;1389&quot;
31:      inkscape:window-x=&quot;0&quot;
32:      inkscape:window-y=&quot;27&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      d=&quot;M17.5002 0H8.50024L7.00024 1.5V6H2.50024L1.00024 7.5V22.5699L2.50024 24H14.5702L16.0002 22.5699V18H20.7002L22.0002 16.5699V4.5L17.5002 0ZM17.5002 2.12L19.8802 4.5H17.5002V2.12ZM14.5002 22.5H2.50024V7.5H7.00024V16.5699L8.50024 18H14.5002V22.5ZM20.5002 16.5H8.50024V1.5H16.0002V6H20.5002V16.5Z&quot;
37:      fill=&quot;#424242&quot;
38:      id=&quot;path1&quot;
39:      style=&quot;fill:#ffffff&quot; /&gt;
40: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/editcopy.svg">1: &lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
2: &lt;path d=&quot;M17.5002 0H8.50024L7.00024 1.5V6H2.50024L1.00024 7.5V22.5699L2.50024 24H14.5702L16.0002 22.5699V18H20.7002L22.0002 16.5699V4.5L17.5002 0ZM17.5002 2.12L19.8802 4.5H17.5002V2.12ZM14.5002 22.5H2.50024V7.5H7.00024V16.5699L8.50024 18H14.5002V22.5ZM20.5002 16.5H8.50024V1.5H16.0002V6H20.5002V16.5Z&quot; fill=&quot;#424242&quot;/&gt;
3: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/editpaste_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;24&quot;
 4:    height=&quot;24&quot;
 5:    viewBox=&quot;0 0 24 24&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;editpaste_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;0&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;34.625&quot;
27:      inkscape:cx=&quot;11.971119&quot;
28:      inkscape:cy=&quot;14.296029&quot;
29:      inkscape:window-width=&quot;2560&quot;
30:      inkscape:window-height=&quot;1389&quot;
31:      inkscape:window-x=&quot;0&quot;
32:      inkscape:window-y=&quot;27&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      fill-rule=&quot;evenodd&quot;
37:      clip-rule=&quot;evenodd&quot;
38:      d=&quot;m 24,14 v 8.5 L 22.5,24 h -9 L 12,22.5 v -11 L 13.5,9.9999995 20,10 m -1.3e-5,4 H 22 L 20,12.12 Z M 13.5,11.5 v 11 h 9 v -7 H 19.500025 L 18.5,14.5 v -3 z&quot;
39:      fill=&quot;#424242&quot;
40:      id=&quot;path1&quot;
41:      style=&quot;stroke-width:1;fill:#ffffff&quot;
42:      sodipodi:nodetypes=&quot;cccccccccccccccccccc&quot; /&gt;
43:   &lt;path
44:      fill-rule=&quot;evenodd&quot;
45:      clip-rule=&quot;evenodd&quot;
46:      d=&quot;m 10.750039,20.487399 -5.0004751,3.07e-4 V 7.0001537 L 18.249985,6.9998463 V 9 h 1.50003 L 19.75,6.4878497 18.75,5.487385 h -1.999997 v -1.5 H 15.249997 C 15.246697,3.193015 14.928441,2.43241 14.365053,1.872385 13.802971,1.31362 13.042618,1 12.250045,1 11.457487,1 10.697134,1.31362 10.135037,1.872385 9.5716645,2.43241 9.2533932,3.193015 9.2500331,3.987385 H 7.6600267 v 1.5 L 5.2497894,5.4875424 4.249985,6.4881503 V 20.988 l 0.9993494,1.012078 5.5002496,-1.57e-4 z m 0,-16.800014 c 0.05547,-0.29781 0.199801,-0.57183 0.413987,-0.78603 0.2142,-0.214185 0.488222,-0.358515 0.786018,-0.41397 0.292516,-0.057105 0.595382,-0.02577 0.870003,0.09 0.276001,0.10488 0.512087,0.29376 0.675003,0.54 0.196516,0.28881 0.286066,0.63714 0.253216,0.984915 -0.03286,0.34779 -0.186076,0.673185 -0.433217,0.920085 -0.246886,0.247125 -0.572297,0.400335 -0.920073,0.4332 -0.347777,0.032865 -0.696123,-0.0567 -0.984934,-0.2532 -0.246226,-0.162915 -0.435107,-0.399015 -0.540003,-0.675 -0.12,-0.26262 -0.16167,-0.554295 -0.12,-0.84 z&quot;
47:      fill=&quot;#424242&quot;
48:      id=&quot;path1-1&quot;
49:      style=&quot;stroke-width:1;fill:#ffffff&quot;
50:      sodipodi:nodetypes=&quot;ccccccccccccscccccccccccccccccsccc&quot; /&gt;
51: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/editpaste.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;24&quot;
 4:    height=&quot;24&quot;
 5:    viewBox=&quot;0 0 24 24&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;editpaste.svg&quot;
10:    inkscape:version=&quot;1.3.2 (091e20e, 2023-11-25, custom)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;0&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;34.625&quot;
27:      inkscape:cx=&quot;11.98556&quot;
28:      inkscape:cy=&quot;14.310469&quot;
29:      inkscape:window-width=&quot;1920&quot;
30:      inkscape:window-height=&quot;1027&quot;
31:      inkscape:window-x=&quot;-8&quot;
32:      inkscape:window-y=&quot;-8&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      fill-rule=&quot;evenodd&quot;
37:      clip-rule=&quot;evenodd&quot;
38:      d=&quot;m 24,14 v 8.5 L 22.5,24 h -9 L 12,22.5 v -11 L 13.5,9.9999995 20,10 m -1.3e-5,4 H 22 L 20,12.12 Z M 13.5,11.5 v 11 h 9 v -7 H 19.500025 L 18.5,14.5 v -3 z&quot;
39:      fill=&quot;#424242&quot;
40:      id=&quot;path1&quot;
41:      style=&quot;stroke-width:1&quot;
42:      sodipodi:nodetypes=&quot;cccccccccccccccccccc&quot; /&gt;
43:   &lt;path
44:      fill-rule=&quot;evenodd&quot;
45:      clip-rule=&quot;evenodd&quot;
46:      d=&quot;m 10.750039,20.487399 -5.0004751,3.07e-4 V 7.0001537 L 18.249985,6.9998463 V 9 h 1.50003 L 19.75,6.4878497 18.75,5.487385 h -1.999997 v -1.5 H 15.249997 C 15.246697,3.193015 14.928441,2.43241 14.365053,1.872385 13.802971,1.31362 13.042618,1 12.250045,1 11.457487,1 10.697134,1.31362 10.135037,1.872385 9.5716645,2.43241 9.2533932,3.193015 9.2500331,3.987385 H 7.6600267 v 1.5 L 5.2497894,5.4875424 4.249985,6.4881503 V 20.988 l 0.9993494,1.012078 5.5002496,-1.57e-4 z m 0,-16.800014 c 0.05547,-0.29781 0.199801,-0.57183 0.413987,-0.78603 0.2142,-0.214185 0.488222,-0.358515 0.786018,-0.41397 0.292516,-0.057105 0.595382,-0.02577 0.870003,0.09 0.276001,0.10488 0.512087,0.29376 0.675003,0.54 0.196516,0.28881 0.286066,0.63714 0.253216,0.984915 -0.03286,0.34779 -0.186076,0.673185 -0.433217,0.920085 -0.246886,0.247125 -0.572297,0.400335 -0.920073,0.4332 -0.347777,0.032865 -0.696123,-0.0567 -0.984934,-0.2532 -0.246226,-0.162915 -0.435107,-0.399015 -0.540003,-0.675 -0.12,-0.26262 -0.16167,-0.554295 -0.12,-0.84 z&quot;
47:      fill=&quot;#424242&quot;
48:      id=&quot;path1-1&quot;
49:      style=&quot;stroke-width:1&quot;
50:      sodipodi:nodetypes=&quot;ccccccccccccscccccccccccccccccsccc&quot; /&gt;
51: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/filenew_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;16&quot;
 4:    height=&quot;16&quot;
 5:    viewBox=&quot;0 0 16 16&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;filenew_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;sodipodi:namedview
16:      id=&quot;namedview1&quot;
17:      pagecolor=&quot;#ffffff&quot;
18:      bordercolor=&quot;#000000&quot;
19:      borderopacity=&quot;0.25&quot;
20:      inkscape:showpageshadow=&quot;2&quot;
21:      inkscape:pageopacity=&quot;0.0&quot;
22:      inkscape:pagecheckerboard=&quot;0&quot;
23:      inkscape:deskcolor=&quot;#d1d1d1&quot;
24:      inkscape:zoom=&quot;74.125&quot;
25:      inkscape:cx=&quot;7.9932546&quot;
26:      inkscape:cy=&quot;8&quot;
27:      inkscape:window-width=&quot;2560&quot;
28:      inkscape:window-height=&quot;1389&quot;
29:      inkscape:window-x=&quot;0&quot;
30:      inkscape:window-y=&quot;27&quot;
31:      inkscape:window-maximized=&quot;1&quot;
32:      inkscape:current-layer=&quot;g1&quot; /&gt;
33:   &lt;g
34:      clip-path=&quot;url(#clip0)&quot;
35:      id=&quot;g1&quot;&gt;
36:     &lt;path
37:        fill-rule=&quot;evenodd&quot;
38:        clip-rule=&quot;evenodd&quot;
39:        d=&quot;M4.00024 7H3.00024V4H0.000244141V3H3.00024V0H4.00024V3H7.00024V4H4.00024V7ZM10.5002 1.09998L13.9003 4.59998L14.0002 5V13.5L13.5002 14H3.50024L3.00024 13.5V8H4.00024V13H13.0002V6H9.00024V2H5.00024V1H10.2002L10.5002 1.09998ZM10.0002 2V5H12.9003L10.0002 2Z&quot;
40:        fill=&quot;#424242&quot;
41:        id=&quot;path1&quot;
42:        style=&quot;fill:#ffffff&quot; /&gt;
43:   &lt;/g&gt;
44:   &lt;defs
45:      id=&quot;defs1&quot;&gt;
46:     &lt;clipPath
47:        id=&quot;clip0&quot;&gt;
48:       &lt;rect
49:          width=&quot;16&quot;
50:          height=&quot;16&quot;
51:          fill=&quot;white&quot;
52:          transform=&quot;translate(0.000244141)&quot;
53:          id=&quot;rect1&quot; /&gt;
54:     &lt;/clipPath&gt;
55:   &lt;/defs&gt;
56: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/filenew.svg"> 1: &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
 2: &lt;g clip-path=&quot;url(#clip0)&quot;&gt;
 3: &lt;path fill-rule=&quot;evenodd&quot; clip-rule=&quot;evenodd&quot; d=&quot;M4.00024 7H3.00024V4H0.000244141V3H3.00024V0H4.00024V3H7.00024V4H4.00024V7ZM10.5002 1.09998L13.9003 4.59998L14.0002 5V13.5L13.5002 14H3.50024L3.00024 13.5V8H4.00024V13H13.0002V6H9.00024V2H5.00024V1H10.2002L10.5002 1.09998ZM10.0002 2V5H12.9003L10.0002 2Z&quot; fill=&quot;#424242&quot;/&gt;
 4: &lt;/g&gt;
 5: &lt;defs&gt;
 6: &lt;clipPath id=&quot;clip0&quot;&gt;
 7: &lt;rect width=&quot;16&quot; height=&quot;16&quot; fill=&quot;white&quot; transform=&quot;translate(0.000244141)&quot;/&gt;
 8: &lt;/clipPath&gt;
 9: &lt;/defs&gt;
10: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/fileopen_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;16&quot;
 4:    height=&quot;16&quot;
 5:    viewBox=&quot;0 0 16 16&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;fileopen_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;0&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;74.125&quot;
27:      inkscape:cx=&quot;7.9932546&quot;
28:      inkscape:cy=&quot;8&quot;
29:      inkscape:window-width=&quot;2560&quot;
30:      inkscape:window-height=&quot;1389&quot;
31:      inkscape:window-x=&quot;0&quot;
32:      inkscape:window-y=&quot;27&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      d=&quot;M1.50024 14H12.5002L12.9802 13.63L15.6102 6.63L15.1302 6H14.0002V3.5L13.5002 3H7.71021L6.85022 2.15002L6.50024 2H1.50024L1.00024 2.5V13.5L1.50024 14ZM2.00024 3H6.29028L7.15027 3.84998L7.50024 4H13.0002V6H8.50024L8.15027 6.15002L7.29028 7H3.50024L3.03027 7.33997L2.03027 10.42L2.00024 3ZM12.1302 13H2.19019L3.86023 8H7.50024L7.85022 7.84998L8.71021 7H14.5002L12.1302 13Z&quot;
37:      fill=&quot;#424242&quot;
38:      id=&quot;path1&quot;
39:      style=&quot;fill:#ffffff&quot; /&gt;
40: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/fileopen.svg">1: &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
2: &lt;path d=&quot;M1.50024 14H12.5002L12.9802 13.63L15.6102 6.63L15.1302 6H14.0002V3.5L13.5002 3H7.71021L6.85022 2.15002L6.50024 2H1.50024L1.00024 2.5V13.5L1.50024 14ZM2.00024 3H6.29028L7.15027 3.84998L7.50024 4H13.0002V6H8.50024L8.15027 6.15002L7.29028 7H3.50024L3.03027 7.33997L2.03027 10.42L2.00024 3ZM12.1302 13H2.19019L3.86023 8H7.50024L7.85022 7.84998L8.71021 7H14.5002L12.1302 13Z&quot; fill=&quot;#424242&quot;/&gt;
3: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/filesave_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;16&quot;
 4:    height=&quot;16&quot;
 5:    viewBox=&quot;0 0 16 16&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;filesave_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;0&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;74.125&quot;
27:      inkscape:cx=&quot;7.9932546&quot;
28:      inkscape:cy=&quot;8&quot;
29:      inkscape:window-width=&quot;2560&quot;
30:      inkscape:window-height=&quot;1389&quot;
31:      inkscape:window-x=&quot;0&quot;
32:      inkscape:window-y=&quot;27&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      fill-rule=&quot;evenodd&quot;
37:      clip-rule=&quot;evenodd&quot;
38:      d=&quot;M13.3532 1.146L14.8532 2.646L15.0002 3V14.5L14.5002 15H1.50024L1.00024 14.5V1.5L1.50024 1H13.0002L13.3532 1.146ZM2.00024 2V14H14.0002V3.208L12.7932 2H11.0002V6H4.00024V2H2.00024ZM8.00024 2V5H10.0002V2H8.00024Z&quot;
39:      fill=&quot;#424242&quot;
40:      id=&quot;path1&quot;
41:      style=&quot;fill:#ffffff&quot; /&gt;
42: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/filesave.svg">1: &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
2: &lt;path fill-rule=&quot;evenodd&quot; clip-rule=&quot;evenodd&quot; d=&quot;M13.3532 1.146L14.8532 2.646L15.0002 3V14.5L14.5002 15H1.50024L1.00024 14.5V1.5L1.50024 1H13.0002L13.3532 1.146ZM2.00024 2V14H14.0002V3.208L12.7932 2H11.0002V6H4.00024V2H2.00024ZM8.00024 2V5H10.0002V2H8.00024Z&quot; fill=&quot;#424242&quot;/&gt;
3: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/filesaveas_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;16&quot;
 4:    height=&quot;16&quot;
 5:    viewBox=&quot;0 0 16 16&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;filesaveas_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;0&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;74.125&quot;
27:      inkscape:cx=&quot;7.9932546&quot;
28:      inkscape:cy=&quot;8&quot;
29:      inkscape:window-width=&quot;2560&quot;
30:      inkscape:window-height=&quot;1389&quot;
31:      inkscape:window-x=&quot;0&quot;
32:      inkscape:window-y=&quot;27&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      fill-rule=&quot;evenodd&quot;
37:      clip-rule=&quot;evenodd&quot;
38:      d=&quot;M11.0403 1.32996L12.7102 3L13.0002 3.70996V4.04004H12.5002L12.0002 4.54004V3.70996L10.3302 2.04004H10.0002V6.04004H4.00024V2.04004H2.00024V12.04H5.00024L4.50024 13.04H2.00024L1.00024 12.04V2.04004L2.00024 1.04004H10.3302L11.0403 1.32996ZM7.00024 5H9.00024V2H7.00024V5ZM13.5002 5L15.0002 6.5L14.9802 7.18994L9.48022 12.6899L9.35022 12.8101L8.98022 13.1801L8.88025 13.27L5.88025 14.77L5.21021 14.1L6.71021 11.1L6.80029 11L7.17029 10.63L7.29028 10.5L12.7903 5H13.5002ZM7.28027 12.24L6.76025 13.24L7.80029 12.76L7.28027 12.24ZM7.97021 11.21L8.76025 12L13.9103 6.84998L13.1202 6.06006L7.97021 11.21Z&quot;
39:      fill=&quot;#424242&quot;
40:      id=&quot;path1&quot;
41:      style=&quot;fill:#ffffff&quot; /&gt;
42: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/filesaveas.svg">1: &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
2: &lt;path fill-rule=&quot;evenodd&quot; clip-rule=&quot;evenodd&quot; d=&quot;M11.0403 1.32996L12.7102 3L13.0002 3.70996V4.04004H12.5002L12.0002 4.54004V3.70996L10.3302 2.04004H10.0002V6.04004H4.00024V2.04004H2.00024V12.04H5.00024L4.50024 13.04H2.00024L1.00024 12.04V2.04004L2.00024 1.04004H10.3302L11.0403 1.32996ZM7.00024 5H9.00024V2H7.00024V5ZM13.5002 5L15.0002 6.5L14.9802 7.18994L9.48022 12.6899L9.35022 12.8101L8.98022 13.1801L8.88025 13.27L5.88025 14.77L5.21021 14.1L6.71021 11.1L6.80029 11L7.17029 10.63L7.29028 10.5L12.7903 5H13.5002ZM7.28027 12.24L6.76025 13.24L7.80029 12.76L7.28027 12.24ZM7.97021 11.21L8.76025 12L13.9103 6.84998L13.1202 6.06006L7.97021 11.21Z&quot; fill=&quot;#424242&quot;/&gt;
3: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/image_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    height=&quot;16&quot;
 4:    viewBox=&quot;0 -960 640 640&quot;
 5:    width=&quot;16&quot;
 6:    version=&quot;1.1&quot;
 7:    id=&quot;svg1&quot;
 8:    sodipodi:docname=&quot;image_dark.svg&quot;
 9:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
10:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
11:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
12:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
13:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
14:   &lt;defs
15:      id=&quot;defs1&quot; /&gt;
16:   &lt;sodipodi:namedview
17:      id=&quot;namedview1&quot;
18:      pagecolor=&quot;#ffffff&quot;
19:      bordercolor=&quot;#000000&quot;
20:      borderopacity=&quot;0.25&quot;
21:      inkscape:showpageshadow=&quot;2&quot;
22:      inkscape:pageopacity=&quot;0.0&quot;
23:      inkscape:pagecheckerboard=&quot;0&quot;
24:      inkscape:deskcolor=&quot;#d1d1d1&quot;
25:      inkscape:zoom=&quot;49.9375&quot;
26:      inkscape:cx=&quot;7.979975&quot;
27:      inkscape:cy=&quot;7.9899875&quot;
28:      inkscape:window-width=&quot;2560&quot;
29:      inkscape:window-height=&quot;1389&quot;
30:      inkscape:window-x=&quot;0&quot;
31:      inkscape:window-y=&quot;27&quot;
32:      inkscape:window-maximized=&quot;1&quot;
33:      inkscape:current-layer=&quot;svg1&quot; /&gt;
34:   &lt;path
35:      d=&quot;m 70,-370 -20,-20 v -500 l 20,-20 h 300 v 40 H 90 v 460 h 460 v -280 h 40 v 300 l -20,20 z m 400,-360 v -60 h -60 v -60 h 60 v -60 h 60 v 60 h 60 v 60 h -60 v 60 z&quot;
36:      id=&quot;path1&quot;
37:      style=&quot;fill:#ffffff;fill-opacity:1;stroke-width:0.999997&quot;
38:      sodipodi:nodetypes=&quot;ccccccccccccccccccccccccccc&quot; /&gt;
39:   &lt;path
40:      d=&quot;M 140,-470 H 500 L 387.5,-670 297.5,-510 230,-630 Z&quot;
41:      style=&quot;fill:#ffffff;fill-opacity:1;stroke-width:0.999997&quot;
42:      id=&quot;path1-4&quot; /&gt;
43: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/image.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    height=&quot;16&quot;
 4:    viewBox=&quot;0 -960 640 640&quot;
 5:    width=&quot;16&quot;
 6:    version=&quot;1.1&quot;
 7:    id=&quot;svg1&quot;
 8:    sodipodi:docname=&quot;image.svg&quot;
 9:    inkscape:version=&quot;1.3.2 (091e20e, 2023-11-25, custom)&quot;
10:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
11:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
12:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
13:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
14:   &lt;defs
15:      id=&quot;defs1&quot; /&gt;
16:   &lt;sodipodi:namedview
17:      id=&quot;namedview1&quot;
18:      pagecolor=&quot;#ffffff&quot;
19:      bordercolor=&quot;#000000&quot;
20:      borderopacity=&quot;0.25&quot;
21:      inkscape:showpageshadow=&quot;2&quot;
22:      inkscape:pageopacity=&quot;0.0&quot;
23:      inkscape:pagecheckerboard=&quot;0&quot;
24:      inkscape:deskcolor=&quot;#d1d1d1&quot;
25:      inkscape:zoom=&quot;49.9375&quot;
26:      inkscape:cx=&quot;7.9899875&quot;
27:      inkscape:cy=&quot;8&quot;
28:      inkscape:window-width=&quot;1920&quot;
29:      inkscape:window-height=&quot;1013&quot;
30:      inkscape:window-x=&quot;-9&quot;
31:      inkscape:window-y=&quot;-9&quot;
32:      inkscape:window-maximized=&quot;1&quot;
33:      inkscape:current-layer=&quot;svg1&quot; /&gt;
34:   &lt;path
35:      d=&quot;m 70,-370 -20,-20 v -500 l 20,-20 h 300 v 40 H 90 v 460 h 460 v -280 h 40 v 300 l -20,20 z m 400,-360 v -60 h -60 v -60 h 60 v -60 h 60 v 60 h 60 v 60 h -60 v 60 z&quot;
36:      id=&quot;path1&quot;
37:      style=&quot;fill:#424242;fill-opacity:1;stroke-width:0.999997&quot;
38:      sodipodi:nodetypes=&quot;ccccccccccccccccccccccccccc&quot; /&gt;
39:   &lt;path
40:      d=&quot;M 140,-470 H 500 L 387.5,-670 297.5,-510 230,-630 Z&quot;
41:      style=&quot;fill:#424242;fill-opacity:1;stroke-width:0.999997&quot;
42:      id=&quot;path1-4&quot; /&gt;
43: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/newgrid_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    height=&quot;16&quot;
 4:    viewBox=&quot;0 -960 640 640&quot;
 5:    width=&quot;16&quot;
 6:    version=&quot;1.1&quot;
 7:    id=&quot;svg1&quot;
 8:    sodipodi:docname=&quot;newgrid_dark.svg&quot;
 9:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
10:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
11:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
12:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
13:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
14:   &lt;defs
15:      id=&quot;defs1&quot; /&gt;
16:   &lt;sodipodi:namedview
17:      id=&quot;namedview1&quot;
18:      pagecolor=&quot;#ffffff&quot;
19:      bordercolor=&quot;#000000&quot;
20:      borderopacity=&quot;0.25&quot;
21:      inkscape:showpageshadow=&quot;2&quot;
22:      inkscape:pageopacity=&quot;0.0&quot;
23:      inkscape:pagecheckerboard=&quot;0&quot;
24:      inkscape:deskcolor=&quot;#d1d1d1&quot;
25:      inkscape:zoom=&quot;49.9375&quot;
26:      inkscape:cx=&quot;8&quot;
27:      inkscape:cy=&quot;7.9899875&quot;
28:      inkscape:window-width=&quot;2560&quot;
29:      inkscape:window-height=&quot;1389&quot;
30:      inkscape:window-x=&quot;0&quot;
31:      inkscape:window-y=&quot;27&quot;
32:      inkscape:window-maximized=&quot;1&quot;
33:      inkscape:current-layer=&quot;svg1&quot; /&gt;
34:   &lt;path
35:      style=&quot;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:40;stroke-dasharray:40, 40;stroke-dashoffset:0;stroke-opacity:1&quot;
36:      d=&quot;M 20.000001,-899.99999 H 620.00002&quot;
37:      id=&quot;path1-8&quot; /&gt;
38:   &lt;path
39:      style=&quot;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:40;stroke-dasharray:40, 40;stroke-dashoffset:20;stroke-opacity:1&quot;
40:      d=&quot;M 40,-360 V -920&quot;
41:      id=&quot;path3&quot; /&gt;
42:   &lt;path
43:      style=&quot;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:40;stroke-dasharray:40, 40;stroke-dashoffset:0;stroke-opacity:1&quot;
44:      d=&quot;M 20.000001,-380.00001 H 620.00002&quot;
45:      id=&quot;path2&quot; /&gt;
46:   &lt;path
47:      style=&quot;fill:#ffffff;fill-opacity:1;stroke:#ffffff;stroke-width:40;stroke-dasharray:40, 40;stroke-dashoffset:20;stroke-opacity:1&quot;
48:      d=&quot;M 600,-360 V -920&quot;
49:      id=&quot;path7&quot; /&gt;
50:   &lt;path
51:      d=&quot;m 180,-480 -20,-20 v -280 l 20,-20 h 100 v 40 h -80 v 240 l 240,0.0133 v -80.00665 l 40,-0.0133 V -500 l -20,20 z m 193.33334,-160 v -53.33334 H 320 v -53.33333 h 53.33334 V -800 h 53.33333 v 53.33333 H 480 v 53.33333 H 426.66667 V -640 Z M 200,-760 v 240 z&quot;
52:      id=&quot;path1&quot;
53:      style=&quot;fill:#ffffff;fill-opacity:1;stroke-width:0.999996&quot;
54:      sodipodi:nodetypes=&quot;cccccccccccccccccccccccccccccc&quot; /&gt;
55: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/newgrid.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    height=&quot;16&quot;
 4:    viewBox=&quot;0 -960 640 640&quot;
 5:    width=&quot;16&quot;
 6:    version=&quot;1.1&quot;
 7:    id=&quot;svg1&quot;
 8:    sodipodi:docname=&quot;newgrid.svg&quot;
 9:    inkscape:version=&quot;1.3.2 (091e20e, 2023-11-25, custom)&quot;
10:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
11:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
12:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
13:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
14:   &lt;defs
15:      id=&quot;defs1&quot; /&gt;
16:   &lt;sodipodi:namedview
17:      id=&quot;namedview1&quot;
18:      pagecolor=&quot;#ffffff&quot;
19:      bordercolor=&quot;#000000&quot;
20:      borderopacity=&quot;0.25&quot;
21:      inkscape:showpageshadow=&quot;2&quot;
22:      inkscape:pageopacity=&quot;0.0&quot;
23:      inkscape:pagecheckerboard=&quot;0&quot;
24:      inkscape:deskcolor=&quot;#d1d1d1&quot;
25:      inkscape:zoom=&quot;49.9375&quot;
26:      inkscape:cx=&quot;8&quot;
27:      inkscape:cy=&quot;8&quot;
28:      inkscape:window-width=&quot;1920&quot;
29:      inkscape:window-height=&quot;1013&quot;
30:      inkscape:window-x=&quot;-9&quot;
31:      inkscape:window-y=&quot;-9&quot;
32:      inkscape:window-maximized=&quot;1&quot;
33:      inkscape:current-layer=&quot;svg1&quot; /&gt;
34:   &lt;path
35:      style=&quot;fill:none;fill-opacity:1;stroke:#424242;stroke-width:40;stroke-dasharray:40, 40;stroke-dashoffset:0;stroke-opacity:1&quot;
36:      d=&quot;M 20.000001,-899.99999 H 620.00002&quot;
37:      id=&quot;path1-8&quot; /&gt;
38:   &lt;path
39:      style=&quot;fill:none;fill-opacity:1;stroke:#424242;stroke-width:40;stroke-dasharray:40, 40;stroke-dashoffset:20;stroke-opacity:1&quot;
40:      d=&quot;M 40,-360 V -920&quot;
41:      id=&quot;path3&quot; /&gt;
42:   &lt;path
43:      style=&quot;fill:none;fill-opacity:1;stroke:#424242;stroke-width:40;stroke-dasharray:40, 40;stroke-dashoffset:0;stroke-opacity:1&quot;
44:      d=&quot;M 20.000001,-380.00001 H 620.00002&quot;
45:      id=&quot;path2&quot; /&gt;
46:   &lt;path
47:      style=&quot;fill:none;fill-opacity:1;stroke:#424242;stroke-width:40;stroke-dasharray:40,40;stroke-dashoffset:20;stroke-opacity:1&quot;
48:      d=&quot;M 600,-360 V -920&quot;
49:      id=&quot;path7&quot; /&gt;
50:   &lt;path
51:      d=&quot;m 180,-480 -20,-20 v -280 l 20,-20 h 100 v 40 h -80 v 240 l 240,0.0133 v -80.00665 l 40,-0.0133 V -500 l -20,20 z m 193.33334,-160 v -53.33334 H 320 v -53.33333 h 53.33334 V -800 h 53.33333 v 53.33333 H 480 v 53.33333 H 426.66667 V -640 Z M 200,-760 v 240 z&quot;
52:      id=&quot;path1&quot;
53:      style=&quot;fill:#424242;fill-opacity:1;stroke-width:0.999996&quot;
54:      sodipodi:nodetypes=&quot;cccccccccccccccccccccccccccccc&quot; /&gt;
55: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/replace_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;16&quot;
 4:    height=&quot;16&quot;
 5:    viewBox=&quot;0 0 16 16&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;replace_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;0&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;74.125&quot;
27:      inkscape:cx=&quot;7.9932546&quot;
28:      inkscape:cy=&quot;8&quot;
29:      inkscape:window-width=&quot;2560&quot;
30:      inkscape:window-height=&quot;1389&quot;
31:      inkscape:window-x=&quot;0&quot;
32:      inkscape:window-y=&quot;27&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      fill-rule=&quot;evenodd&quot;
37:      clip-rule=&quot;evenodd&quot;
38:      d=&quot;M3.22124 3.739L5.48224 6.008L7.70024 3.784L7.00025 3.084L5.98824 4.091L5.98024 2.491C5.97934 2.35567 6.03093 2.22525 6.12417 2.12716C6.21741 2.02908 6.34504 1.97095 6.48024 1.965H8.00024V1H6.48024C6.2852 1.00026 6.09213 1.03902 5.9121 1.11405C5.73207 1.18908 5.56862 1.29892 5.43112 1.43725C5.29363 1.57558 5.18479 1.73969 5.11085 1.92018C5.03691 2.10066 4.99932 2.29396 5.00024 2.489V4.1L3.92724 3.033L3.22124 3.739ZM9.89038 5.53277H9.90165C10.0838 5.84426 10.3524 6 10.7073 6C11.0998 6 11.4134 5.83236 11.6481 5.49708C11.8829 5.1618 12.0002 4.71728 12.0002 4.16353C12.0002 3.65304 11.8998 3.2507 11.6988 2.95652C11.4979 2.66234 11.2115 2.51525 10.8397 2.51525C10.434 2.51525 10.1214 2.70885 9.90165 3.09604H9.89038V1H9.00024V5.91888H9.89038V5.53277ZM9.8763 4.47177V4.13108C9.8763 3.88449 9.93452 3.6844 10.0509 3.53082C10.1693 3.37724 10.3176 3.30045 10.496 3.30045C10.6857 3.30045 10.8312 3.37833 10.9326 3.53407C11.0359 3.68765 11.0876 3.9018 11.0876 4.17651C11.0876 4.50746 11.0312 4.76379 10.9186 4.94549C10.8078 5.12503 10.6509 5.2148 10.4481 5.2148C10.281 5.2148 10.1439 5.14449 10.0369 5.00389C9.92982 4.86329 9.8763 4.68592 9.8763 4.47177ZM9.00024 12.7691C8.74457 12.923 8.37539 13 7.89272 13C7.3288 13 6.87241 12.8225 6.52354 12.4674C6.17468 12.1124 6.00024 11.6543 6.00024 11.0931C6.00024 10.4451 6.18662 9.93484 6.55938 9.5624C6.93453 9.18747 7.43513 9.00001 8.06118 9.00001C8.49367 9.00001 8.8067 9.0596 9.00024 9.17878V10.1769C8.76369 9.99319 8.49965 9.90132 8.20813 9.90132C7.88316 9.90132 7.62509 10.0006 7.43394 10.1993C7.24517 10.3954 7.15078 10.6673 7.15078 11.0149C7.15078 11.3526 7.24158 11.6183 7.42318 11.8119C7.60478 12.0031 7.85449 12.0987 8.17229 12.0987C8.45425 12.0987 8.73023 12.0068 9.00024 11.8231V12.7691ZM4.00024 7L3.00024 8V14L4.00024 15H11.0002L12.0002 14V8L11.0002 7H4.00024ZM4.00024 8H5.00024H10.0002H11.0002V9V13V14H10.0002H5.00024H4.00024V13V9V8Z&quot;
39:      fill=&quot;#424242&quot;
40:      id=&quot;path1&quot;
41:      style=&quot;fill:#ffffff&quot; /&gt;
42: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/replace.svg">1: &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
2: &lt;path fill-rule=&quot;evenodd&quot; clip-rule=&quot;evenodd&quot; d=&quot;M3.22124 3.739L5.48224 6.008L7.70024 3.784L7.00025 3.084L5.98824 4.091L5.98024 2.491C5.97934 2.35567 6.03093 2.22525 6.12417 2.12716C6.21741 2.02908 6.34504 1.97095 6.48024 1.965H8.00024V1H6.48024C6.2852 1.00026 6.09213 1.03902 5.9121 1.11405C5.73207 1.18908 5.56862 1.29892 5.43112 1.43725C5.29363 1.57558 5.18479 1.73969 5.11085 1.92018C5.03691 2.10066 4.99932 2.29396 5.00024 2.489V4.1L3.92724 3.033L3.22124 3.739ZM9.89038 5.53277H9.90165C10.0838 5.84426 10.3524 6 10.7073 6C11.0998 6 11.4134 5.83236 11.6481 5.49708C11.8829 5.1618 12.0002 4.71728 12.0002 4.16353C12.0002 3.65304 11.8998 3.2507 11.6988 2.95652C11.4979 2.66234 11.2115 2.51525 10.8397 2.51525C10.434 2.51525 10.1214 2.70885 9.90165 3.09604H9.89038V1H9.00024V5.91888H9.89038V5.53277ZM9.8763 4.47177V4.13108C9.8763 3.88449 9.93452 3.6844 10.0509 3.53082C10.1693 3.37724 10.3176 3.30045 10.496 3.30045C10.6857 3.30045 10.8312 3.37833 10.9326 3.53407C11.0359 3.68765 11.0876 3.9018 11.0876 4.17651C11.0876 4.50746 11.0312 4.76379 10.9186 4.94549C10.8078 5.12503 10.6509 5.2148 10.4481 5.2148C10.281 5.2148 10.1439 5.14449 10.0369 5.00389C9.92982 4.86329 9.8763 4.68592 9.8763 4.47177ZM9.00024 12.7691C8.74457 12.923 8.37539 13 7.89272 13C7.3288 13 6.87241 12.8225 6.52354 12.4674C6.17468 12.1124 6.00024 11.6543 6.00024 11.0931C6.00024 10.4451 6.18662 9.93484 6.55938 9.5624C6.93453 9.18747 7.43513 9.00001 8.06118 9.00001C8.49367 9.00001 8.8067 9.0596 9.00024 9.17878V10.1769C8.76369 9.99319 8.49965 9.90132 8.20813 9.90132C7.88316 9.90132 7.62509 10.0006 7.43394 10.1993C7.24517 10.3954 7.15078 10.6673 7.15078 11.0149C7.15078 11.3526 7.24158 11.6183 7.42318 11.8119C7.60478 12.0031 7.85449 12.0987 8.17229 12.0987C8.45425 12.0987 8.73023 12.0068 9.00024 11.8231V12.7691ZM4.00024 7L3.00024 8V14L4.00024 15H11.0002L12.0002 14V8L11.0002 7H4.00024ZM4.00024 8H5.00024H10.0002H11.0002V9V13V14H10.0002H5.00024H4.00024V13V9V8Z&quot; fill=&quot;#424242&quot;/&gt;
3: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/replaceall_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;16&quot;
 4:    height=&quot;16&quot;
 5:    viewBox=&quot;0 0 16 16&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;replaceall_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;0&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;74.125&quot;
27:      inkscape:cx=&quot;7.9932546&quot;
28:      inkscape:cy=&quot;8&quot;
29:      inkscape:window-width=&quot;2560&quot;
30:      inkscape:window-height=&quot;1389&quot;
31:      inkscape:window-x=&quot;0&quot;
32:      inkscape:window-y=&quot;27&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      fill-rule=&quot;evenodd&quot;
37:      clip-rule=&quot;evenodd&quot;
38:      d=&quot;M11.6012 2.67683C11.7477 2.36708 11.9561 2.2122 12.2265 2.2122C12.4744 2.2122 12.6653 2.32987 12.7993 2.56522C12.9333 2.80056 13.0002 3.12243 13.0002 3.53082C13.0002 3.97383 12.922 4.32944 12.7655 4.59766C12.609 4.86589 12.3999 5 12.1383 5C11.9017 5 11.7226 4.87541 11.6012 4.62622H11.5937V4.93511H11.0002V1H11.5937V2.67683H11.6012ZM11.5843 3.77742C11.5843 3.94873 11.62 4.09063 11.6913 4.20311C11.7627 4.3156 11.8541 4.37184 11.9655 4.37184C12.1007 4.37184 12.2053 4.30002 12.2791 4.15639C12.3542 4.01103 12.3918 3.80597 12.3918 3.54121C12.3918 3.32144 12.3574 3.15012 12.2885 3.02726C12.2209 2.90266 12.1239 2.84036 11.9974 2.84036C11.8785 2.84036 11.7796 2.9018 11.7007 3.02466C11.6231 3.14752 11.5843 3.30759 11.5843 3.50487V3.77742ZM4.11993 7.695L2.00024 5.56781L2.66212 4.90594L3.66806 5.90625V4.39594C3.66719 4.21309 3.70243 4.03187 3.77175 3.86266C3.84107 3.69346 3.9431 3.53961 4.07201 3.40992C4.20091 3.28023 4.35414 3.17727 4.52292 3.10692C4.6917 3.03658 4.87271 3.00024 5.05556 3H7.39931V3.90469H5.05556C4.9288 3.91026 4.80915 3.96476 4.72173 4.05672C4.63432 4.14868 4.58596 4.27094 4.58681 4.39781L4.59431 5.89781L5.54306 4.95375L6.19931 5.61L4.11993 7.695ZM9.35585 4.93017H10.0002V3.22067C10.0002 2.40689 9.68559 2 9.05628 2C8.92122 2 8.77108 2.02421 8.60585 2.07263C8.44205 2.12104 8.31274 2.17691 8.21792 2.24022V2.90503C8.45499 2.70205 8.70499 2.60056 8.96792 2.60056C9.22941 2.60056 9.36016 2.75698 9.36016 3.06983L8.76102 3.17318C8.25384 3.25885 8.00024 3.57914 8.00024 4.13408C8.00024 4.39665 8.06131 4.60708 8.18343 4.76536C8.307 4.92179 8.47582 5 8.6899 5C8.98013 5 9.19924 4.83985 9.34723 4.51955H9.35585V4.93017ZM9.36016 3.57542V3.76816C9.36016 3.9432 9.31993 4.08845 9.23947 4.20391C9.15901 4.3175 9.05484 4.3743 8.92697 4.3743C8.83501 4.3743 8.76174 4.34264 8.70714 4.27933C8.65398 4.21415 8.6274 4.13128 8.6274 4.03073C8.6274 3.80912 8.73803 3.6797 8.9593 3.64246L9.36016 3.57542ZM7.00024 12.9302H6.35585V12.5196H6.34723C6.19924 12.8399 5.98013 13 5.6899 13C5.47582 13 5.307 12.9218 5.18343 12.7654C5.06131 12.6071 5.00024 12.3966 5.00024 12.1341C5.00024 11.5791 5.25384 11.2588 5.76102 11.1732L6.36016 11.0698C6.36016 10.757 6.22941 10.6006 5.96792 10.6006C5.70499 10.6006 5.45499 10.702 5.21792 10.905V10.2402C5.31274 10.1769 5.44205 10.121 5.60585 10.0726C5.77108 10.0242 5.92122 10 6.05628 10C6.68559 10 7.00024 10.4069 7.00024 11.2207V12.9302ZM6.36016 11.7682V11.5754L5.9593 11.6425C5.73803 11.6797 5.6274 11.8091 5.6274 12.0307C5.6274 12.1313 5.65398 12.2142 5.70714 12.2793C5.76174 12.3426 5.83501 12.3743 5.92697 12.3743C6.05484 12.3743 6.15901 12.3175 6.23947 12.2039C6.31993 12.0885 6.36016 11.9432 6.36016 11.7682ZM9.26189 13C9.58368 13 9.82979 12.9423 10.0002 12.8268V12.1173C9.82024 12.2551 9.63625 12.324 9.44827 12.324C9.2364 12.324 9.06994 12.2523 8.94887 12.1089C8.8278 11.9637 8.76727 11.7644 8.76727 11.5112C8.76727 11.2505 8.83019 11.0466 8.95604 10.8994C9.08348 10.7505 9.25552 10.676 9.47217 10.676C9.66651 10.676 9.84254 10.7449 10.0002 10.8827V10.1341C9.87121 10.0447 9.66253 10 9.3742 10C8.95684 10 8.6231 10.1406 8.373 10.4218C8.1245 10.7011 8.00024 11.0838 8.00024 11.5698C8.00024 11.9907 8.11653 12.3343 8.34911 12.6006C8.58169 12.8669 8.88595 13 9.26189 13ZM2.00024 9L3.00024 8H12.0002L13.0002 9V14L12.0002 15H3.00024L2.00024 14V9ZM3.00024 9V14H12.0002V9H3.00024ZM6.00024 7L7.00024 6H14.0002L15.0002 7V12L14.0002 13V12V7H7.00024H6.00024Z&quot;
39:      fill=&quot;#424242&quot;
40:      id=&quot;path1&quot;
41:      style=&quot;fill:#ffffff&quot; /&gt;
42: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/replaceall.svg">1: &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
2: &lt;path fill-rule=&quot;evenodd&quot; clip-rule=&quot;evenodd&quot; d=&quot;M11.6012 2.67683C11.7477 2.36708 11.9561 2.2122 12.2265 2.2122C12.4744 2.2122 12.6653 2.32987 12.7993 2.56522C12.9333 2.80056 13.0002 3.12243 13.0002 3.53082C13.0002 3.97383 12.922 4.32944 12.7655 4.59766C12.609 4.86589 12.3999 5 12.1383 5C11.9017 5 11.7226 4.87541 11.6012 4.62622H11.5937V4.93511H11.0002V1H11.5937V2.67683H11.6012ZM11.5843 3.77742C11.5843 3.94873 11.62 4.09063 11.6913 4.20311C11.7627 4.3156 11.8541 4.37184 11.9655 4.37184C12.1007 4.37184 12.2053 4.30002 12.2791 4.15639C12.3542 4.01103 12.3918 3.80597 12.3918 3.54121C12.3918 3.32144 12.3574 3.15012 12.2885 3.02726C12.2209 2.90266 12.1239 2.84036 11.9974 2.84036C11.8785 2.84036 11.7796 2.9018 11.7007 3.02466C11.6231 3.14752 11.5843 3.30759 11.5843 3.50487V3.77742ZM4.11993 7.695L2.00024 5.56781L2.66212 4.90594L3.66806 5.90625V4.39594C3.66719 4.21309 3.70243 4.03187 3.77175 3.86266C3.84107 3.69346 3.9431 3.53961 4.07201 3.40992C4.20091 3.28023 4.35414 3.17727 4.52292 3.10692C4.6917 3.03658 4.87271 3.00024 5.05556 3H7.39931V3.90469H5.05556C4.9288 3.91026 4.80915 3.96476 4.72173 4.05672C4.63432 4.14868 4.58596 4.27094 4.58681 4.39781L4.59431 5.89781L5.54306 4.95375L6.19931 5.61L4.11993 7.695ZM9.35585 4.93017H10.0002V3.22067C10.0002 2.40689 9.68559 2 9.05628 2C8.92122 2 8.77108 2.02421 8.60585 2.07263C8.44205 2.12104 8.31274 2.17691 8.21792 2.24022V2.90503C8.45499 2.70205 8.70499 2.60056 8.96792 2.60056C9.22941 2.60056 9.36016 2.75698 9.36016 3.06983L8.76102 3.17318C8.25384 3.25885 8.00024 3.57914 8.00024 4.13408C8.00024 4.39665 8.06131 4.60708 8.18343 4.76536C8.307 4.92179 8.47582 5 8.6899 5C8.98013 5 9.19924 4.83985 9.34723 4.51955H9.35585V4.93017ZM9.36016 3.57542V3.76816C9.36016 3.9432 9.31993 4.08845 9.23947 4.20391C9.15901 4.3175 9.05484 4.3743 8.92697 4.3743C8.83501 4.3743 8.76174 4.34264 8.70714 4.27933C8.65398 4.21415 8.6274 4.13128 8.6274 4.03073C8.6274 3.80912 8.73803 3.6797 8.9593 3.64246L9.36016 3.57542ZM7.00024 12.9302H6.35585V12.5196H6.34723C6.19924 12.8399 5.98013 13 5.6899 13C5.47582 13 5.307 12.9218 5.18343 12.7654C5.06131 12.6071 5.00024 12.3966 5.00024 12.1341C5.00024 11.5791 5.25384 11.2588 5.76102 11.1732L6.36016 11.0698C6.36016 10.757 6.22941 10.6006 5.96792 10.6006C5.70499 10.6006 5.45499 10.702 5.21792 10.905V10.2402C5.31274 10.1769 5.44205 10.121 5.60585 10.0726C5.77108 10.0242 5.92122 10 6.05628 10C6.68559 10 7.00024 10.4069 7.00024 11.2207V12.9302ZM6.36016 11.7682V11.5754L5.9593 11.6425C5.73803 11.6797 5.6274 11.8091 5.6274 12.0307C5.6274 12.1313 5.65398 12.2142 5.70714 12.2793C5.76174 12.3426 5.83501 12.3743 5.92697 12.3743C6.05484 12.3743 6.15901 12.3175 6.23947 12.2039C6.31993 12.0885 6.36016 11.9432 6.36016 11.7682ZM9.26189 13C9.58368 13 9.82979 12.9423 10.0002 12.8268V12.1173C9.82024 12.2551 9.63625 12.324 9.44827 12.324C9.2364 12.324 9.06994 12.2523 8.94887 12.1089C8.8278 11.9637 8.76727 11.7644 8.76727 11.5112C8.76727 11.2505 8.83019 11.0466 8.95604 10.8994C9.08348 10.7505 9.25552 10.676 9.47217 10.676C9.66651 10.676 9.84254 10.7449 10.0002 10.8827V10.1341C9.87121 10.0447 9.66253 10 9.3742 10C8.95684 10 8.6231 10.1406 8.373 10.4218C8.1245 10.7011 8.00024 11.0838 8.00024 11.5698C8.00024 11.9907 8.11653 12.3343 8.34911 12.6006C8.58169 12.8669 8.88595 13 9.26189 13ZM2.00024 9L3.00024 8H12.0002L13.0002 9V14L12.0002 15H3.00024L2.00024 14V9ZM3.00024 9V14H12.0002V9H3.00024ZM6.00024 7L7.00024 6H14.0002L15.0002 7V12L14.0002 13V12V7H7.00024H6.00024Z&quot; fill=&quot;#424242&quot;/&gt;
3: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/run_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;16&quot;
 4:    height=&quot;16&quot;
 5:    viewBox=&quot;0 0 16 16&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;run_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;0&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;74.125&quot;
27:      inkscape:cx=&quot;7.9932546&quot;
28:      inkscape:cy=&quot;8&quot;
29:      inkscape:window-width=&quot;2560&quot;
30:      inkscape:window-height=&quot;1389&quot;
31:      inkscape:window-x=&quot;0&quot;
32:      inkscape:window-y=&quot;27&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      fill-rule=&quot;evenodd&quot;
37:      clip-rule=&quot;evenodd&quot;
38:      d=&quot;M4.00024 2V14.4805L12.9149 8.24024L4.00024 2ZM11.1812 8.24024L4.99524 12.5684V3.91209L11.1812 8.24024Z&quot;
39:      fill=&quot;#424242&quot;
40:      id=&quot;path1&quot;
41:      style=&quot;fill:#ffffff&quot; /&gt;
42: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/run.svg">1: &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
2: &lt;path fill-rule=&quot;evenodd&quot; clip-rule=&quot;evenodd&quot; d=&quot;M4.00024 2V14.4805L12.9149 8.24024L4.00024 2ZM11.1812 8.24024L4.99524 12.5684V3.91209L11.1812 8.24024Z&quot; fill=&quot;#424242&quot;/&gt;
3: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/search_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;24&quot;
 4:    height=&quot;24&quot;
 5:    viewBox=&quot;0 0 24 24&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;search_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;0&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;49.416667&quot;
27:      inkscape:cx=&quot;12.010118&quot;
28:      inkscape:cy=&quot;12&quot;
29:      inkscape:window-width=&quot;2560&quot;
30:      inkscape:window-height=&quot;1389&quot;
31:      inkscape:window-x=&quot;0&quot;
32:      inkscape:window-y=&quot;27&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      d=&quot;M15.2502 1.02546e-06C13.6607 -0.000791296 12.1048 0.457574 10.7697 1.32007C9.43447 2.18256 8.37681 3.4124 7.724 4.8617C7.07118 6.31099 6.85102 7.91801 7.08984 9.4895C7.32867 11.061 8.01628 12.5301 9.07019 13.72L1.00024 22.88L2.12024 23.88L10.1703 14.76C11.2057 15.5693 12.4195 16.1196 13.7106 16.365C15.0017 16.6104 16.3328 16.5437 17.5929 16.1707C18.853 15.7976 20.0058 15.1288 20.9552 14.2201C21.9046 13.3114 22.6232 12.1891 23.0511 10.9465C23.4791 9.70396 23.6041 8.37703 23.4155 7.07642C23.227 5.77581 22.7304 4.53915 21.9673 3.46924C21.2041 2.39933 20.1964 1.52711 19.0281 0.925416C17.8597 0.323719 16.5644 0.00991516 15.2502 0.0100108V1.02546e-06ZM15.2502 15C13.9152 15 12.6102 14.6041 11.5001 13.8624C10.3901 13.1207 9.52493 12.0665 9.01404 10.8331C8.50315 9.59973 8.36943 8.24248 8.62988 6.93311C8.89033 5.62373 9.53329 4.42106 10.4773 3.47705C11.4213 2.53305 12.624 1.89009 13.9333 1.62964C15.2427 1.36919 16.6 1.5029 17.8334 2.01379C19.0668 2.52469 20.121 3.38985 20.8627 4.49988C21.6044 5.60991 22.0002 6.91498 22.0002 8.25C22.0002 10.0402 21.2891 11.7571 20.0232 13.023C18.7573 14.2888 17.0405 15 15.2502 15Z&quot;
37:      fill=&quot;#424242&quot;
38:      id=&quot;path1&quot;
39:      style=&quot;fill:#ffffff&quot; /&gt;
40: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/search.svg">1: &lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
2: &lt;path d=&quot;M15.2502 1.02546e-06C13.6607 -0.000791296 12.1048 0.457574 10.7697 1.32007C9.43447 2.18256 8.37681 3.4124 7.724 4.8617C7.07118 6.31099 6.85102 7.91801 7.08984 9.4895C7.32867 11.061 8.01628 12.5301 9.07019 13.72L1.00024 22.88L2.12024 23.88L10.1703 14.76C11.2057 15.5693 12.4195 16.1196 13.7106 16.365C15.0017 16.6104 16.3328 16.5437 17.5929 16.1707C18.853 15.7976 20.0058 15.1288 20.9552 14.2201C21.9046 13.3114 22.6232 12.1891 23.0511 10.9465C23.4791 9.70396 23.6041 8.37703 23.4155 7.07642C23.227 5.77581 22.7304 4.53915 21.9673 3.46924C21.2041 2.39933 20.1964 1.52711 19.0281 0.925416C17.8597 0.323719 16.5644 0.00991516 15.2502 0.0100108V1.02546e-06ZM15.2502 15C13.9152 15 12.6102 14.6041 11.5001 13.8624C10.3901 13.1207 9.52493 12.0665 9.01404 10.8331C8.50315 9.59973 8.36943 8.24248 8.62988 6.93311C8.89033 5.62373 9.53329 4.42106 10.4773 3.47705C11.4213 2.53305 12.624 1.89009 13.9333 1.62964C15.2427 1.36919 16.6 1.5029 17.8334 2.01379C19.0668 2.52469 20.121 3.38985 20.8627 4.49988C21.6044 5.60991 22.0002 6.91498 22.0002 8.25C22.0002 10.0402 21.2891 11.7571 20.0232 13.023C18.7573 14.2888 17.0405 15 15.2502 15Z&quot; fill=&quot;#424242&quot;/&gt;
3: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/undo_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;16&quot;
 4:    height=&quot;16&quot;
 5:    viewBox=&quot;0 0 16 16&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;undo_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;0&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;74.125&quot;
27:      inkscape:cx=&quot;7.9932546&quot;
28:      inkscape:cy=&quot;8&quot;
29:      inkscape:window-width=&quot;2560&quot;
30:      inkscape:window-height=&quot;1389&quot;
31:      inkscape:window-x=&quot;0&quot;
32:      inkscape:window-y=&quot;27&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      fill-rule=&quot;evenodd&quot;
37:      clip-rule=&quot;evenodd&quot;
38:      d=&quot;M3.50024 2V5.5L4.00024 6H7.50024V5H4.97925L5.92065 4.05869C7.30786 2.67157 9.55688 2.67157 10.9436 4.05869C12.3308 5.4458 12.3308 7.69476 10.9436 9.08188L5.74585 14.2799L6.46606 14.9999L11.6638 9.80194C13.4485 8.01715 13.4485 5.12341 11.6638 3.33859C9.87915 1.5538 6.98511 1.5538 5.20044 3.33859L4.50024 4.03882V2H3.50024Z&quot;
39:      fill=&quot;#424242&quot;
40:      id=&quot;path1&quot;
41:      style=&quot;fill:#ffffff&quot; /&gt;
42: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/undo.svg">1: &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
2: &lt;path fill-rule=&quot;evenodd&quot; clip-rule=&quot;evenodd&quot; d=&quot;M3.50024 2V5.5L4.00024 6H7.50024V5H4.97925L5.92065 4.05869C7.30786 2.67157 9.55688 2.67157 10.9436 4.05869C12.3308 5.4458 12.3308 7.69476 10.9436 9.08188L5.74585 14.2799L6.46606 14.9999L11.6638 9.80194C13.4485 8.01715 13.4485 5.12341 11.6638 3.33859C9.87915 1.5538 6.98511 1.5538 5.20044 3.33859L4.50024 4.03882V2H3.50024Z&quot; fill=&quot;#424242&quot;/&gt;
3: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/zoomin_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;16&quot;
 4:    height=&quot;16&quot;
 5:    viewBox=&quot;0 0 16 16&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;zoomin_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;0&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;74.125&quot;
27:      inkscape:cx=&quot;7.9932546&quot;
28:      inkscape:cy=&quot;8&quot;
29:      inkscape:window-width=&quot;2560&quot;
30:      inkscape:window-height=&quot;1389&quot;
31:      inkscape:window-x=&quot;0&quot;
32:      inkscape:window-y=&quot;27&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      fill-rule=&quot;evenodd&quot;
37:      clip-rule=&quot;evenodd&quot;
38:      d=&quot;M12.0278 6.14861C12.1234 7.56649 11.6685 8.96661 10.7577 10.0575L15.0177 14.3176L14.3178 15.0275L10.0578 10.7575C8.96686 11.6682 7.56674 12.1231 6.14885 12.0275C4.73097 11.9319 3.40461 11.2931 2.44585 10.2442C1.48709 9.19523 0.969739 7.81691 1.00164 6.39617C1.03353 4.97542 1.61212 3.62162 2.61699 2.61675C3.62187 1.61188 4.97566 1.03329 6.39641 1.00139C7.81716 0.969494 9.19548 1.48684 10.2444 2.44561C11.2934 3.40437 11.9321 4.73072 12.0278 6.14861ZM6.57781 11.0375C7.77066 11.0354 8.91402 10.5608 9.75774 9.71758L9.71782 9.7376C10.145 9.32074 10.4851 8.82316 10.7186 8.27385C10.952 7.72455 11.0741 7.13437 11.0778 6.53752C11.0778 5.64751 10.8139 4.77755 10.3194 4.03752C9.82492 3.2975 9.12212 2.72065 8.29985 2.38005C7.47759 2.03946 6.57279 1.95032 5.69988 2.12395C4.82696 2.29758 4.02514 2.72618 3.3958 3.35552C2.76646 3.98485 2.33787 4.78668 2.16423 5.6596C1.9906 6.53251 2.07974 7.4373 2.42034 8.25957C2.76093 9.08184 3.33766 9.78464 4.07769 10.2791C4.81771 10.7736 5.68779 11.0375 6.57781 11.0375ZM9.01773 7.0376V6.0376H7.01773V4.0376H6.01773V6.0376H4.01773V7.0376H6.01773V9.0376H7.01773V7.0376H9.01773Z&quot;
39:      fill=&quot;#424242&quot;
40:      id=&quot;path1&quot;
41:      style=&quot;fill:#ffffff&quot; /&gt;
42: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/zoomin.svg">1: &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
2: &lt;path fill-rule=&quot;evenodd&quot; clip-rule=&quot;evenodd&quot; d=&quot;M12.0278 6.14861C12.1234 7.56649 11.6685 8.96661 10.7577 10.0575L15.0177 14.3176L14.3178 15.0275L10.0578 10.7575C8.96686 11.6682 7.56674 12.1231 6.14885 12.0275C4.73097 11.9319 3.40461 11.2931 2.44585 10.2442C1.48709 9.19523 0.969739 7.81691 1.00164 6.39617C1.03353 4.97542 1.61212 3.62162 2.61699 2.61675C3.62187 1.61188 4.97566 1.03329 6.39641 1.00139C7.81716 0.969494 9.19548 1.48684 10.2444 2.44561C11.2934 3.40437 11.9321 4.73072 12.0278 6.14861ZM6.57781 11.0375C7.77066 11.0354 8.91402 10.5608 9.75774 9.71758L9.71782 9.7376C10.145 9.32074 10.4851 8.82316 10.7186 8.27385C10.952 7.72455 11.0741 7.13437 11.0778 6.53752C11.0778 5.64751 10.8139 4.77755 10.3194 4.03752C9.82492 3.2975 9.12212 2.72065 8.29985 2.38005C7.47759 2.03946 6.57279 1.95032 5.69988 2.12395C4.82696 2.29758 4.02514 2.72618 3.3958 3.35552C2.76646 3.98485 2.33787 4.78668 2.16423 5.6596C1.9906 6.53251 2.07974 7.4373 2.42034 8.25957C2.76093 9.08184 3.33766 9.78464 4.07769 10.2791C4.81771 10.7736 5.68779 11.0375 6.57781 11.0375ZM9.01773 7.0376V6.0376H7.01773V4.0376H6.01773V6.0376H4.01773V7.0376H6.01773V9.0376H7.01773V7.0376H9.01773Z&quot; fill=&quot;#424242&quot;/&gt;
3: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/zoomout_dark.svg"> 1: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
 2: &lt;svg
 3:    width=&quot;16&quot;
 4:    height=&quot;16&quot;
 5:    viewBox=&quot;0 0 16 16&quot;
 6:    fill=&quot;none&quot;
 7:    version=&quot;1.1&quot;
 8:    id=&quot;svg1&quot;
 9:    sodipodi:docname=&quot;zoomout_dark.svg&quot;
10:    inkscape:version=&quot;1.4 (e7c3feb100, 2024-10-09)&quot;
11:    xmlns:inkscape=&quot;http://www.inkscape.org/namespaces/inkscape&quot;
12:    xmlns:sodipodi=&quot;http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd&quot;
13:    xmlns=&quot;http://www.w3.org/2000/svg&quot;
14:    xmlns:svg=&quot;http://www.w3.org/2000/svg&quot;&gt;
15:   &lt;defs
16:      id=&quot;defs1&quot; /&gt;
17:   &lt;sodipodi:namedview
18:      id=&quot;namedview1&quot;
19:      pagecolor=&quot;#ffffff&quot;
20:      bordercolor=&quot;#000000&quot;
21:      borderopacity=&quot;0.25&quot;
22:      inkscape:showpageshadow=&quot;2&quot;
23:      inkscape:pageopacity=&quot;0.0&quot;
24:      inkscape:pagecheckerboard=&quot;0&quot;
25:      inkscape:deskcolor=&quot;#d1d1d1&quot;
26:      inkscape:zoom=&quot;74.125&quot;
27:      inkscape:cx=&quot;7.9932546&quot;
28:      inkscape:cy=&quot;8&quot;
29:      inkscape:window-width=&quot;2560&quot;
30:      inkscape:window-height=&quot;1389&quot;
31:      inkscape:window-x=&quot;0&quot;
32:      inkscape:window-y=&quot;27&quot;
33:      inkscape:window-maximized=&quot;1&quot;
34:      inkscape:current-layer=&quot;svg1&quot; /&gt;
35:   &lt;path
36:      fill-rule=&quot;evenodd&quot;
37:      clip-rule=&quot;evenodd&quot;
38:      d=&quot;M12.0278 6.14861C12.1234 7.56649 11.6685 8.96661 10.7577 10.0575L15.0177 14.3176L14.3178 15.0275L10.0578 10.7575C8.96686 11.6682 7.56674 12.1231 6.14885 12.0275C4.73097 11.9319 3.40461 11.2931 2.44585 10.2442C1.48709 9.19523 0.969739 7.81691 1.00164 6.39617C1.03353 4.97542 1.61212 3.62162 2.61699 2.61675C3.62187 1.61188 4.97566 1.03329 6.39641 1.00139C7.81716 0.969494 9.19548 1.48684 10.2444 2.44561C11.2934 3.40437 11.9321 4.73072 12.0278 6.14861ZM6.57781 11.0375C7.77066 11.0354 8.91402 10.5608 9.75774 9.71758L9.71782 9.7376C10.145 9.32074 10.4851 8.82316 10.7186 8.27385C10.952 7.72455 11.0741 7.13437 11.0778 6.53752C11.0778 5.64751 10.8139 4.77755 10.3194 4.03752C9.82492 3.2975 9.12212 2.72065 8.29985 2.38005C7.47759 2.03946 6.57279 1.95032 5.69988 2.12395C4.82696 2.29758 4.02514 2.72618 3.3958 3.35552C2.76646 3.98485 2.33787 4.78668 2.16423 5.6596C1.9906 6.53251 2.07974 7.4373 2.42034 8.25957C2.76093 9.08184 3.33766 9.78464 4.07769 10.2791C4.81771 10.7736 5.68779 11.0375 6.57781 11.0375ZM4.03772 6.0575H9.03772V7.0575H4.03772V6.0575Z&quot;
39:      fill=&quot;#424242&quot;
40:      id=&quot;path1&quot;
41:      style=&quot;fill:#ffffff&quot; /&gt;
42: &lt;/svg&gt;</file><file path="TS/images/material/toolbar/zoomout.svg">1: &lt;svg width=&quot;16&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
2: &lt;path fill-rule=&quot;evenodd&quot; clip-rule=&quot;evenodd&quot; d=&quot;M12.0278 6.14861C12.1234 7.56649 11.6685 8.96661 10.7577 10.0575L15.0177 14.3176L14.3178 15.0275L10.0578 10.7575C8.96686 11.6682 7.56674 12.1231 6.14885 12.0275C4.73097 11.9319 3.40461 11.2931 2.44585 10.2442C1.48709 9.19523 0.969739 7.81691 1.00164 6.39617C1.03353 4.97542 1.61212 3.62162 2.61699 2.61675C3.62187 1.61188 4.97566 1.03329 6.39641 1.00139C7.81716 0.969494 9.19548 1.48684 10.2444 2.44561C11.2934 3.40437 11.9321 4.73072 12.0278 6.14861ZM6.57781 11.0375C7.77066 11.0354 8.91402 10.5608 9.75774 9.71758L9.71782 9.7376C10.145 9.32074 10.4851 8.82316 10.7186 8.27385C10.952 7.72455 11.0741 7.13437 11.0778 6.53752C11.0778 5.64751 10.8139 4.77755 10.3194 4.03752C9.82492 3.2975 9.12212 2.72065 8.29985 2.38005C7.47759 2.03946 6.57279 1.95032 5.69988 2.12395C4.82696 2.29758 4.02514 2.72618 3.3958 3.35552C2.76646 3.98485 2.33787 4.78668 2.16423 5.6596C1.9906 6.53251 2.07974 7.4373 2.42034 8.25957C2.76093 9.08184 3.33766 9.78464 4.07769 10.2791C4.81771 10.7736 5.68779 11.0375 6.57781 11.0375ZM4.03772 6.0575H9.03772V7.0575H4.03772V6.0575Z&quot; fill=&quot;#424242&quot;/&gt;
3: &lt;/svg&gt;</file><file path="TS/images/material/LICENSE.material">  1: Apache License
  2:                            Version 2.0, January 2004
  3:                         http://www.apache.org/licenses/
  4: 
  5:    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
  6: 
  7:    1. Definitions.
  8: 
  9:       &quot;License&quot; shall mean the terms and conditions for use, reproduction,
 10:       and distribution as defined by Sections 1 through 9 of this document.
 11: 
 12:       &quot;Licensor&quot; shall mean the copyright owner or entity authorized by
 13:       the copyright owner that is granting the License.
 14: 
 15:       &quot;Legal Entity&quot; shall mean the union of the acting entity and all
 16:       other entities that control, are controlled by, or are under common
 17:       control with that entity. For the purposes of this definition,
 18:       &quot;control&quot; means (i) the power, direct or indirect, to cause the
 19:       direction or management of such entity, whether by contract or
 20:       otherwise, or (ii) ownership of fifty percent (50%) or more of the
 21:       outstanding shares, or (iii) beneficial ownership of such entity.
 22: 
 23:       &quot;You&quot; (or &quot;Your&quot;) shall mean an individual or Legal Entity
 24:       exercising permissions granted by this License.
 25: 
 26:       &quot;Source&quot; form shall mean the preferred form for making modifications,
 27:       including but not limited to software source code, documentation
 28:       source, and configuration files.
 29: 
 30:       &quot;Object&quot; form shall mean any form resulting from mechanical
 31:       transformation or translation of a Source form, including but
 32:       not limited to compiled object code, generated documentation,
 33:       and conversions to other media types.
 34: 
 35:       &quot;Work&quot; shall mean the work of authorship, whether in Source or
 36:       Object form, made available under the License, as indicated by a
 37:       copyright notice that is included in or attached to the work
 38:       (an example is provided in the Appendix below).
 39: 
 40:       &quot;Derivative Works&quot; shall mean any work, whether in Source or Object
 41:       form, that is based on (or derived from) the Work and for which the
 42:       editorial revisions, annotations, elaborations, or other modifications
 43:       represent, as a whole, an original work of authorship. For the purposes
 44:       of this License, Derivative Works shall not include works that remain
 45:       separable from, or merely link (or bind by name) to the interfaces of,
 46:       the Work and Derivative Works thereof.
 47: 
 48:       &quot;Contribution&quot; shall mean any work of authorship, including
 49:       the original version of the Work and any modifications or additions
 50:       to that Work or Derivative Works thereof, that is intentionally
 51:       submitted to Licensor for inclusion in the Work by the copyright owner
 52:       or by an individual or Legal Entity authorized to submit on behalf of
 53:       the copyright owner. For the purposes of this definition, &quot;submitted&quot;
 54:       means any form of electronic, verbal, or written communication sent
 55:       to the Licensor or its representatives, including but not limited to
 56:       communication on electronic mailing lists, source code control systems,
 57:       and issue tracking systems that are managed by, or on behalf of, the
 58:       Licensor for the purpose of discussing and improving the Work, but
 59:       excluding communication that is conspicuously marked or otherwise
 60:       designated in writing by the copyright owner as &quot;Not a Contribution.&quot;
 61: 
 62:       &quot;Contributor&quot; shall mean Licensor and any individual or Legal Entity
 63:       on behalf of whom a Contribution has been received by Licensor and
 64:       subsequently incorporated within the Work.
 65: 
 66:    2. Grant of Copyright License. Subject to the terms and conditions of
 67:       this License, each Contributor hereby grants to You a perpetual,
 68:       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 69:       copyright license to reproduce, prepare Derivative Works of,
 70:       publicly display, publicly perform, sublicense, and distribute the
 71:       Work and such Derivative Works in Source or Object form.
 72: 
 73:    3. Grant of Patent License. Subject to the terms and conditions of
 74:       this License, each Contributor hereby grants to You a perpetual,
 75:       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
 76:       (except as stated in this section) patent license to make, have made,
 77:       use, offer to sell, sell, import, and otherwise transfer the Work,
 78:       where such license applies only to those patent claims licensable
 79:       by such Contributor that are necessarily infringed by their
 80:       Contribution(s) alone or by combination of their Contribution(s)
 81:       with the Work to which such Contribution(s) was submitted. If You
 82:       institute patent litigation against any entity (including a
 83:       cross-claim or counterclaim in a lawsuit) alleging that the Work
 84:       or a Contribution incorporated within the Work constitutes direct
 85:       or contributory patent infringement, then any patent licenses
 86:       granted to You under this License for that Work shall terminate
 87:       as of the date such litigation is filed.
 88: 
 89:    4. Redistribution. You may reproduce and distribute copies of the
 90:       Work or Derivative Works thereof in any medium, with or without
 91:       modifications, and in Source or Object form, provided that You
 92:       meet the following conditions:
 93: 
 94:       (a) You must give any other recipients of the Work or
 95:           Derivative Works a copy of this License; and
 96: 
 97:       (b) You must cause any modified files to carry prominent notices
 98:           stating that You changed the files; and
 99: 
100:       (c) You must retain, in the Source form of any Derivative Works
101:           that You distribute, all copyright, patent, trademark, and
102:           attribution notices from the Source form of the Work,
103:           excluding those notices that do not pertain to any part of
104:           the Derivative Works; and
105: 
106:       (d) If the Work includes a &quot;NOTICE&quot; text file as part of its
107:           distribution, then any Derivative Works that You distribute must
108:           include a readable copy of the attribution notices contained
109:           within such NOTICE file, excluding those notices that do not
110:           pertain to any part of the Derivative Works, in at least one
111:           of the following places: within a NOTICE text file distributed
112:           as part of the Derivative Works; within the Source form or
113:           documentation, if provided along with the Derivative Works; or,
114:           within a display generated by the Derivative Works, if and
115:           wherever such third-party notices normally appear. The contents
116:           of the NOTICE file are for informational purposes only and
117:           do not modify the License. You may add Your own attribution
118:           notices within Derivative Works that You distribute, alongside
119:           or as an addendum to the NOTICE text from the Work, provided
120:           that such additional attribution notices cannot be construed
121:           as modifying the License.
122: 
123:       You may add Your own copyright statement to Your modifications and
124:       may provide additional or different license terms and conditions
125:       for use, reproduction, or distribution of Your modifications, or
126:       for any such Derivative Works as a whole, provided Your use,
127:       reproduction, and distribution of the Work otherwise complies with
128:       the conditions stated in this License.
129: 
130:    5. Submission of Contributions. Unless You explicitly state otherwise,
131:       any Contribution intentionally submitted for inclusion in the Work
132:       by You to the Licensor shall be under the terms and conditions of
133:       this License, without any additional terms or conditions.
134:       Notwithstanding the above, nothing herein shall supersede or modify
135:       the terms of any separate license agreement you may have executed
136:       with Licensor regarding such Contributions.
137: 
138:    6. Trademarks. This License does not grant permission to use the trade
139:       names, trademarks, service marks, or product names of the Licensor,
140:       except as required for reasonable and customary use in describing the
141:       origin of the Work and reproducing the content of the NOTICE file.
142: 
143:    7. Disclaimer of Warranty. Unless required by applicable law or
144:       agreed to in writing, Licensor provides the Work (and each
145:       Contributor provides its Contributions) on an &quot;AS IS&quot; BASIS,
146:       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
147:       implied, including, without limitation, any warranties or conditions
148:       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
149:       PARTICULAR PURPOSE. You are solely responsible for determining the
150:       appropriateness of using or redistributing the Work and assume any
151:       risks associated with Your exercise of permissions under this License.
152: 
153:    8. Limitation of Liability. In no event and under no legal theory,
154:       whether in tort (including negligence), contract, or otherwise,
155:       unless required by applicable law (such as deliberate and grossly
156:       negligent acts) or agreed to in writing, shall any Contributor be
157:       liable to You for damages, including any direct, indirect, special,
158:       incidental, or consequential damages of any character arising as a
159:       result of this License or out of the use or inability to use the
160:       Work (including but not limited to damages for loss of goodwill,
161:       work stoppage, computer failure or malfunction, or any and all
162:       other commercial damages or losses), even if such Contributor
163:       has been advised of the possibility of such damages.
164: 
165:    9. Accepting Warranty or Additional Liability. While redistributing
166:       the Work or Derivative Works thereof, You may choose to offer,
167:       and charge a fee for, acceptance of support, warranty, indemnity,
168:       or other liability obligations and/or rights consistent with this
169:       License. However, in accepting such obligations, You may act only
170:       on Your own behalf and on Your sole responsibility, not on behalf
171:       of any other Contributor, and only if You agree to indemnify,
172:       defend, and hold each Contributor harmless for any liability
173:       incurred by, or claims asserted against, such Contributor by reason
174:       of your accepting any such warranty or additional liability.
175: 
176:    END OF TERMS AND CONDITIONS
177: 
178:    APPENDIX: How to apply the Apache License to your work.
179: 
180:       To apply the Apache License to your work, attach the following
181:       boilerplate notice, with the fields enclosed by brackets &quot;[]&quot;
182:       replaced with your own identifying information. (Don&apos;t include
183:       the brackets!)  The text should be enclosed in the appropriate
184:       comment syntax for the file format. We also recommend that a
185:       file or class name and description of purpose be included on the
186:       same &quot;printed page&quot; as the copyright notice for easier
187:       identification within third-party archives.
188: 
189:    Copyright [yyyy] [name of copyright owner]
190: 
191:    Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
192:    you may not use this file except in compliance with the License.
193:    You may obtain a copy of the License at
194: 
195:        http://www.apache.org/licenses/LICENSE-2.0
196: 
197:    Unless required by applicable law or agreed to in writing, software
198:    distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
199:    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
200:    See the License for the specific language governing permissions and
201:    limitations under the License.</file><file path="TS/images/material/LICENSE.vscode-icons">  1: The Licensed Material was created by Microsoft.
  2: 
  3: 
  4: --------------------------------------------------------------------------------
  5: Legal Notices
  6: 
  7: Microsoft and any contributors grant you a license to the Microsoft
  8: documentation and other content in this repository under the Creative Commons
  9: Attribution 4.0 International Public License, see the LICENSE file, and grant
 10: you a license to any code in the repository under the MIT License, see the
 11: LICENSE-CODE file.
 12: 
 13: Microsoft, Windows, Microsoft Azure and/or other Microsoft products and
 14: services referenced in the documentation may be either trademarks or registered
 15: trademarks of Microsoft in the United States and/or other countries.
 16: The licenses for this project do not grant you rights to use any Microsoft
 17: names, logos, or trademarks. Microsoft&apos;s general trademark guidelines can be
 18: found at http://go.microsoft.com/fwlink/?LinkID=254653.
 19: 
 20: Privacy information can be found at https://privacy.microsoft.com/en-us/
 21: 
 22: Microsoft and any contributors reserve all other rights, whether under their
 23: respective copyrights, patents, or trademarks, whether by implication, estoppel
 24: or otherwise.
 25: --------------------------------------------------------------------------------
 26: 
 27: 
 28: The Creative Commons Attribution 4.0 International license is available at
 29: https://creativecommons.org/licenses/by/4.0/
 30: 
 31: 
 32: Creative Commons gives no warranties regarding its licenses, any material
 33: licensed under their terms and conditions, or any related information.
 34: Creative Commons disclaims all liability for damages resulting from their use
 35: to the fullest extent possible.
 36: 
 37: 
 38: The Licensed Material was obtained from
 39: https://github.com/microsoft/vscode-icons
 40: 
 41: 
 42: Georger Arajo modified icons/light/clippy.svg for use in TreeSheets,
 43: and renamed it to editpaste.svg.
 44: 
 45: The following icons were used unmodified:
 46: run.svg
 47: search.svg
 48: replace.svg
 49: 
 50: The following icons were renamed and used unmodified:
 51: new-file.svg      -&gt; filenew.svg
 52: folder-opened.svg -&gt; fileopen.svg
 53: save.svg          -&gt; filesave.svg
 54: save-as.svg       -&gt; filesaveas.svg
 55: discard.svg       -&gt; undo.svg
 56: files.svg         -&gt; editcopy.svg
 57: zoom-in.svg       -&gt; zoomin.svg
 58: zoom-out.svg      -&gt; zoomout.svg
 59: search-stop.svg   -&gt; cancel.svg
 60: replaceall.svg    -&gt; replace-all.svg
 61: 
 62: 
 63: The icons mentioned in this notice are licensed under the
 64: Creative Commons Attribution 4.0 International license.
 65: 
 66: 
 67: Attribution 4.0 International
 68: 
 69: =======================================================================
 70: 
 71: Creative Commons Corporation (&quot;Creative Commons&quot;) is not a law firm and
 72: does not provide legal services or legal advice. Distribution of
 73: Creative Commons public licenses does not create a lawyer-client or
 74: other relationship. Creative Commons makes its licenses and related
 75: information available on an &quot;as-is&quot; basis. Creative Commons gives no
 76: warranties regarding its licenses, any material licensed under their
 77: terms and conditions, or any related information. Creative Commons
 78: disclaims all liability for damages resulting from their use to the
 79: fullest extent possible.
 80: 
 81: Using Creative Commons Public Licenses
 82: 
 83: Creative Commons public licenses provide a standard set of terms and
 84: conditions that creators and other rights holders may use to share
 85: original works of authorship and other material subject to copyright
 86: and certain other rights specified in the public license below. The
 87: following considerations are for informational purposes only, are not
 88: exhaustive, and do not form part of our licenses.
 89: 
 90:      Considerations for licensors: Our public licenses are
 91:      intended for use by those authorized to give the public
 92:      permission to use material in ways otherwise restricted by
 93:      copyright and certain other rights. Our licenses are
 94:      irrevocable. Licensors should read and understand the terms
 95:      and conditions of the license they choose before applying it.
 96:      Licensors should also secure all rights necessary before
 97:      applying our licenses so that the public can reuse the
 98:      material as expected. Licensors should clearly mark any
 99:      material not subject to the license. This includes other CC-
100:      licensed material, or material used under an exception or
101:      limitation to copyright. More considerations for licensors:
102: 	wiki.creativecommons.org/Considerations_for_licensors
103: 
104:      Considerations for the public: By using one of our public
105:      licenses, a licensor grants the public permission to use the
106:      licensed material under specified terms and conditions. If
107:      the licensor&apos;s permission is not necessary for any reason--for
108:      example, because of any applicable exception or limitation to
109:      copyright--then that use is not regulated by the license. Our
110:      licenses grant only permissions under copyright and certain
111:      other rights that a licensor has authority to grant. Use of
112:      the licensed material may still be restricted for other
113:      reasons, including because others have copyright or other
114:      rights in the material. A licensor may make special requests,
115:      such as asking that all changes be marked or described.
116:      Although not required by our licenses, you are encouraged to
117:      respect those requests where reasonable. More_considerations
118:      for the public: 
119: 	wiki.creativecommons.org/Considerations_for_licensees
120: 
121: =======================================================================
122: 
123: Creative Commons Attribution 4.0 International Public License
124: 
125: By exercising the Licensed Rights (defined below), You accept and agree
126: to be bound by the terms and conditions of this Creative Commons
127: Attribution 4.0 International Public License (&quot;Public License&quot;). To the
128: extent this Public License may be interpreted as a contract, You are
129: granted the Licensed Rights in consideration of Your acceptance of
130: these terms and conditions, and the Licensor grants You such rights in
131: consideration of benefits the Licensor receives from making the
132: Licensed Material available under these terms and conditions.
133: 
134: 
135: Section 1 -- Definitions.
136: 
137:   a. Adapted Material means material subject to Copyright and Similar
138:      Rights that is derived from or based upon the Licensed Material
139:      and in which the Licensed Material is translated, altered,
140:      arranged, transformed, or otherwise modified in a manner requiring
141:      permission under the Copyright and Similar Rights held by the
142:      Licensor. For purposes of this Public License, where the Licensed
143:      Material is a musical work, performance, or sound recording,
144:      Adapted Material is always produced where the Licensed Material is
145:      synched in timed relation with a moving image.
146: 
147:   b. Adapter&apos;s License means the license You apply to Your Copyright
148:      and Similar Rights in Your contributions to Adapted Material in
149:      accordance with the terms and conditions of this Public License.
150: 
151:   c. Copyright and Similar Rights means copyright and/or similar rights
152:      closely related to copyright including, without limitation,
153:      performance, broadcast, sound recording, and Sui Generis Database
154:      Rights, without regard to how the rights are labeled or
155:      categorized. For purposes of this Public License, the rights
156:      specified in Section 2(b)(1)-(2) are not Copyright and Similar
157:      Rights.
158: 
159:   d. Effective Technological Measures means those measures that, in the
160:      absence of proper authority, may not be circumvented under laws
161:      fulfilling obligations under Article 11 of the WIPO Copyright
162:      Treaty adopted on December 20, 1996, and/or similar international
163:      agreements.
164: 
165:   e. Exceptions and Limitations means fair use, fair dealing, and/or
166:      any other exception or limitation to Copyright and Similar Rights
167:      that applies to Your use of the Licensed Material.
168: 
169:   f. Licensed Material means the artistic or literary work, database,
170:      or other material to which the Licensor applied this Public
171:      License.
172: 
173:   g. Licensed Rights means the rights granted to You subject to the
174:      terms and conditions of this Public License, which are limited to
175:      all Copyright and Similar Rights that apply to Your use of the
176:      Licensed Material and that the Licensor has authority to license.
177: 
178:   h. Licensor means the individual(s) or entity(ies) granting rights
179:      under this Public License.
180: 
181:   i. Share means to provide material to the public by any means or
182:      process that requires permission under the Licensed Rights, such
183:      as reproduction, public display, public performance, distribution,
184:      dissemination, communication, or importation, and to make material
185:      available to the public including in ways that members of the
186:      public may access the material from a place and at a time
187:      individually chosen by them.
188: 
189:   j. Sui Generis Database Rights means rights other than copyright
190:      resulting from Directive 96/9/EC of the European Parliament and of
191:      the Council of 11 March 1996 on the legal protection of databases,
192:      as amended and/or succeeded, as well as other essentially
193:      equivalent rights anywhere in the world.
194: 
195:   k. You means the individual or entity exercising the Licensed Rights
196:      under this Public License. Your has a corresponding meaning.
197: 
198: 
199: Section 2 -- Scope.
200: 
201:   a. License grant.
202: 
203:        1. Subject to the terms and conditions of this Public License,
204:           the Licensor hereby grants You a worldwide, royalty-free,
205:           non-sublicensable, non-exclusive, irrevocable license to
206:           exercise the Licensed Rights in the Licensed Material to:
207: 
208:             a. reproduce and Share the Licensed Material, in whole or
209:                in part; and
210: 
211:             b. produce, reproduce, and Share Adapted Material.
212: 
213:        2. Exceptions and Limitations. For the avoidance of doubt, where
214:           Exceptions and Limitations apply to Your use, this Public
215:           License does not apply, and You do not need to comply with
216:           its terms and conditions.
217: 
218:        3. Term. The term of this Public License is specified in Section
219:           6(a).
220: 
221:        4. Media and formats; technical modifications allowed. The
222:           Licensor authorizes You to exercise the Licensed Rights in
223:           all media and formats whether now known or hereafter created,
224:           and to make technical modifications necessary to do so. The
225:           Licensor waives and/or agrees not to assert any right or
226:           authority to forbid You from making technical modifications
227:           necessary to exercise the Licensed Rights, including
228:           technical modifications necessary to circumvent Effective
229:           Technological Measures. For purposes of this Public License,
230:           simply making modifications authorized by this Section 2(a)
231:           (4) never produces Adapted Material.
232: 
233:        5. Downstream recipients.
234: 
235:             a. Offer from the Licensor -- Licensed Material. Every
236:                recipient of the Licensed Material automatically
237:                receives an offer from the Licensor to exercise the
238:                Licensed Rights under the terms and conditions of this
239:                Public License.
240: 
241:             b. No downstream restrictions. You may not offer or impose
242:                any additional or different terms or conditions on, or
243:                apply any Effective Technological Measures to, the
244:                Licensed Material if doing so restricts exercise of the
245:                Licensed Rights by any recipient of the Licensed
246:                Material.
247: 
248:        6. No endorsement. Nothing in this Public License constitutes or
249:           may be construed as permission to assert or imply that You
250:           are, or that Your use of the Licensed Material is, connected
251:           with, or sponsored, endorsed, or granted official status by,
252:           the Licensor or others designated to receive attribution as
253:           provided in Section 3(a)(1)(A)(i).
254: 
255:   b. Other rights.
256: 
257:        1. Moral rights, such as the right of integrity, are not
258:           licensed under this Public License, nor are publicity,
259:           privacy, and/or other similar personality rights; however, to
260:           the extent possible, the Licensor waives and/or agrees not to
261:           assert any such rights held by the Licensor to the limited
262:           extent necessary to allow You to exercise the Licensed
263:           Rights, but not otherwise.
264: 
265:        2. Patent and trademark rights are not licensed under this
266:           Public License.
267: 
268:        3. To the extent possible, the Licensor waives any right to
269:           collect royalties from You for the exercise of the Licensed
270:           Rights, whether directly or through a collecting society
271:           under any voluntary or waivable statutory or compulsory
272:           licensing scheme. In all other cases the Licensor expressly
273:           reserves any right to collect such royalties.
274: 
275: 
276: Section 3 -- License Conditions.
277: 
278: Your exercise of the Licensed Rights is expressly made subject to the
279: following conditions.
280: 
281:   a. Attribution.
282: 
283:        1. If You Share the Licensed Material (including in modified
284:           form), You must:
285: 
286:             a. retain the following if it is supplied by the Licensor
287:                with the Licensed Material:
288: 
289:                  i. identification of the creator(s) of the Licensed
290:                     Material and any others designated to receive
291:                     attribution, in any reasonable manner requested by
292:                     the Licensor (including by pseudonym if
293:                     designated);
294: 
295:                 ii. a copyright notice;
296: 
297:                iii. a notice that refers to this Public License;
298: 
299:                 iv. a notice that refers to the disclaimer of
300:                     warranties;
301: 
302:                  v. a URI or hyperlink to the Licensed Material to the
303:                     extent reasonably practicable;
304: 
305:             b. indicate if You modified the Licensed Material and
306:                retain an indication of any previous modifications; and
307: 
308:             c. indicate the Licensed Material is licensed under this
309:                Public License, and include the text of, or the URI or
310:                hyperlink to, this Public License.
311: 
312:        2. You may satisfy the conditions in Section 3(a)(1) in any
313:           reasonable manner based on the medium, means, and context in
314:           which You Share the Licensed Material. For example, it may be
315:           reasonable to satisfy the conditions by providing a URI or
316:           hyperlink to a resource that includes the required
317:           information.
318: 
319:        3. If requested by the Licensor, You must remove any of the
320:           information required by Section 3(a)(1)(A) to the extent
321:           reasonably practicable.
322: 
323:        4. If You Share Adapted Material You produce, the Adapter&apos;s
324:           License You apply must not prevent recipients of the Adapted
325:           Material from complying with this Public License.
326: 
327: 
328: Section 4 -- Sui Generis Database Rights.
329: 
330: Where the Licensed Rights include Sui Generis Database Rights that
331: apply to Your use of the Licensed Material:
332: 
333:   a. for the avoidance of doubt, Section 2(a)(1) grants You the right
334:      to extract, reuse, reproduce, and Share all or a substantial
335:      portion of the contents of the database;
336: 
337:   b. if You include all or a substantial portion of the database
338:      contents in a database in which You have Sui Generis Database
339:      Rights, then the database in which You have Sui Generis Database
340:      Rights (but not its individual contents) is Adapted Material; and
341: 
342:   c. You must comply with the conditions in Section 3(a) if You Share
343:      all or a substantial portion of the contents of the database.
344: 
345: For the avoidance of doubt, this Section 4 supplements and does not
346: replace Your obligations under this Public License where the Licensed
347: Rights include other Copyright and Similar Rights.
348: 
349: 
350: Section 5 -- Disclaimer of Warranties and Limitation of Liability.
351: 
352:   a. UNLESS OTHERWISE SEPARATELY UNDERTAKEN BY THE LICENSOR, TO THE
353:      EXTENT POSSIBLE, THE LICENSOR OFFERS THE LICENSED MATERIAL AS-IS
354:      AND AS-AVAILABLE, AND MAKES NO REPRESENTATIONS OR WARRANTIES OF
355:      ANY KIND CONCERNING THE LICENSED MATERIAL, WHETHER EXPRESS,
356:      IMPLIED, STATUTORY, OR OTHER. THIS INCLUDES, WITHOUT LIMITATION,
357:      WARRANTIES OF TITLE, MERCHANTABILITY, FITNESS FOR A PARTICULAR
358:      PURPOSE, NON-INFRINGEMENT, ABSENCE OF LATENT OR OTHER DEFECTS,
359:      ACCURACY, OR THE PRESENCE OR ABSENCE OF ERRORS, WHETHER OR NOT
360:      KNOWN OR DISCOVERABLE. WHERE DISCLAIMERS OF WARRANTIES ARE NOT
361:      ALLOWED IN FULL OR IN PART, THIS DISCLAIMER MAY NOT APPLY TO YOU.
362: 
363:   b. TO THE EXTENT POSSIBLE, IN NO EVENT WILL THE LICENSOR BE LIABLE
364:      TO YOU ON ANY LEGAL THEORY (INCLUDING, WITHOUT LIMITATION,
365:      NEGLIGENCE) OR OTHERWISE FOR ANY DIRECT, SPECIAL, INDIRECT,
366:      INCIDENTAL, CONSEQUENTIAL, PUNITIVE, EXEMPLARY, OR OTHER LOSSES,
367:      COSTS, EXPENSES, OR DAMAGES ARISING OUT OF THIS PUBLIC LICENSE OR
368:      USE OF THE LICENSED MATERIAL, EVEN IF THE LICENSOR HAS BEEN
369:      ADVISED OF THE POSSIBILITY OF SUCH LOSSES, COSTS, EXPENSES, OR
370:      DAMAGES. WHERE A LIMITATION OF LIABILITY IS NOT ALLOWED IN FULL OR
371:      IN PART, THIS LIMITATION MAY NOT APPLY TO YOU.
372: 
373:   c. The disclaimer of warranties and limitation of liability provided
374:      above shall be interpreted in a manner that, to the extent
375:      possible, most closely approximates an absolute disclaimer and
376:      waiver of all liability.
377: 
378: 
379: Section 6 -- Term and Termination.
380: 
381:   a. This Public License applies for the term of the Copyright and
382:      Similar Rights licensed here. However, if You fail to comply with
383:      this Public License, then Your rights under this Public License
384:      terminate automatically.
385: 
386:   b. Where Your right to use the Licensed Material has terminated under
387:      Section 6(a), it reinstates:
388: 
389:        1. automatically as of the date the violation is cured, provided
390:           it is cured within 30 days of Your discovery of the
391:           violation; or
392: 
393:        2. upon express reinstatement by the Licensor.
394: 
395:      For the avoidance of doubt, this Section 6(b) does not affect any
396:      right the Licensor may have to seek remedies for Your violations
397:      of this Public License.
398: 
399:   c. For the avoidance of doubt, the Licensor may also offer the
400:      Licensed Material under separate terms or conditions or stop
401:      distributing the Licensed Material at any time; however, doing so
402:      will not terminate this Public License.
403: 
404:   d. Sections 1, 5, 6, 7, and 8 survive termination of this Public
405:      License.
406: 
407: 
408: Section 7 -- Other Terms and Conditions.
409: 
410:   a. The Licensor shall not be bound by any additional or different
411:      terms or conditions communicated by You unless expressly agreed.
412: 
413:   b. Any arrangements, understandings, or agreements regarding the
414:      Licensed Material not stated herein are separate from and
415:      independent of the terms and conditions of this Public License.
416: 
417: 
418: Section 8 -- Interpretation.
419: 
420:   a. For the avoidance of doubt, this Public License does not, and
421:      shall not be interpreted to, reduce, limit, restrict, or impose
422:      conditions on any use of the Licensed Material that could lawfully
423:      be made without permission under this Public License.
424: 
425:   b. To the extent possible, if any provision of this Public License is
426:      deemed unenforceable, it shall be automatically reformed to the
427:      minimum extent necessary to make it enforceable. If the provision
428:      cannot be reformed, it shall be severed from this Public License
429:      without affecting the enforceability of the remaining terms and
430:      conditions.
431: 
432:   c. No term or condition of this Public License will be waived and no
433:      failure to comply consented to unless expressly agreed to by the
434:      Licensor.
435: 
436:   d. Nothing in this Public License constitutes or may be interpreted
437:      as a limitation upon, or waiver of, any privileges and immunities
438:      that apply to the Licensor or You, including from the legal
439:      processes of any jurisdiction or authority.
440: 
441: 
442: =======================================================================
443: 
444: Creative Commons is not a party to its public
445: licenses. Notwithstanding, Creative Commons may elect to apply one of
446: its public licenses to material it publishes and in those instances
447: will be considered the Licensor. The text of the Creative Commons
448: public licenses is dedicated to the public domain under the CC0 Public
449: Domain Dedication. Except for the limited purpose of indicating that
450: material is shared under a Creative Commons public license or as
451: otherwise permitted by the Creative Commons policies published at
452: creativecommons.org/policies, Creative Commons does not authorize the
453: use of the trademark &quot;Creative Commons&quot; or any other trademark or logo
454: of Creative Commons without its prior written consent including,
455: without limitation, in connection with any unauthorized modifications
456: to any of its public licenses or any other arrangements,
457: understandings, or agreements concerning use of licensed material. For
458: the avoidance of doubt, this paragraph does not form part of the
459: public licenses.
460: 
461: Creative Commons may be contacted at creativecommons.org.</file><file path="TS/images/nuvola/author">1: David Vignoni (david@icon-king.com)
2: ICON KING - www.icon-king.com</file><file path="TS/images/nuvola/license.txt">  1: GNU LESSER GENERAL PUBLIC LICENSE
  2: 		       Version 2.1, February 1999
  3: 
  4:  Copyright (C) 1991, 1999 Free Software Foundation, Inc.
  5:      51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  6:  Everyone is permitted to copy and distribute verbatim copies
  7:  of this license document, but changing it is not allowed.
  8: 
  9: [This is the first released version of the Lesser GPL.  It also counts
 10:  as the successor of the GNU Library Public License, version 2, hence
 11:  the version number 2.1.]
 12: 
 13: 			    Preamble
 14: 
 15:   The licenses for most software are designed to take away your
 16: freedom to share and change it.  By contrast, the GNU General Public
 17: Licenses are intended to guarantee your freedom to share and change
 18: free software--to make sure the software is free for all its users.
 19: 
 20:   This license, the Lesser General Public License, applies to some
 21: specially designated software packages--typically libraries--of the
 22: Free Software Foundation and other authors who decide to use it.  You
 23: can use it too, but we suggest you first think carefully about whether
 24: this license or the ordinary General Public License is the better
 25: strategy to use in any particular case, based on the explanations below.
 26: 
 27:   When we speak of free software, we are referring to freedom of use,
 28: not price.  Our General Public Licenses are designed to make sure that
 29: you have the freedom to distribute copies of free software (and charge
 30: for this service if you wish); that you receive source code or can get
 31: it if you want it; that you can change the software and use pieces of
 32: it in new free programs; and that you are informed that you can do
 33: these things.
 34: 
 35:   To protect your rights, we need to make restrictions that forbid
 36: distributors to deny you these rights or to ask you to surrender these
 37: rights.  These restrictions translate to certain responsibilities for
 38: you if you distribute copies of the library or if you modify it.
 39: 
 40:   For example, if you distribute copies of the library, whether gratis
 41: or for a fee, you must give the recipients all the rights that we gave
 42: you.  You must make sure that they, too, receive or can get the source
 43: code.  If you link other code with the library, you must provide
 44: complete object files to the recipients, so that they can relink them
 45: with the library after making changes to the library and recompiling
 46: it.  And you must show them these terms so they know their rights.
 47: 
 48:   We protect your rights with a two-step method: (1) we copyright the
 49: library, and (2) we offer you this license, which gives you legal
 50: permission to copy, distribute and/or modify the library.
 51: 
 52:   To protect each distributor, we want to make it very clear that
 53: there is no warranty for the free library.  Also, if the library is
 54: modified by someone else and passed on, the recipients should know
 55: that what they have is not the original version, so that the original
 56: author&apos;s reputation will not be affected by problems that might be
 57: introduced by others.
 58: 
 59:   Finally, software patents pose a constant threat to the existence of
 60: any free program.  We wish to make sure that a company cannot
 61: effectively restrict the users of a free program by obtaining a
 62: restrictive license from a patent holder.  Therefore, we insist that
 63: any patent license obtained for a version of the library must be
 64: consistent with the full freedom of use specified in this license.
 65: 
 66:   Most GNU software, including some libraries, is covered by the
 67: ordinary GNU General Public License.  This license, the GNU Lesser
 68: General Public License, applies to certain designated libraries, and
 69: is quite different from the ordinary General Public License.  We use
 70: this license for certain libraries in order to permit linking those
 71: libraries into non-free programs.
 72: 
 73:   When a program is linked with a library, whether statically or using
 74: a shared library, the combination of the two is legally speaking a
 75: combined work, a derivative of the original library.  The ordinary
 76: General Public License therefore permits such linking only if the
 77: entire combination fits its criteria of freedom.  The Lesser General
 78: Public License permits more lax criteria for linking other code with
 79: the library.
 80: 
 81:   We call this license the &quot;Lesser&quot; General Public License because it
 82: does Less to protect the user&apos;s freedom than the ordinary General
 83: Public License.  It also provides other free software developers Less
 84: of an advantage over competing non-free programs.  These disadvantages
 85: are the reason we use the ordinary General Public License for many
 86: libraries.  However, the Lesser license provides advantages in certain
 87: special circumstances.
 88: 
 89:   For example, on rare occasions, there may be a special need to
 90: encourage the widest possible use of a certain library, so that it becomes
 91: a de-facto standard.  To achieve this, non-free programs must be
 92: allowed to use the library.  A more frequent case is that a free
 93: library does the same job as widely used non-free libraries.  In this
 94: case, there is little to gain by limiting the free library to free
 95: software only, so we use the Lesser General Public License.
 96: 
 97:   In other cases, permission to use a particular library in non-free
 98: programs enables a greater number of people to use a large body of
 99: free software.  For example, permission to use the GNU C Library in
100: non-free programs enables many more people to use the whole GNU
101: operating system, as well as its variant, the GNU/Linux operating
102: system.
103: 
104:   Although the Lesser General Public License is Less protective of the
105: users&apos; freedom, it does ensure that the user of a program that is
106: linked with the Library has the freedom and the wherewithal to run
107: that program using a modified version of the Library.
108: 
109:   The precise terms and conditions for copying, distribution and
110: modification follow.  Pay close attention to the difference between a
111: &quot;work based on the library&quot; and a &quot;work that uses the library&quot;.  The
112: former contains code derived from the library, whereas the latter must
113: be combined with the library in order to run.
114: 
115: 		  GNU LESSER GENERAL PUBLIC LICENSE
116:    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
117: 
118:   0. This License Agreement applies to any software library or other
119: program which contains a notice placed by the copyright holder or
120: other authorized party saying it may be distributed under the terms of
121: this Lesser General Public License (also called &quot;this License&quot;).
122: Each licensee is addressed as &quot;you&quot;.
123: 
124:   A &quot;library&quot; means a collection of software functions and/or data
125: prepared so as to be conveniently linked with application programs
126: (which use some of those functions and data) to form executables.
127: 
128:   The &quot;Library&quot;, below, refers to any such software library or work
129: which has been distributed under these terms.  A &quot;work based on the
130: Library&quot; means either the Library or any derivative work under
131: copyright law: that is to say, a work containing the Library or a
132: portion of it, either verbatim or with modifications and/or translated
133: straightforwardly into another language.  (Hereinafter, translation is
134: included without limitation in the term &quot;modification&quot;.)
135: 
136:   &quot;Source code&quot; for a work means the preferred form of the work for
137: making modifications to it.  For a library, complete source code means
138: all the source code for all modules it contains, plus any associated
139: interface definition files, plus the scripts used to control compilation
140: and installation of the library.
141: 
142:   Activities other than copying, distribution and modification are not
143: covered by this License; they are outside its scope.  The act of
144: running a program using the Library is not restricted, and output from
145: such a program is covered only if its contents constitute a work based
146: on the Library (independent of the use of the Library in a tool for
147: writing it).  Whether that is true depends on what the Library does
148: and what the program that uses the Library does.
149:   
150:   1. You may copy and distribute verbatim copies of the Library&apos;s
151: complete source code as you receive it, in any medium, provided that
152: you conspicuously and appropriately publish on each copy an
153: appropriate copyright notice and disclaimer of warranty; keep intact
154: all the notices that refer to this License and to the absence of any
155: warranty; and distribute a copy of this License along with the
156: Library.
157: 
158:   You may charge a fee for the physical act of transferring a copy,
159: and you may at your option offer warranty protection in exchange for a
160: fee.
161: 
162:   2. You may modify your copy or copies of the Library or any portion
163: of it, thus forming a work based on the Library, and copy and
164: distribute such modifications or work under the terms of Section 1
165: above, provided that you also meet all of these conditions:
166: 
167:     a) The modified work must itself be a software library.
168: 
169:     b) You must cause the files modified to carry prominent notices
170:     stating that you changed the files and the date of any change.
171: 
172:     c) You must cause the whole of the work to be licensed at no
173:     charge to all third parties under the terms of this License.
174: 
175:     d) If a facility in the modified Library refers to a function or a
176:     table of data to be supplied by an application program that uses
177:     the facility, other than as an argument passed when the facility
178:     is invoked, then you must make a good faith effort to ensure that,
179:     in the event an application does not supply such function or
180:     table, the facility still operates, and performs whatever part of
181:     its purpose remains meaningful.
182: 
183:     (For example, a function in a library to compute square roots has
184:     a purpose that is entirely well-defined independent of the
185:     application.  Therefore, Subsection 2d requires that any
186:     application-supplied function or table used by this function must
187:     be optional: if the application does not supply it, the square
188:     root function must still compute square roots.)
189: 
190: These requirements apply to the modified work as a whole.  If
191: identifiable sections of that work are not derived from the Library,
192: and can be reasonably considered independent and separate works in
193: themselves, then this License, and its terms, do not apply to those
194: sections when you distribute them as separate works.  But when you
195: distribute the same sections as part of a whole which is a work based
196: on the Library, the distribution of the whole must be on the terms of
197: this License, whose permissions for other licensees extend to the
198: entire whole, and thus to each and every part regardless of who wrote
199: it.
200: 
201: Thus, it is not the intent of this section to claim rights or contest
202: your rights to work written entirely by you; rather, the intent is to
203: exercise the right to control the distribution of derivative or
204: collective works based on the Library.
205: 
206: In addition, mere aggregation of another work not based on the Library
207: with the Library (or with a work based on the Library) on a volume of
208: a storage or distribution medium does not bring the other work under
209: the scope of this License.
210: 
211:   3. You may opt to apply the terms of the ordinary GNU General Public
212: License instead of this License to a given copy of the Library.  To do
213: this, you must alter all the notices that refer to this License, so
214: that they refer to the ordinary GNU General Public License, version 2,
215: instead of to this License.  (If a newer version than version 2 of the
216: ordinary GNU General Public License has appeared, then you can specify
217: that version instead if you wish.)  Do not make any other change in
218: these notices.
219: 
220:   Once this change is made in a given copy, it is irreversible for
221: that copy, so the ordinary GNU General Public License applies to all
222: subsequent copies and derivative works made from that copy.
223: 
224:   This option is useful when you wish to copy part of the code of
225: the Library into a program that is not a library.
226: 
227:   4. You may copy and distribute the Library (or a portion or
228: derivative of it, under Section 2) in object code or executable form
229: under the terms of Sections 1 and 2 above provided that you accompany
230: it with the complete corresponding machine-readable source code, which
231: must be distributed under the terms of Sections 1 and 2 above on a
232: medium customarily used for software interchange.
233: 
234:   If distribution of object code is made by offering access to copy
235: from a designated place, then offering equivalent access to copy the
236: source code from the same place satisfies the requirement to
237: distribute the source code, even though third parties are not
238: compelled to copy the source along with the object code.
239: 
240:   5. A program that contains no derivative of any portion of the
241: Library, but is designed to work with the Library by being compiled or
242: linked with it, is called a &quot;work that uses the Library&quot;.  Such a
243: work, in isolation, is not a derivative work of the Library, and
244: therefore falls outside the scope of this License.
245: 
246:   However, linking a &quot;work that uses the Library&quot; with the Library
247: creates an executable that is a derivative of the Library (because it
248: contains portions of the Library), rather than a &quot;work that uses the
249: library&quot;.  The executable is therefore covered by this License.
250: Section 6 states terms for distribution of such executables.
251: 
252:   When a &quot;work that uses the Library&quot; uses material from a header file
253: that is part of the Library, the object code for the work may be a
254: derivative work of the Library even though the source code is not.
255: Whether this is true is especially significant if the work can be
256: linked without the Library, or if the work is itself a library.  The
257: threshold for this to be true is not precisely defined by law.
258: 
259:   If such an object file uses only numerical parameters, data
260: structure layouts and accessors, and small macros and small inline
261: functions (ten lines or less in length), then the use of the object
262: file is unrestricted, regardless of whether it is legally a derivative
263: work.  (Executables containing this object code plus portions of the
264: Library will still fall under Section 6.)
265: 
266:   Otherwise, if the work is a derivative of the Library, you may
267: distribute the object code for the work under the terms of Section 6.
268: Any executables containing that work also fall under Section 6,
269: whether or not they are linked directly with the Library itself.
270: 
271:   6. As an exception to the Sections above, you may also combine or
272: link a &quot;work that uses the Library&quot; with the Library to produce a
273: work containing portions of the Library, and distribute that work
274: under terms of your choice, provided that the terms permit
275: modification of the work for the customer&apos;s own use and reverse
276: engineering for debugging such modifications.
277: 
278:   You must give prominent notice with each copy of the work that the
279: Library is used in it and that the Library and its use are covered by
280: this License.  You must supply a copy of this License.  If the work
281: during execution displays copyright notices, you must include the
282: copyright notice for the Library among them, as well as a reference
283: directing the user to the copy of this License.  Also, you must do one
284: of these things:
285: 
286:     a) Accompany the work with the complete corresponding
287:     machine-readable source code for the Library including whatever
288:     changes were used in the work (which must be distributed under
289:     Sections 1 and 2 above); and, if the work is an executable linked
290:     with the Library, with the complete machine-readable &quot;work that
291:     uses the Library&quot;, as object code and/or source code, so that the
292:     user can modify the Library and then relink to produce a modified
293:     executable containing the modified Library.  (It is understood
294:     that the user who changes the contents of definitions files in the
295:     Library will not necessarily be able to recompile the application
296:     to use the modified definitions.)
297: 
298:     b) Use a suitable shared library mechanism for linking with the
299:     Library.  A suitable mechanism is one that (1) uses at run time a
300:     copy of the library already present on the user&apos;s computer system,
301:     rather than copying library functions into the executable, and (2)
302:     will operate properly with a modified version of the library, if
303:     the user installs one, as long as the modified version is
304:     interface-compatible with the version that the work was made with.
305: 
306:     c) Accompany the work with a written offer, valid for at
307:     least three years, to give the same user the materials
308:     specified in Subsection 6a, above, for a charge no more
309:     than the cost of performing this distribution.
310: 
311:     d) If distribution of the work is made by offering access to copy
312:     from a designated place, offer equivalent access to copy the above
313:     specified materials from the same place.
314: 
315:     e) Verify that the user has already received a copy of these
316:     materials or that you have already sent this user a copy.
317: 
318:   For an executable, the required form of the &quot;work that uses the
319: Library&quot; must include any data and utility programs needed for
320: reproducing the executable from it.  However, as a special exception,
321: the materials to be distributed need not include anything that is
322: normally distributed (in either source or binary form) with the major
323: components (compiler, kernel, and so on) of the operating system on
324: which the executable runs, unless that component itself accompanies
325: the executable.
326: 
327:   It may happen that this requirement contradicts the license
328: restrictions of other proprietary libraries that do not normally
329: accompany the operating system.  Such a contradiction means you cannot
330: use both them and the Library together in an executable that you
331: distribute.
332: 
333:   7. You may place library facilities that are a work based on the
334: Library side-by-side in a single library together with other library
335: facilities not covered by this License, and distribute such a combined
336: library, provided that the separate distribution of the work based on
337: the Library and of the other library facilities is otherwise
338: permitted, and provided that you do these two things:
339: 
340:     a) Accompany the combined library with a copy of the same work
341:     based on the Library, uncombined with any other library
342:     facilities.  This must be distributed under the terms of the
343:     Sections above.
344: 
345:     b) Give prominent notice with the combined library of the fact
346:     that part of it is a work based on the Library, and explaining
347:     where to find the accompanying uncombined form of the same work.
348: 
349:   8. You may not copy, modify, sublicense, link with, or distribute
350: the Library except as expressly provided under this License.  Any
351: attempt otherwise to copy, modify, sublicense, link with, or
352: distribute the Library is void, and will automatically terminate your
353: rights under this License.  However, parties who have received copies,
354: or rights, from you under this License will not have their licenses
355: terminated so long as such parties remain in full compliance.
356: 
357:   9. You are not required to accept this License, since you have not
358: signed it.  However, nothing else grants you permission to modify or
359: distribute the Library or its derivative works.  These actions are
360: prohibited by law if you do not accept this License.  Therefore, by
361: modifying or distributing the Library (or any work based on the
362: Library), you indicate your acceptance of this License to do so, and
363: all its terms and conditions for copying, distributing or modifying
364: the Library or works based on it.
365: 
366:   10. Each time you redistribute the Library (or any work based on the
367: Library), the recipient automatically receives a license from the
368: original licensor to copy, distribute, link with or modify the Library
369: subject to these terms and conditions.  You may not impose any further
370: restrictions on the recipients&apos; exercise of the rights granted herein.
371: You are not responsible for enforcing compliance by third parties with
372: this License.
373: 
374:   11. If, as a consequence of a court judgment or allegation of patent
375: infringement or for any other reason (not limited to patent issues),
376: conditions are imposed on you (whether by court order, agreement or
377: otherwise) that contradict the conditions of this License, they do not
378: excuse you from the conditions of this License.  If you cannot
379: distribute so as to satisfy simultaneously your obligations under this
380: License and any other pertinent obligations, then as a consequence you
381: may not distribute the Library at all.  For example, if a patent
382: license would not permit royalty-free redistribution of the Library by
383: all those who receive copies directly or indirectly through you, then
384: the only way you could satisfy both it and this License would be to
385: refrain entirely from distribution of the Library.
386: 
387: If any portion of this section is held invalid or unenforceable under any
388: particular circumstance, the balance of the section is intended to apply,
389: and the section as a whole is intended to apply in other circumstances.
390: 
391: It is not the purpose of this section to induce you to infringe any
392: patents or other property right claims or to contest validity of any
393: such claims; this section has the sole purpose of protecting the
394: integrity of the free software distribution system which is
395: implemented by public license practices.  Many people have made
396: generous contributions to the wide range of software distributed
397: through that system in reliance on consistent application of that
398: system; it is up to the author/donor to decide if he or she is willing
399: to distribute software through any other system and a licensee cannot
400: impose that choice.
401: 
402: This section is intended to make thoroughly clear what is believed to
403: be a consequence of the rest of this License.
404: 
405:   12. If the distribution and/or use of the Library is restricted in
406: certain countries either by patents or by copyrighted interfaces, the
407: original copyright holder who places the Library under this License may add
408: an explicit geographical distribution limitation excluding those countries,
409: so that distribution is permitted only in or among countries not thus
410: excluded.  In such case, this License incorporates the limitation as if
411: written in the body of this License.
412: 
413:   13. The Free Software Foundation may publish revised and/or new
414: versions of the Lesser General Public License from time to time.
415: Such new versions will be similar in spirit to the present version,
416: but may differ in detail to address new problems or concerns.
417: 
418: Each version is given a distinguishing version number.  If the Library
419: specifies a version number of this License which applies to it and
420: &quot;any later version&quot;, you have the option of following the terms and
421: conditions either of that version or of any later version published by
422: the Free Software Foundation.  If the Library does not specify a
423: license version number, you may choose any version ever published by
424: the Free Software Foundation.
425: 
426:   14. If you wish to incorporate parts of the Library into other free
427: programs whose distribution conditions are incompatible with these,
428: write to the author to ask for permission.  For software which is
429: copyrighted by the Free Software Foundation, write to the Free
430: Software Foundation; we sometimes make exceptions for this.  Our
431: decision will be guided by the two goals of preserving the free status
432: of all derivatives of our free software and of promoting the sharing
433: and reuse of software generally.
434: 
435: 			    NO WARRANTY
436: 
437:   15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
438: WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
439: EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
440: OTHER PARTIES PROVIDE THE LIBRARY &quot;AS IS&quot; WITHOUT WARRANTY OF ANY
441: KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
442: IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
443: PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
444: LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
445: THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
446: 
447:   16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
448: WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
449: AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
450: FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
451: CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
452: LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
453: RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
454: FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
455: SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
456: DAMAGES.
457: 
458: 		     END OF TERMS AND CONDITIONS
459: 
460:            How to Apply These Terms to Your New Libraries
461: 
462:   If you develop a new library, and you want it to be of the greatest
463: possible use to the public, we recommend making it free software that
464: everyone can redistribute and change.  You can do so by permitting
465: redistribution under these terms (or, alternatively, under the terms of the
466: ordinary General Public License).
467: 
468:   To apply these terms, attach the following notices to the library.  It is
469: safest to attach them to the start of each source file to most effectively
470: convey the exclusion of warranty; and each file should have at least the
471: &quot;copyright&quot; line and a pointer to where the full notice is found.
472: 
473:     &lt;one line to give the library&apos;s name and a brief idea of what it does.&gt;
474:     Copyright (C) &lt;year&gt;  &lt;name of author&gt;
475: 
476:     This library is free software; you can redistribute it and/or
477:     modify it under the terms of the GNU Lesser General Public
478:     License as published by the Free Software Foundation; either
479:     version 2.1 of the License, or (at your option) any later version.
480: 
481:     This library is distributed in the hope that it will be useful,
482:     but WITHOUT ANY WARRANTY; without even the implied warranty of
483:     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
484:     Lesser General Public License for more details.
485: 
486:     You should have received a copy of the GNU Lesser General Public
487:     License along with this library; if not, write to the Free Software
488:     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
489: 
490: Also add information on how to contact you by electronic and paper mail.
491: 
492: You should also get your employer (if you work as a programmer) or your
493: school, if any, to sign a &quot;copyright disclaimer&quot; for the library, if
494: necessary.  Here is a sample; alter the names:
495: 
496:   Yoyodyne, Inc., hereby disclaims all copyright interest in the
497:   library `Frob&apos; (a library for tweaking knobs) written by James Random Hacker.
498: 
499:   &lt;signature of Ty Coon&gt;, 1 April 1990
500:   Ty Coon, President of Vice
501: 
502: That&apos;s all there is to it!</file><file path="TS/images/nuvola/readme.txt"> 1: ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2: This copyright and license notice covers the images in this directory.
 3: Note the license notice contains an add-on.
 4: ************************************************************************
 5: 
 6: TITLE:	NUVOLA ICON THEME for KDE 3.x
 7: AUTHOR:	David Vignoni | ICON KING
 8: SITE:	http://www.icon-king.com
 9: MAILING LIST: http://mail.icon-king.com/mailman/listinfo/nuvola_icon-king.com
10: 
11: Copyright (c)  2003-2004  David Vignoni.
12: 
13: This library is free software; you can redistribute it and/or
14: modify it under the terms of the GNU Lesser General Public
15: License as published by the Free Software Foundation,
16: version 2.1 of the License.
17: This library is distributed in the hope that it will be useful,
18: but WITHOUT ANY WARRANTY; without even the implied warranty of
19: MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
20: Lesser General Public License for more details.
21: You should have received a copy of the GNU Lesser General Public
22: License along with this library (see the the license.txt file); if not, write to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
23: #######**** NOTE THIS ADD-ON ****#######
24: The GNU Lesser General Public License or LGPL is written for software libraries
25: in the first place. The LGPL has to be considered valid for this artwork
26: library too.
27: Nuvola icon theme for KDE 3.x is a special kind of software library, it is an
28: artwork library, it&apos;s elements can be used in a Graphical User Interface, or
29: GUI.
30: Source code, for this library means:
31:  - raster png image* .
32: The LGPL in some sections obliges you to make the files carry
33: notices. With images this is in some cases impossible or hardly usefull.
34: With this library a notice is placed at a prominent place in the directory
35: containing the elements. You may follow this practice.
36: The exception in section 6 of the GNU Lesser General Public License covers
37: the use of elements of this art library in a GUI.
38: dave [at] icon-king.com
39: 
40: Date:		15 october 2004
41: Version:	1.0
42: 
43: DESCRIPTION:
44: 
45: Icon theme for KDE 3.x. 
46: Icons where designed using Adobe Illustrator, and then exported to PNG format.
47: Icons shadows and minor corrections were done using Adobe Photoshop.
48: Kiconedit was used to correct some 16x16 and 22x22 icons.
49: 
50: LICENSE
51: 
52: Released under GNU Lesser General Public License (LGPL)
53: Look at the license.txt file.
54: 
55: CONTACT
56: 
57: David Vignoni	
58: e-mail :		david [at] icon-king.com
59: ICQ :			117761009
60: http:           	http://www.icon-king.com</file><file path="TS/images/nuvola/thanks.to">1: Thanks to
2: 
3: Mark Mahle from Hosted.as for hosting the site, support and for being a true friend. Best wishes for you.
4: Christian Schaller to be a big fan Nuvola SVG and to have made me part of the gnome-themes-extras team.
5: Carlos Woelz for his work at kde-quality and to give me some visibility with the interview at dot.kde.org.
6: 
7: Also big thanks to Swell Technology, Kde-look and special thanks to the guys of Nuvola Mailinglist: Marcel Dierkes, Christian Szabo and Virginie Quesnay.</file><file path="TS/scripts/Export JSON.lobster"> 1: // This example script exports a TreeSheet to JSON.
 2: 
 3: // That is not super-useful, since TreeSheets are not key-value pairs, so instead it exports
 4: // as a recursive set of arrays with strings instead.
 5: 
 6: // In each array, the first element is cell text, followed by the children.
 7: // For each child, if it has no children it is just a string, otherwise an array.
 8: 
 9: // Also a nice simple example on how to recurse through a TreeSheet in script.
10: 
11: import std
12: 
13: let out = []
14: 
15: def add_text(s):
16:     out.push(&quot;\&quot;&quot;)
17:     // \ and &quot; need to be escaped in JSON:
18:     out.push(escape_string(s, &quot;\\\&quot;&quot;, &quot;\\&quot;, &quot;&quot;))
19:     out.push(&quot;\&quot;&quot;)
20: 
21: def add_indent(indent):
22:     out.push(concat_string(map(indent): &quot;  &quot;, &quot;&quot;))
23: 
24: def add_cell(indent) -&gt; void:
25:     out.push(&quot;[\n&quot;)
26:     add_indent(indent + 1)
27:     add_text(ts.get_text())
28:     for(ts.num_children()) i:
29:         out.push(&quot;,\n&quot;)
30:         ts.goto_child(i)
31:         add_indent(indent + 1)
32:         if ts.num_children():
33:             add_cell(indent + 1)
34:         else:
35:             add_text(ts.get_text())
36:         ts.goto_parent()
37:     out.push(&quot;\n&quot;)
38:     add_indent(indent)
39:     out.push(&quot;]&quot;)
40: 
41: let filename = ts.get_filename_from_user(true)
42: if filename.length:
43:     ts.goto_root()  // This the default, here just for clarity.
44:     add_cell(0)
45:     let ok = write_file(filename, concat_string(out, &quot;&quot;), true, true)
46:     ts.set_status_message(&quot;JSON export of {filename} &quot; + if ok: &quot;successful&quot; else: &quot;failed!&quot;)
47: else:
48:     ts.set_status_message(&quot;export cancelled&quot;)</file><file path="TS/scripts/Statistics.lobster"> 1: // This example script prints a statistics line.
 2: 
 3: // Also a nice simple example on how to recurse through a TreeSheet in script.
 4: 
 5: import std
 6: 
 7: var cells = 0
 8: var chars = 0
 9: 
10: def count_cell() -&gt; void:
11:     cells++
12:     chars += ts.get_text().length
13:     for(ts.num_children()) i:
14:         ts.goto_child(i)
15:         count_cell()
16:         ts.goto_parent()
17: 
18: ts.goto_selection()
19: let size, start = ts.selection()
20: ts.goto_parent()
21: let g = ts.num_columns_rows()
22: for(ts.num_children()) j:
23:     if j % g[0] &gt;= start[0] and j % g[0] &lt; start[0] + size[0] and j / g[0] &gt;= start[1] and j / g[0] &lt; start[1] + size[1]:
24:         ts.goto_child(j)
25:         count_cell()
26:         ts.goto_parent()
27: ts.set_status_message(&quot;Selection contains {cells} cell(s) with {chars} character(s)&quot;)</file><file path="TS/readme-ko.html">  1: &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//KO&quot;
  2: &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
  3: &lt;html&gt;
  4: &lt;head&gt;
  5:   &lt;title&gt;TreeSheets&lt;/title&gt;
  6:   &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=iso-8859-1&quot;&gt;
  7:   &lt;style type=&quot;text/css&quot;&gt;
  8:     &lt;!-- body {
  9:       background-color: #666666;
 10:     }
 11:     div#rounded {
 12:       background: #FFF;
 13:       width: 660px;
 14:       margin-left: auto;
 15:       margin-right: auto;
 16:     }
 17:     div#roundedcontent {
 18:       padding: 20px;
 19:     }
 20:     b.rtop,
 21:     b.rbottom {
 22:       display: block;
 23:       background: #666
 24:     }
 25:     b.rtop b,
 26:     b.rbottom b {
 27:       display: block;
 28:       height: 1px;
 29:       overflow: hidden;
 30:       background: #FFF
 31:     }
 32:     b.r1 {
 33:       margin: 0 5px
 34:     }
 35:     b.r2 {
 36:       margin: 0 3px
 37:     }
 38:     b.r3 {
 39:       margin: 0 2px
 40:     }
 41:     b.rtop b.r4,
 42:     b.rbottom b.r4 {
 43:       margin: 0 1px;
 44:       height: 2px
 45:     }
 46:     div#roundedbutton {
 47:       background: #888;
 48:       float: left;
 49:       text-align: center;
 50:       font-family: Verdana, Arial, Helvetica, sans-serif;
 51:     }
 52:     div#roundedbuttoncontent {
 53:       color: #FFF
 54:     }
 55:     b.brtop,
 56:     b.brbottom {
 57:       display: block;
 58:       background: #FFF
 59:     }
 60:     b.brtop b,
 61:     b.brbottom b {
 62:       display: block;
 63:       height: 1px;
 64:       overflow: hidden;
 65:       background: #888
 66:     }
 67:     b.br1 {
 68:       margin: 0 5px
 69:     }
 70:     b.br2 {
 71:       margin: 0 3px
 72:     }
 73:     b.br3 {
 74:       margin: 0 2px
 75:     }
 76:     b.brtop b.br4,
 77:     b.brbottom b.br4 {
 78:       margin: 0 1px;
 79:       height: 2px
 80:     }
 81:     .style11 {
 82:       font-size: medium;
 83:     }
 84:     .style12 {
 85:       font-size: small
 86:     }
 87:     a:link {
 88:       color: #0000FF;
 89:     }
 90:     a:visited {
 91:       color: #0000FF;
 92:     }
 93:     a:hover {
 94:       color: #0066FF;
 95:     }
 96:     a:active {
 97:       color: #0099FF;
 98:     }
 99:     .style13 {
100:       font-size: small;
101:       font-family: Verdana, Arial, Helvetica, sans-serif;
102:     }
103:     .style14 {
104:       font-family: Verdana, Arial, Helvetica, sans-serif
105:     }
106:     img {
107:       border-style: none
108:     }
109:     table {
110:       color: #000
111:     }
112:     --&gt;
113:   &lt;/style&gt;
114: &lt;/head&gt;
115: &lt;body&gt;
116:   &lt;div id=&quot;rounded&quot;&gt;
117:     &lt;b class=&quot;rtop&quot;&gt;
118:       &lt;b class=&quot;r1&quot;&gt;&lt;/b&gt;
119:       &lt;b class=&quot;r2&quot;&gt;&lt;/b&gt;
120:       &lt;b class=&quot;r3&quot;&gt;&lt;/b&gt;
121:       &lt;b class=&quot;r4&quot;&gt;&lt;/b&gt;
122:     &lt;/b&gt;
123:     &lt;div id=&quot;roundedcontent&quot;&gt;
124:       &lt;div align=&quot;center&quot;&gt;
125:         &lt;img src=&quot;docs/images/treesheets_logo.png&quot; width=&quot;507&quot; height=&quot;156&quot;&gt; &lt;/div&gt;
126:       &lt;p align=&quot;center&quot; class=&quot;style2 style10 style14&quot;&gt; 
127:         &lt;br&gt;    &lt;br&gt; ( )&lt;/p&gt;
128:       &lt;div id=&quot;roundedbutton&quot; style=&quot;width: 598px; margin-top: 10px;margin-left: 10px;&quot;&gt;
129:         &lt;b class=&quot;brtop&quot;&gt;
130:           &lt;b class=&quot;br1&quot;&gt;&lt;/b&gt;
131:           &lt;b class=&quot;br2&quot;&gt;&lt;/b&gt;
132:           &lt;b class=&quot;br3&quot;&gt;&lt;/b&gt;
133:           &lt;b class=&quot;br4&quot;&gt;&lt;/b&gt;
134:         &lt;/b&gt;
135:         &lt;div id=&quot;roundedbuttoncontent&quot;&gt;
136:               :
137:           &lt;table width=&quot;590&quot; border=&quot;0&quot; align=&quot;center&quot; cellpadding=&quot;3&quot; cellspacing=&quot;1&quot;&gt;
138:             &lt;tr&gt;
139:               &lt;td width=&quot;40%&quot; bgcolor=&quot;#CCCCCC&quot; colspan=&quot;2&quot;&gt;
140:                 &lt;div align=&quot;left&quot;&gt;
141:                   &lt;span class=&quot;style13&quot;&gt;github    :&lt;/span&gt;
142:                 &lt;/div&gt;
143:               &lt;/td&gt;
144:             &lt;/tr&gt;
145:             &lt;tr&gt;
146:               &lt;td width=&quot;40%&quot; bgcolor=&quot;#EEEEEE&quot;&gt;
147:                 &lt;div align=&quot;left&quot;&gt;
148:                   &lt;span class=&quot;style13&quot;&gt;Windows / OS X / Linux&lt;/span&gt;
149:                 &lt;/div&gt;
150:               &lt;/td&gt;
151:               &lt;td width=&quot;60%&quot; bgcolor=&quot;#EEEEEE&quot;&gt;
152:                 &lt;div align=&quot;left&quot;&gt;
153:                   &lt;span class=&quot;style13&quot;&gt;
154:                         &lt;a href=&quot;https://github.com/aardappel/treesheets/releases&quot;&gt;&lt;/a&gt; .
155:                   &lt;/span&gt;
156:                 &lt;/div&gt;
157:               &lt;/td&gt;
158:             &lt;/tr&gt;
159:           &lt;/table&gt;
160:         &lt;/div&gt;
161:         &lt;b class=&quot;brbottom&quot;&gt;
162:           &lt;b class=&quot;br4&quot;&gt;&lt;/b&gt;
163:           &lt;b class=&quot;br3&quot;&gt;&lt;/b&gt;
164:           &lt;b class=&quot;br2&quot;&gt;&lt;/b&gt;
165:           &lt;b class=&quot;br1&quot;&gt;&lt;/b&gt;
166:         &lt;/b&gt;
167:       &lt;/div&gt;
168:       &lt;table width=&quot;618&quot; border=&quot;0&quot; align=&quot;left&quot; cellpadding=&quot;3&quot; cellspacing=&quot;1&quot;&gt;
169:         &lt;tr&gt;
170:           &lt;td&gt;&amp;nbsp;&lt;/td&gt;
171:         &lt;/tr&gt;
172:         &lt;tr&gt;
173:           &lt;td&gt;
174:             &lt;a href=&quot;docs/screenshots.html&quot;&gt;
175:               &lt;img src=&quot;docs/images/screenshots/screenshot_todo_half.png&quot; width=&quot;607&quot; height=&quot;498&quot;&gt;
176:             &lt;/a&gt;
177:           &lt;/td&gt;
178:         &lt;/tr&gt;
179:         &lt;tr&gt;
180:           &lt;td&gt;
181:             &lt;p class=&quot;style13&quot;&gt;,  , , PIM,        
182:               &quot; &quot;.&lt;/p&gt;
183:             &lt;p class=&quot;style13&quot;&gt;  , ,  , ,  ,
184:               ,   ,        
185:               ..
186:             &lt;/p&gt;
187:             &lt;p class=&quot;style13&quot;&gt;         .
188:                   .
189:               &lt;br&gt;      .
190:               &lt;br&gt;       .
191:               &lt;br&gt;     .&lt;/p&gt;
192:             &lt;p class=&quot;style13&quot;&gt;
193:               &lt;a href=&quot;docs/screenshots.html&quot;&gt;&lt;/a&gt;        
194:               &lt;a href=&quot;docs/tutorial.html&quot;&gt;&lt;/a&gt;          ().
195:                 &lt;a href=&quot;https://www.youtube.com/watch?v=UB-saQZfrsw&quot;&gt;&lt;/a&gt; (Linux) &lt;/p&gt;
196:             &lt;p class=&quot;style13&quot;&gt;TreeSheets         
197:               :  100       
198:               Windows 5MB  
199:               (!)&lt;/p&gt;
200:             &lt;p class=&quot;style13&quot;&gt;TreeSheets   . !&lt;/p&gt;
201:             &lt;p class=&quot;style13&quot;&gt;
202:               &lt;a href=&quot;https://discord.gg/HAfKkJz&quot;&gt;Discord&lt;/a&gt; 
203:               &lt;a href=&quot;http://groups.google.com/group/treesheets&quot;&gt;google &lt;/a&gt;  .
204:               &lt;a href=&quot;https://github.com/aardappel/treesheets&quot;&gt;GitHub&lt;/a&gt;   
205:                    .
206:                &lt;a href=&quot;docs/donations.html&quot;&gt;&lt;/a&gt;  .
207:                (Wouter van Oortmerssen)  &lt;a href=&quot;mailto:aardappelatgmaildotcom&quot;&gt;&lt;/a&gt;.&lt;/p&gt;
208:             &lt;iframe src=&quot;http://www.facebook.com/plugins/likebox.php?href=http%3A%2F%2Fwww.facebook.com%2Fpages%2FTreeSheets%2F149372691795105&amp;amp;width=300&amp;amp;colorscheme=light&amp;amp;show_faces=false&amp;amp;stream=false&amp;amp;header=false&amp;amp;height=62&quot;
209:               scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:300px; height:62px;&quot;
210:               allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
211:           &lt;/td&gt;
212:         &lt;/tr&gt;
213:       &lt;/table&gt;
214:       &lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;
215:       &lt;br&gt;
216:       &lt;p align=&quot;left&quot; class=&quot;style12&quot;&gt;&amp;nbsp;&lt;/p&gt;
217:     &lt;/div&gt;
218:     &lt;b class=&quot;rbottom&quot;&gt;
219:       &lt;b class=&quot;r4&quot;&gt;&lt;/b&gt;
220:       &lt;b class=&quot;r3&quot;&gt;&lt;/b&gt;
221:       &lt;b class=&quot;r2&quot;&gt;&lt;/b&gt;
222:       &lt;b class=&quot;r1&quot;&gt;&lt;/b&gt;
223:     &lt;/b&gt;
224:   &lt;/div&gt;
225: &lt;/body&gt;
226: &lt;/html&gt;</file><file path="TS/readme-zh_CN.html">  1: &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
  2: &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
  3: &lt;html lang=&quot;zh&quot;&gt;
  4: &lt;head&gt;
  5:   &lt;title&gt;TreeSheets&lt;/title&gt;
  6:   &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
  7:   &lt;style type=&quot;text/css&quot;&gt;
  8:     &lt;!-- body {
  9:       background-color: #666666;
 10:     }
 11:     div#rounded {
 12:       background: #FFF;
 13:       width: 660px;
 14:       margin-left: auto;
 15:       margin-right: auto;
 16:     }
 17:     div#roundedcontent {
 18:       padding: 20px;
 19:     }
 20:     b.rtop,
 21:     b.rbottom {
 22:       display: block;
 23:       background: #666
 24:     }
 25:     b.rtop b,
 26:     b.rbottom b {
 27:       display: block;
 28:       height: 1px;
 29:       overflow: hidden;
 30:       background: #FFF
 31:     }
 32:     b.r1 {
 33:       margin: 0 5px
 34:     }
 35:     b.r2 {
 36:       margin: 0 3px
 37:     }
 38:     b.r3 {
 39:       margin: 0 2px
 40:     }
 41:     b.rtop b.r4,
 42:     b.rbottom b.r4 {
 43:       margin: 0 1px;
 44:       height: 2px
 45:     }
 46:     div#roundedbutton {
 47:       background: #888;
 48:       float: left;
 49:       text-align: center;
 50:       font-family: Verdana, Arial, Helvetica, sans-serif;
 51:     }
 52:     div#roundedbuttoncontent {
 53:       color: #FFF
 54:     }
 55:     b.brtop,
 56:     b.brbottom {
 57:       display: block;
 58:       background: #FFF
 59:     }
 60:     b.brtop b,
 61:     b.brbottom b {
 62:       display: block;
 63:       height: 1px;
 64:       overflow: hidden;
 65:       background: #888
 66:     }
 67:     b.br1 {
 68:       margin: 0 5px
 69:     }
 70:     b.br2 {
 71:       margin: 0 3px
 72:     }
 73:     b.br3 {
 74:       margin: 0 2px
 75:     }
 76:     b.brtop b.br4,
 77:     b.brbottom b.br4 {
 78:       margin: 0 1px;
 79:       height: 2px
 80:     }
 81:     .style11 {
 82:       font-size: medium;
 83:     }
 84:     .style12 {
 85:       font-size: small
 86:     }
 87:     a:link {
 88:       color: #0000FF;
 89:     }
 90:     a:visited {
 91:       color: #0000FF;
 92:     }
 93:     a:hover {
 94:       color: #0066FF;
 95:     }
 96:     a:active {
 97:       color: #0099FF;
 98:     }
 99:     .style13 {
100:       font-size: small;
101:       font-family: Verdana, Arial, Helvetica, sans-serif;
102:     }
103:     .style14 {
104:       font-family: Verdana, Arial, Helvetica, sans-serif
105:     }
106:     img {
107:       border-style: none
108:     }
109:     table {
110:       color: #000
111:     }
112:     --&gt;
113:   &lt;/style&gt;
114: &lt;/head&gt;
115: &lt;body&gt;
116:   &lt;div id=&quot;rounded&quot;&gt;
117:     &lt;b class=&quot;rtop&quot;&gt;
118:       &lt;b class=&quot;r1&quot;&gt;&lt;/b&gt;
119:       &lt;b class=&quot;r2&quot;&gt;&lt;/b&gt;
120:       &lt;b class=&quot;r3&quot;&gt;&lt;/b&gt;
121:       &lt;b class=&quot;r4&quot;&gt;&lt;/b&gt;
122:     &lt;/b&gt;
123:     &lt;div id=&quot;roundedcontent&quot;&gt;
124:       &lt;div align=&quot;center&quot;&gt;
125:         &lt;img src=&quot;docs/images/treesheets_logo.png&quot; width=&quot;507&quot; height=&quot;156&quot;&gt; &lt;/div&gt;
126:       &lt;p align=&quot;center&quot; class=&quot;style2 style10 style14&quot;&gt;
127:         &lt;br&gt; &lt;br&gt; ()&lt;/p&gt;
128:       &lt;div id=&quot;roundedbutton&quot; style=&quot;width: 598px; margin-top: 10px;margin-left: 10px;&quot;&gt;
129:         &lt;b class=&quot;brtop&quot;&gt;
130:           &lt;b class=&quot;br1&quot;&gt;&lt;/b&gt;
131:           &lt;b class=&quot;br2&quot;&gt;&lt;/b&gt;
132:           &lt;b class=&quot;br3&quot;&gt;&lt;/b&gt;
133:           &lt;b class=&quot;br4&quot;&gt;&lt;/b&gt;
134:         &lt;/b&gt;
135:         &lt;div id=&quot;roundedbuttoncontent&quot;&gt;
136:           :
137:           &lt;table width=&quot;590&quot; border=&quot;0&quot; align=&quot;center&quot; cellpadding=&quot;3&quot; cellspacing=&quot;1&quot;&gt;
138:             &lt;tr&gt;
139:               &lt;td width=&quot;40%&quot; bgcolor=&quot;#CCCCCC&quot; colspan=&quot;2&quot;&gt;
140:                 &lt;div align=&quot;left&quot;&gt;
141:                   &lt;span class=&quot;style13&quot;&gt; github &lt;/span&gt;
142:                 &lt;/div&gt;
143:               &lt;/td&gt;
144:             &lt;/tr&gt;
145:             &lt;tr&gt;
146:               &lt;td width=&quot;40%&quot; bgcolor=&quot;#EEEEEE&quot;&gt;
147:                 &lt;div align=&quot;left&quot;&gt;
148:                   &lt;span class=&quot;style13&quot;&gt;Windows / OS X / Linux&lt;/span&gt;
149:                 &lt;/div&gt;
150:               &lt;/td&gt;
151:               &lt;td width=&quot;60%&quot; bgcolor=&quot;#EEEEEE&quot;&gt;
152:                 &lt;div align=&quot;left&quot;&gt;
153:                   &lt;span class=&quot;style13&quot;&gt;
154:                     &lt;a href=&quot;https://github.com/aardappel/treesheets/releases&quot;&gt;&lt;/a&gt;
155:                   &lt;/span&gt;
156:                 &lt;/div&gt;
157:               &lt;/td&gt;
158:             &lt;/tr&gt;
159:           &lt;/table&gt;
160:         &lt;/div&gt;
161:         &lt;b class=&quot;brbottom&quot;&gt;
162:           &lt;b class=&quot;br4&quot;&gt;&lt;/b&gt;
163:           &lt;b class=&quot;br3&quot;&gt;&lt;/b&gt;
164:           &lt;b class=&quot;br2&quot;&gt;&lt;/b&gt;
165:           &lt;b class=&quot;br1&quot;&gt;&lt;/b&gt;
166:         &lt;/b&gt;
167:       &lt;/div&gt;
168:       &lt;table width=&quot;618&quot; border=&quot;0&quot; align=&quot;left&quot; cellpadding=&quot;3&quot; cellspacing=&quot;1&quot;&gt;
169:         &lt;tr&gt;
170:           &lt;td&gt;&amp;nbsp;&lt;/td&gt;
171:         &lt;/tr&gt;
172:         &lt;tr&gt;
173:           &lt;td&gt;
174:             &lt;a href=&quot;docs/screenshots.html&quot;&gt;
175:               &lt;img src=&quot;docs/images/screenshots/screenshot_todo_half.png&quot; width=&quot;607&quot; height=&quot;498&quot;&gt;
176:             &lt;/a&gt;
177:           &lt;/td&gt;
178:         &lt;/tr&gt;
179:         &lt;tr&gt;
180:           &lt;td&gt;
181:             &lt;p class=&quot;style13&quot;&gt;PIMs&lt;/p&gt;
182:             &lt;p class=&quot;style13&quot;&gt;
183:             &lt;/p&gt;
184:             &lt;p class=&quot;style13&quot;&gt;
185:             &lt;br&gt;
186: 			&lt;br&gt;
187: 			&lt;br&gt;
188: 			 
189: 			&lt;/p&gt;
190:             &lt;p class=&quot;style13&quot;&gt;
191:               &lt;a href=&quot;docs/screenshots.html&quot;&gt;&lt;/a&gt; &lt;br&gt;
192:               &lt;a href=&quot;docs/tutorial.html&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;
193:               &lt;a href=&quot;https://www.youtube.com/watch?v=UB-saQZfrsw&quot;&gt;&lt;/a&gt; (Linux)&lt;/p&gt;
194:             &lt;p class=&quot;style13&quot;&gt;TreeSheets100Windows 75MB&lt;/p&gt;
195:             &lt;p class=&quot;style13&quot;&gt;TreeSheets&lt;/p&gt;
196:             &lt;p class=&quot;style13&quot;&gt;
197:               &lt;a href=&quot;https://discord.gg/HAfKkJz&quot;&gt;Discord&lt;/a&gt; 
198:               &lt;a href=&quot;http://groups.google.com/group/treesheets&quot;&gt;google group&lt;/a&gt; 
199:               
200:               &lt;a href=&quot;https://github.com/aardappel/treesheets&quot;&gt;GitHub&lt;/a&gt;/
201:                &lt;a href=&quot;docs/donations.html&quot;&gt;&lt;/a&gt; 
202:               &lt;a href=&quot;mailto:aardappelatgmaildotcom&quot;&gt;&lt;/a&gt;  (Wouter van Oortmerssen) &lt;/p&gt;
203:             &lt;iframe src=&quot;http://www.facebook.com/plugins/likebox.php?href=http%3A%2F%2Fwww.facebook.com%2Fpages%2FTreeSheets%2F149372691795105&amp;amp;width=300&amp;amp;colorscheme=light&amp;amp;show_faces=false&amp;amp;stream=false&amp;amp;header=false&amp;amp;height=62&quot;
204:               scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:300px; height:62px;&quot;
205:               allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
206:           &lt;/td&gt;
207:         &lt;/tr&gt;
208:       &lt;/table&gt;
209:       &lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;
210:       &lt;br&gt;
211:       &lt;p align=&quot;left&quot; class=&quot;style12&quot;&gt;&amp;nbsp;&lt;/p&gt;
212:     &lt;/div&gt;
213:     &lt;b class=&quot;rbottom&quot;&gt;
214:       &lt;b class=&quot;r4&quot;&gt;&lt;/b&gt;
215:       &lt;b class=&quot;r3&quot;&gt;&lt;/b&gt;
216:       &lt;b class=&quot;r2&quot;&gt;&lt;/b&gt;
217:       &lt;b class=&quot;r1&quot;&gt;&lt;/b&gt;
218:     &lt;/b&gt;
219:   &lt;/div&gt;
220: &lt;/body&gt;
221: &lt;/html&gt;</file><file path="TS/readme.html">  1: &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
  2: &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
  3: &lt;html&gt;
  4: &lt;head&gt;
  5:   &lt;title&gt;TreeSheets&lt;/title&gt;
  6:   &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=iso-8859-1&quot;&gt;
  7:   &lt;style type=&quot;text/css&quot;&gt;
  8:     &lt;!-- body {
  9:       background-color: #666666;
 10:     }
 11:     div#rounded {
 12:       background: #FFF;
 13:       width: 660px;
 14:       margin-left: auto;
 15:       margin-right: auto;
 16:     }
 17:     div#roundedcontent {
 18:       padding: 20px;
 19:     }
 20:     b.rtop,
 21:     b.rbottom {
 22:       display: block;
 23:       background: #666
 24:     }
 25:     b.rtop b,
 26:     b.rbottom b {
 27:       display: block;
 28:       height: 1px;
 29:       overflow: hidden;
 30:       background: #FFF
 31:     }
 32:     b.r1 {
 33:       margin: 0 5px
 34:     }
 35:     b.r2 {
 36:       margin: 0 3px
 37:     }
 38:     b.r3 {
 39:       margin: 0 2px
 40:     }
 41:     b.rtop b.r4,
 42:     b.rbottom b.r4 {
 43:       margin: 0 1px;
 44:       height: 2px
 45:     }
 46:     div#roundedbutton {
 47:       background: #888;
 48:       float: left;
 49:       text-align: center;
 50:       font-family: Verdana, Arial, Helvetica, sans-serif;
 51:     }
 52:     div#roundedbuttoncontent {
 53:       color: #FFF
 54:     }
 55:     b.brtop,
 56:     b.brbottom {
 57:       display: block;
 58:       background: #FFF
 59:     }
 60:     b.brtop b,
 61:     b.brbottom b {
 62:       display: block;
 63:       height: 1px;
 64:       overflow: hidden;
 65:       background: #888
 66:     }
 67:     b.br1 {
 68:       margin: 0 5px
 69:     }
 70:     b.br2 {
 71:       margin: 0 3px
 72:     }
 73:     b.br3 {
 74:       margin: 0 2px
 75:     }
 76:     b.brtop b.br4,
 77:     b.brbottom b.br4 {
 78:       margin: 0 1px;
 79:       height: 2px
 80:     }
 81:     .style11 {
 82:       font-size: medium;
 83:     }
 84:     .style12 {
 85:       font-size: small
 86:     }
 87:     a:link {
 88:       color: #0000FF;
 89:     }
 90:     a:visited {
 91:       color: #0000FF;
 92:     }
 93:     a:hover {
 94:       color: #0066FF;
 95:     }
 96:     a:active {
 97:       color: #0099FF;
 98:     }
 99:     .style13 {
100:       font-size: small;
101:       font-family: Verdana, Arial, Helvetica, sans-serif;
102:     }
103:     .style14 {
104:       font-family: Verdana, Arial, Helvetica, sans-serif
105:     }
106:     img {
107:       border-style: none
108:     }
109:     table {
110:       color: #000
111:     }
112:     --&gt;
113:   &lt;/style&gt;
114: &lt;/head&gt;
115: &lt;body&gt;
116:   &lt;div id=&quot;rounded&quot;&gt;
117:     &lt;b class=&quot;rtop&quot;&gt;
118:       &lt;b class=&quot;r1&quot;&gt;&lt;/b&gt;
119:       &lt;b class=&quot;r2&quot;&gt;&lt;/b&gt;
120:       &lt;b class=&quot;r3&quot;&gt;&lt;/b&gt;
121:       &lt;b class=&quot;r4&quot;&gt;&lt;/b&gt;
122:     &lt;/b&gt;
123:     &lt;div id=&quot;roundedcontent&quot;&gt;
124:       &lt;div align=&quot;center&quot;&gt;
125:         &lt;img src=&quot;docs/images/treesheets_logo.png&quot; width=&quot;507&quot; height=&quot;156&quot;&gt; &lt;/div&gt;
126:       &lt;p align=&quot;center&quot; class=&quot;style2 style10 style14&quot;&gt;Open Source
127:         &lt;br&gt;Free Form Data Organizer &lt;br&gt; (Hierarchical Spreadsheet)&lt;/p&gt;
128:       &lt;div id=&quot;roundedbutton&quot; style=&quot;width: 598px; margin-top: 10px;margin-left: 10px;&quot;&gt;
129:         &lt;b class=&quot;brtop&quot;&gt;
130:           &lt;b class=&quot;br1&quot;&gt;&lt;/b&gt;
131:           &lt;b class=&quot;br2&quot;&gt;&lt;/b&gt;
132:           &lt;b class=&quot;br3&quot;&gt;&lt;/b&gt;
133:           &lt;b class=&quot;br4&quot;&gt;&lt;/b&gt;
134:         &lt;/b&gt;
135:         &lt;div id=&quot;roundedbuttoncontent&quot;&gt;
136:           D O W N L O A D :
137:           &lt;table width=&quot;590&quot; border=&quot;0&quot; align=&quot;center&quot; cellpadding=&quot;3&quot; cellspacing=&quot;1&quot;&gt;
138:             &lt;tr&gt;
139:               &lt;td width=&quot;40%&quot; bgcolor=&quot;#CCCCCC&quot; colspan=&quot;2&quot;&gt;
140:                 &lt;div align=&quot;left&quot;&gt;
141:                   &lt;span class=&quot;style13&quot;&gt;Download LATEST from github releases:&lt;/span&gt;
142:                 &lt;/div&gt;
143:               &lt;/td&gt;
144:             &lt;/tr&gt;
145:             &lt;tr&gt;
146:               &lt;td width=&quot;40%&quot; bgcolor=&quot;#EEEEEE&quot;&gt;
147:                 &lt;div align=&quot;left&quot;&gt;
148:                   &lt;span class=&quot;style13&quot;&gt;Windows / OS X / Linux&lt;/span&gt;
149:                 &lt;/div&gt;
150:               &lt;/td&gt;
151:               &lt;td width=&quot;60%&quot; bgcolor=&quot;#EEEEEE&quot;&gt;
152:                 &lt;div align=&quot;left&quot;&gt;
153:                   &lt;span class=&quot;style13&quot;&gt;
154:                     Click &lt;a href=&quot;https://github.com/aardappel/treesheets/releases&quot;&gt;HERE&lt;/a&gt;, pick your platform from the latest release.
155:                   &lt;/span&gt;
156:                 &lt;/div&gt;
157:               &lt;/td&gt;
158:             &lt;/tr&gt;
159:           &lt;/table&gt;
160:         &lt;/div&gt;
161:         &lt;b class=&quot;brbottom&quot;&gt;
162:           &lt;b class=&quot;br4&quot;&gt;&lt;/b&gt;
163:           &lt;b class=&quot;br3&quot;&gt;&lt;/b&gt;
164:           &lt;b class=&quot;br2&quot;&gt;&lt;/b&gt;
165:           &lt;b class=&quot;br1&quot;&gt;&lt;/b&gt;
166:         &lt;/b&gt;
167:       &lt;/div&gt;
168:       &lt;table width=&quot;618&quot; border=&quot;0&quot; align=&quot;left&quot; cellpadding=&quot;3&quot; cellspacing=&quot;1&quot;&gt;
169:         &lt;tr&gt;
170:           &lt;td&gt;&amp;nbsp;&lt;/td&gt;
171:         &lt;/tr&gt;
172:         &lt;tr&gt;
173:           &lt;td&gt;
174:             &lt;a href=&quot;docs/screenshots.html&quot;&gt;
175:               &lt;img src=&quot;docs/images/screenshots/screenshot_todo_half.png&quot; width=&quot;607&quot; height=&quot;498&quot;&gt;
176:             &lt;/a&gt;
177:           &lt;/td&gt;
178:         &lt;/tr&gt;
179:         &lt;tr&gt;
180:           &lt;td&gt;
181:             &lt;p class=&quot;style13&quot;&gt;A &quot;hierarchical spreadsheet&quot; that is a great replacement for spreadsheets, mind mappers, outliners, PIMs,
182:               text editors and small databases.&lt;/p&gt;
183:             &lt;p class=&quot;style13&quot;&gt;Suitable for any kind of data organization, such as todo lists, calendars,
184:               project management, brainstorming, organizing ideas, planning, requirements
185:               gathering, presentation of information, etc.
186:             &lt;/p&gt;
187:             &lt;p class=&quot;style13&quot;&gt;It&apos;s like a spreadsheet, immediately familiar, but much more suitable
188:               for complex data because it&apos;s hierarchical.
189:               &lt;br&gt; It&apos;s like a mind mapper, but more organized and compact.
190:               &lt;br&gt; It&apos;s like an outliner, but in more than one dimension.
191:               &lt;br&gt; It&apos;s like a text editor, but with structure. &lt;/p&gt;
192:             &lt;p class=&quot;style13&quot;&gt;Have a quick look at what the application looks like on the
193:               &lt;a href=&quot;docs/screenshots.html&quot;&gt;screenshots&lt;/a&gt; page, see how easy it is to use in the
194:               &lt;a href=&quot;docs/tutorial.html&quot;&gt;tutorial&lt;/a&gt;, then give it a download (above).
195:               A &lt;a href=&quot;https://www.youtube.com/watch?v=UB-saQZfrsw&quot;&gt;video&lt;/a&gt; someone made (on Linux) &lt;/p&gt;
196:             &lt;p class=&quot;style13&quot;&gt;TreeSheets is exceptionally small &amp;amp; fast, so can sit in your system
197:               tray at all times: with several documents loaded representing the equivalent
198:               of almost 100 pages of text, it uses only 5MB of memory on Windows
199:               7 (!)&lt;/p&gt;
200:             &lt;p class=&quot;style13&quot;&gt;TreeSheets is free &amp; open source. Enjoy!&lt;/p&gt;
201:             &lt;p class=&quot;style13&quot;&gt;Join the
202:               &lt;a href=&quot;https://discord.gg/HAfKkJz&quot;&gt;Discord&lt;/a&gt; or
203:               &lt;a href=&quot;http://groups.google.com/group/treesheets&quot;&gt;google group&lt;/a&gt; for discussion.
204:               Grab the source code from
205:               &lt;a href=&quot;https://github.com/aardappel/treesheets&quot;&gt;GitHub&lt;/a&gt;, or file bug reports there / feature requests there.
206:               The past &lt;a href=&quot;docs/donations.html&quot;&gt;donations&lt;/a&gt; page.
207:               &lt;a href=&quot;mailto:aardappelatgmaildotcom&quot;&gt;contact&lt;/a&gt; the author (Wouter van Oortmerssen) personally.&lt;/p&gt;
208:             &lt;iframe src=&quot;http://www.facebook.com/plugins/likebox.php?href=http%3A%2F%2Fwww.facebook.com%2Fpages%2FTreeSheets%2F149372691795105&amp;amp;width=300&amp;amp;colorscheme=light&amp;amp;show_faces=false&amp;amp;stream=false&amp;amp;header=false&amp;amp;height=62&quot;
209:               scrolling=&quot;no&quot; frameborder=&quot;0&quot; style=&quot;border:none; overflow:hidden; width:300px; height:62px;&quot;
210:               allowTransparency=&quot;true&quot;&gt;&lt;/iframe&gt;
211:           &lt;/td&gt;
212:         &lt;/tr&gt;
213:       &lt;/table&gt;
214:       &lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;
215:       &lt;br&gt;
216:       &lt;p align=&quot;left&quot; class=&quot;style12&quot;&gt;&amp;nbsp;&lt;/p&gt;
217:     &lt;/div&gt;
218:     &lt;b class=&quot;rbottom&quot;&gt;
219:       &lt;b class=&quot;r4&quot;&gt;&lt;/b&gt;
220:       &lt;b class=&quot;r3&quot;&gt;&lt;/b&gt;
221:       &lt;b class=&quot;r2&quot;&gt;&lt;/b&gt;
222:       &lt;b class=&quot;r1&quot;&gt;&lt;/b&gt;
223:     &lt;/b&gt;
224:   &lt;/div&gt;
225: &lt;/body&gt;
226: &lt;/html&gt;</file><file path=".clang-format"> 1: ---
 2: BasedOnStyle: Google
 3: ---
 4: Language: Cpp
 5: IndentWidth: 4
 6: ColumnLimit: 100
 7: UseTab: Never
 8: AccessModifierOffset: 0
 9: AlignTrailingComments: true
10: AllowShortBlocksOnASingleLine: true
11: AllowShortCaseLabelsOnASingleLine: true
12: AllowShortFunctionsOnASingleLine : All
13: AllowShortLoopsOnASingleLine: true
14: BinPackParameters: true
15: ConstructorInitializerAllOnOneLineOrOnePerLine: true
16: IndentCaseLabels: true
17: NamespaceIndentation: None
18: PointerAlignment: Right
19: SpaceBeforeParens: ControlStatements
20: SpaceAfterTemplateKeyword: false
21: Standard: Cpp11
22: Cpp11BracedListStyle: true
23: SpaceBeforeCpp11BracedList: true
24: IndentPPDirectives: BeforeHash
25: AlwaysBreakTemplateDeclarations: false</file><file path=".gitattributes"> 1: # From https://docs.github.com/en/get-started/git-basics/configuring-git-to-handle-line-endings
 2: 
 3: # Set the default behavior, in case people don&apos;t have core.autocrlf set.
 4: * text=auto
 5: 
 6: # Explicitly declare text files you want to always be normalized and converted
 7: # to native line endings on checkout.
 8: *.c text
 9: *.h text
10: *.html text
11: *.svg text
12: 
13: # Declare files that will always have CRLF line endings on checkout.
14: *.sln text eol=crlf
15: 
16: # Denote all files that are truly binary and should not be modified.
17: *.png binary
18: *.jpg binary
19: *.cts binary</file><file path=".gitignore"> 1: /treesheets/Release/
 2: /treesheets/Debug/
 3: /wxwidgets/
 4: *.exe
 5: *.zip
 6: *.tar.gz
 7: *.suo
 8: *.ilk
 9: *.pdb
10: *.bak
11: **/*.o
12: 
13: TreeSheets/\.vs/treesheets/v15/
14: 
15: build/treesheets/language/
16: 
17: TS/scripts/\.con\.log
18: # In-tree build
19: TS/treesheets
20: TS/2
21: 
22: # In-tree build CMake files
23: CMakeCache.txt
24: CMakeFiles/**
25: Makefile
26: cmake_install.cmake
27: CMakeLists.txt.user
28: # Build directory for out-of-tree builds
29: _build/
30: 
31: TreeSheets/.vs
32: 
33: treesheets.cbp
34: TreeSheets/x64
35: *.ipdb
36: *.iobj
37: TreeSheets/gettext_bin</file><file path="CMakeLists.txt">  1: cmake_minimum_required(VERSION 3.25)
  2: 
  3: ### Project
  4: 
  5: if(NOT TREESHEETS_VERSION)
  6:     string(TIMESTAMP timestamp &quot;%y%m%d.%H%M&quot; UTC)
  7:     set(TREESHEETS_VERSION &quot;${timestamp}&quot;)
  8: endif()
  9: 
 10: project(TreeSheets
 11:     DESCRIPTION &quot;A free-form hierarchical data organizer&quot;
 12:     HOMEPAGE_URL &quot;https://github.com/aardappel/treesheets&quot;
 13:     VERSION &quot;${TREESHEETS_VERSION}&quot;)
 14: 
 15: ### Settings
 16: 
 17: set(CMAKE_CXX_STANDARD 20)
 18: set(CMAKE_EXPORT_COMPILE_COMMANDS 1)
 19: OPTION(ENABLE_LOBSTER &quot;Enable Lobster scripting&quot; ON)
 20: 
 21: ## Compiler-specific
 22: 
 23: # Use statically-linked libraries with MSVC
 24: if(MSVC)
 25:     set(CMAKE_MSVC_RUNTIME_LIBRARY &quot;MultiThreaded$&lt;$&lt;CONFIG:Debug&gt;:Debug&gt;&quot;)
 26:     set(wxBUILD_USE_STATIC_RUNTIME ON CACHE BOOL &quot;&quot; FORCE)
 27:     set(wxBUILD_SHARED OFF CACHE BOOL &quot;&quot; FORCE)
 28: endif(MSVC)
 29: 
 30: # Silence warnings in GCC that contain lots of false positives
 31: if(CMAKE_COMPILER_IS_GNUCXX)
 32:     set(CMAKE_CXX_FLAGS
 33:     &quot;${CMAKE_CXX_FLAGS} -Wno-array-bounds -Wno-stringop-overflow -Wno-maybe-uninitialized&quot;)
 34: endif()
 35: 
 36: ### Thirdparty dependencies
 37: 
 38: include(FetchContent)
 39: 
 40: FetchContent_Declare(
 41:     wxwidgets
 42:     GIT_REPOSITORY https://github.com/wxWidgets/wxWidgets
 43:     GIT_TAG v3.2.9
 44:     GIT_SHALLOW ON
 45:     FIND_PACKAGE_ARGS 3.2.9 NAMES wxWidgets
 46: )
 47: FetchContent_MakeAvailable(wxwidgets)
 48: 
 49: if(ENABLE_LOBSTER)
 50:     FetchContent_Declare(
 51:         lobster
 52:         GIT_REPOSITORY https://github.com/aardappel/lobster
 53:         GIT_TAG v2025.4
 54:         GIT_SHALLOW ON
 55:     )
 56:     FetchContent_MakeAvailable(lobster)
 57: endif()
 58: 
 59: ### Options
 60: 
 61: ## Run clang-tidy linter
 62: 
 63: OPTION(WITH_CLANG_TIDY &quot;Run clang-tidy linter&quot; OFF)
 64: if (WITH_CLANG_TIDY)
 65:     set(CMAKE_CXX_CLANG_TIDY clang-tidy -checks=cppcoreguidelines-*,clang-analyzer-*,readability-*,performance-*,portability-*,concurrency-*,modernize-*)
 66: endif()
 67: 
 68: ### Libraries (lobster, lobster-impl)
 69: 
 70: ## lobster (script interpreter)
 71: if(ENABLE_LOBSTER)
 72:     add_library(lobster STATIC
 73:         ${lobster_SOURCE_DIR}/dev/external/flatbuffers/src/idl_gen_text.cpp
 74:         ${lobster_SOURCE_DIR}/dev/external/flatbuffers/src/idl_parser.cpp
 75:         ${lobster_SOURCE_DIR}/dev/external/flatbuffers/src/util.cpp
 76:         ${lobster_SOURCE_DIR}/dev/src/builtins.cpp
 77:         ${lobster_SOURCE_DIR}/dev/src/compiler.cpp
 78:         ${lobster_SOURCE_DIR}/dev/src/file.cpp
 79:         ${lobster_SOURCE_DIR}/dev/src/lobsterreader.cpp
 80:         ${lobster_SOURCE_DIR}/dev/src/platform.cpp
 81:         ${lobster_SOURCE_DIR}/dev/src/vm.cpp
 82:         ${lobster_SOURCE_DIR}/dev/src/vmdata.cpp
 83:         ${lobster_SOURCE_DIR}/dev/src/tccbind.cpp
 84:         ${lobster_SOURCE_DIR}/dev/external/libtcc/libtcc.c)
 85:     if(WIN32)
 86:         target_sources(lobster PRIVATE
 87:             ${lobster_SOURCE_DIR}/dev/include/StackWalker/StackWalker.cpp
 88:             ${lobster_SOURCE_DIR}/dev/include/StackWalker/StackWalkerHelpers.cpp)
 89:     endif(WIN32)
 90:     target_include_directories(lobster PUBLIC
 91:         ${lobster_SOURCE_DIR}/dev/src
 92:         ${lobster_SOURCE_DIR}/dev/include
 93:         ${lobster_SOURCE_DIR}/dev/external
 94:         ${lobster_SOURCE_DIR}/dev/external/libtcc)
 95: 
 96:     ## lobster-impl (provider of TreeSheets functions in lobster)
 97: 
 98:     add_library(lobster-impl STATIC src/lobster_impl.cpp)
 99:     target_link_libraries(lobster-impl PRIVATE lobster)
100: endif(ENABLE_LOBSTER)
101: 
102: ### TreeSheets executable
103: 
104: add_executable(TreeSheets
105:     src/main.cpp)
106: 
107: target_compile_definitions(TreeSheets PRIVATE &quot;PACKAGE_VERSION=\&quot;${CMAKE_PROJECT_VERSION}\&quot;&quot;)
108: if(ENABLE_LOBSTER)
109:     target_compile_definitions(TreeSheets PRIVATE &quot;ENABLE_LOBSTER=1&quot;)
110: endif(ENABLE_LOBSTER)
111: 
112: if(APPLE)
113:     set_target_properties(TreeSheets PROPERTIES
114:         MACOSX_BUNDLE TRUE
115:         MACOSX_BUNDLE_BUNDLE_NAME &quot;${CMAKE_PROJECT_NAME}&quot;
116:         MACOSX_BUNDLE_BUNDLE_VERSION &quot;${CMAKE_PROJECT_VERSION}&quot;
117:         MACOSX_BUNDLE_COPYRIGHT &quot;Copyright  2025 Wouter van Oortmerssen and Tobias Predel. All rights reserved.&quot;
118:         MACOSX_BUNDLE_GUI_IDENTIFIER &quot;com.strlen.TreeSheets&quot;
119:         MACOSX_BUNDLE_ICON_FILE &quot;App.icns&quot;
120:         MACOSX_BUNDLE_INFO_PLIST &quot;${CMAKE_SOURCE_DIR}/platform/osx/Info.plist&quot;
121:     )
122: elseif(WIN32)
123:     target_sources(TreeSheets PRIVATE
124:         platform/win/treesheets.rc)
125:     set_target_properties(TreeSheets PROPERTIES
126:         WIN32_EXECUTABLE TRUE
127:     )
128: endif()
129: 
130: target_precompile_headers(TreeSheets PUBLIC src/stdafx.h)
131: 
132: ## Link wxWidgets and lobster-impl into TreeSheets
133: set(TREESHEETS_LIBS wx::aui wx::adv wx::core wx::xml wx::net)
134: if(ENABLE_LOBSTER)
135:     list(APPEND TREESHEETS_LIBS lobster-impl)
136: endif(ENABLE_LOBSTER)
137: target_link_libraries(TreeSheets PRIVATE ${TREESHEETS_LIBS})
138: 
139: ### Installation
140: 
141: ## Platform specific installation paths
142: 
143: if(LINUX OR BSD)
144:     OPTION(TREESHEETS_RELOCATABLE_INSTALLATION &quot;Install data relative to the TreeSheets binary, instead of respecting the Filesystem Hierarchy Standard&quot; OFF)
145: endif()
146: 
147: if((LINUX OR BSD) AND NOT TREESHEETS_RELOCATABLE_INSTALLATION)
148:     include(GNUInstallDirs)
149: 
150:     set(TREESHEETS_BINDIR ${CMAKE_INSTALL_BINDIR})
151:     set(TREESHEETS_DOCDIR ${CMAKE_INSTALL_DOCDIR})
152:     set(TREESHEETS_FULL_DOCDIR ${CMAKE_INSTALL_FULL_DOCDIR})
153:     set(TREESHEETS_PKGDATADIR ${CMAKE_INSTALL_DATADIR}/${CMAKE_PROJECT_NAME})
154:     set(TREESHEETS_FULL_PKGDATADIR ${CMAKE_INSTALL_FULL_DATADIR}/${CMAKE_PROJECT_NAME})
155: 
156:     # Convert relative to absolute paths because only absolute paths are looked up on Linux (and BSD)
157:     target_compile_definitions(TreeSheets PRIVATE
158:         &quot;LOCALEDIR=L\&quot;${CMAKE_INSTALL_FULL_LOCALEDIR}\&quot;&quot;
159:         &quot;TREESHEETS_DOCDIR=\&quot;${TREESHEETS_FULL_DOCDIR}\&quot;&quot;
160:         &quot;TREESHEETS_DATADIR=\&quot;${TREESHEETS_FULL_PKGDATADIR}\&quot;&quot;
161:     )
162: 
163:     install(FILES platform/linux/com.strlen.TreeSheets.svg DESTINATION ${CMAKE_INSTALL_DATADIR}/icons/hicolor/scalable/apps)
164:     install(FILES platform/linux/com.strlen.TreeSheets.desktop DESTINATION ${CMAKE_INSTALL_DATADIR}/applications)
165:     install(FILES platform/linux/com.strlen.TreeSheets.xml DESTINATION ${CMAKE_INSTALL_DATADIR}/mime/packages)
166: elseif(APPLE)
167:     # Paths must be relative to use with CPack
168:     set(TREESHEETS_BINDIR .)
169:     set(TREESHEETS_DOCDIR TreeSheets.app/Contents/Resources)
170:     set(TREESHEETS_PKGDATADIR TreeSheets.app/Contents/Resources)
171: else()
172:     set(TREESHEETS_BINDIR .)
173:     set(TREESHEETS_DOCDIR .)
174:     set(TREESHEETS_PKGDATADIR .)
175: endif()
176: 
177: ## Installation
178: 
179: install(TARGETS TreeSheets DESTINATION ${TREESHEETS_BINDIR})
180: install(DIRECTORY TS/docs DESTINATION ${TREESHEETS_DOCDIR})
181: file(GLOB treesheets_readme_files &quot;TS/readme*.html&quot;)
182: install(FILES ${treesheets_readme_files} DESTINATION ${TREESHEETS_DOCDIR})
183: install(DIRECTORY TS/examples DESTINATION ${TREESHEETS_DOCDIR})
184: 
185: install(DIRECTORY TS/images DESTINATION ${TREESHEETS_PKGDATADIR})
186: install(DIRECTORY TS/scripts DESTINATION ${TREESHEETS_PKGDATADIR})
187: if(ENABLE_LOBSTER)
188:     set(lobster_modules
189:         ${lobster_SOURCE_DIR}/modules/std.lobster
190:         ${lobster_SOURCE_DIR}/modules/stdtype.lobster
191:         ${lobster_SOURCE_DIR}/modules/vec.lobster
192:         ${lobster_SOURCE_DIR}/modules/color.lobster
193:     )
194:     install(FILES ${lobster_modules} DESTINATION ${TREESHEETS_PKGDATADIR}/scripts/modules)
195: endif(ENABLE_LOBSTER)
196: 
197: ## Apple icon set
198: if(APPLE)
199:     install(
200:         FILES &quot;platform/osx/App.icns&quot;
201:         DESTINATION &quot;TreeSheets.app/Contents/Resources&quot;
202:     )
203: endif()
204: 
205: ## Localization
206: 
207: # Install translations to correct platform-specific path.
208: # See: https://docs.wxwidgets.org/trunk/overview_i18n.html#overview_i18n_mofiles
209: file(
210:     GLOB locales
211:     LIST_DIRECTORIES true
212:     RELATIVE ${CMAKE_CURRENT_SOURCE_DIR}/TS/translations
213:     TS/translations/*/ts.mo
214: )
215: list(
216:     TRANSFORM locales
217:     REPLACE &quot;/ts\\.mo$&quot; &quot;&quot;
218: )
219: if(WIN32 OR TREESHEETS_RELOCATABLE_INSTALLATION)
220:     foreach(locale ${locales})
221:         install(
222:             FILES &quot;TS/translations/${locale}/ts.mo&quot;
223:             # Paths must be relative to use with CPack
224:             DESTINATION &quot;translations/${locale}&quot;
225:         )
226:     endforeach()
227: elseif(APPLE)
228:     foreach(locale ${locales})
229:         install(
230:             FILES &quot;TS/translations/${locale}/ts.mo&quot;
231:             # Paths must be relative to use with CPack
232:             DESTINATION &quot;TreeSheets.app/Contents/Resources/translations/${locale}.lproj&quot;
233:         )
234:     endforeach()
235: else()
236:     # Falling back to GNU scheme
237:     foreach(locale ${locales})
238:         install(
239:             FILES &quot;TS/translations/${locale}/ts.mo&quot;
240:             DESTINATION &quot;${CMAKE_INSTALL_LOCALEDIR}/${locale}/LC_MESSAGES&quot;
241:         )
242:     endforeach()
243: endif()
244: 
245: ### Packaging with CPack
246: 
247: set(CPACK_PACKAGE_VENDOR &quot;Wouter van Oortmerssen&quot;)
248: if(APPLE)
249:     set(CPACK_GENERATOR &quot;DragNDrop&quot;)
250: elseif(WIN32)
251:     set(CPACK_GENERATOR &quot;INNOSETUP&quot; &quot;ZIP&quot;)
252:     set(CPACK_PACKAGE_INSTALL_DIRECTORY ${CMAKE_PROJECT_NAME})
253:     set(CPACK_PACKAGE_EXECUTABLES &quot;TreeSheets&quot; &quot;TreeSheets&quot;)
254:     if(CMAKE_VS_PLATFORM_NAME STREQUAL &quot;ARM64&quot; OR CMAKE_SYSTEM_PROCESSOR MATCHES &quot;ARM64|arm64&quot;)
255:         set(CPACK_INNOSETUP_SETUP_ArchitecturesAllowed &quot;arm64&quot;)
256:         set(ARCH_NAME &quot;winarm64&quot;)
257:     else()
258:         set(CPACK_INNOSETUP_SETUP_ArchitecturesAllowed &quot;x64compatible&quot;)
259:         set(ARCH_NAME &quot;winx64&quot;)
260:     endif()
261:     set(CPACK_PACKAGE_FILE_NAME &quot;${CMAKE_PROJECT_NAME}-${PROJECT_VERSION}-${ARCH_NAME}&quot;)
262:     set(CPACK_INNOSETUP_RUN_EXECUTABLES &quot;TreeSheets&quot;)
263:     set(CPACK_INNOSETUP_PACKAGE_NAME ${CMAKE_PROJECT_NAME})
264:     set(CPACK_INNOSETUP_LANGUAGES
265:         &quot;brazilianPortuguese&quot; &quot;english&quot; &quot;french&quot; &quot;german&quot; 
266:         &quot;italian&quot; &quot;korean&quot; &quot;russian&quot;
267:     )
268:     set(CPACK_INNOSETUP_SETUP_PrivilegesRequired &quot;lowest&quot;)
269:     set(CPACK_INNOSETUP_IGNORE_README_PAGE ON)
270:     set(CPACK_INNOSETUP_IGNORE_LICENSE_PAGE ON)
271:     set(CPACK_INNOSETUP_USE_MODERN_WIZARD ON)
272: else()
273:     set(CPACK_GENERATOR &quot;DEB&quot;)
274:     set(CPACK_DEBIAN_PACKAGE_SECTION &quot;contrib/text&quot;)
275:     set(CPACK_DEBIAN_PACKAGE_MAINTAINER &quot;Wouter van Oortmerssen&quot;)
276:     set(CPACK_DEBIAN_PACKAGE_SHLIBDEPS ON)
277:     set(CPACK_DEBIAN_FILE_NAME DEB-DEFAULT)
278:     set(CPACK_DEBIAN_PACKAGE_EPOCH 2)
279: endif()
280: include(CPack)</file><file path="README.md"> 1: &lt;p align=&quot;center&quot;&gt;
 2:   &lt;img src=&quot;https://github.com/user-attachments/assets/1d6dc57a-5db2-48ce-82b9-5e7675bf0e7d&quot;&gt;
 3: &lt;/p&gt;
 4: 
 5: TreeSheets ([https://strlen.com/treesheets/](https://strlen.com/treesheets/)) is a &quot;hierarchical spreadsheet&quot; that is a great replacement for spreadsheets, mind mappers, outliners, PIMs, text editors and small databases.
 6: 
 7: Suitable for any kind of data organization, such as todo lists, calendars, project management, brainstorming, organizing ideas, planning, requirements gathering, presentation of information, etc.
 8: 
 9: It&apos;s like a spreadsheet, immediately familiar, but much more suitable for complex data because it&apos;s hierarchical.
10: It&apos;s like a mind mapper, but more organized and compact.
11: It&apos;s like an outliner, but in more than one dimension.
12: It&apos;s like a text editor, but with structure.
13: 
14: Community:
15: ----------
16: If you like, you are kindly invited to join the [Discord channel](https://discord.gg/HAfKkJz) and 
17: the [Google group](https://groups.google.com/group/treesheets) for discussion.
18: 
19: Installation:
20: -------------
21: 
22: Pre-built binaries for Windows, macOS (Darwin) and Debian-based Linux distributions are available at the
23: [Release section](https://github.com/aardappel/treesheets/releases). 
24: 
25: Please note that the packages for Debian-based distributions provided are built on `ubuntu-latest` used by [GitHub Actions Runner](https://github.com/actions/runner-images). They could also be installed on other Debian-based distributions depending on whether the required dependency packages are available.
26: 
27: If you use Flatpak, you can install [TreeSheets from Flathub](https://flathub.org/apps/com.strlen.TreeSheets).
28: 
29: Source Code:
30: ------------
31: This repository contains all the files needed to build TreeSheets for various platforms.
32: 
33: ### License
34: 
35: TreeSheets has been licensed under the ZLIB license (see ZLIB_LICENSE.txt).
36: 
37: ![Workflow status](https://github.com/aardappel/treesheets/actions/workflows/build.yml/badge.svg)
38: 
39: ### Structure
40: 
41: `src` contains all source code. The code is dense, terse, and with few comments, typical for a codebase that was never
42: intended to be used by more than one person (me). On the positive side, you&apos;ll find the code very small and simple,
43: with all functionality easy to find and only in one place (no copy pasting or over-engineering). Enjoy.
44: 
45: `TS` is the folder that contains all user-facing files, typically the build process results in an executable to be put
46: in the root of this folder, and distributing to users is then a matter of giving them this folder.
47: 
48: `TODO.txt` is the random notes I kept on ideas of myself and others on what future features could be added.
49: 
50: 
51: Building:
52: ---------
53: This project uses CMake to enable compilation on various platforms and CPack on top of it to package the produced binaries. The build, installation and packaging instructions are within `CMakeLists.txt`.
54: Please note that you are responsible to know how to use compilers and C++, the hints below are all the help we will give you for building TreeSheets:
55: 
56: 1. Clone this repository
57: 
58: ```sh
59: git clone https://github.com/aardappel/treesheets
60: ```
61: 
62: 2. Change the working directory to the working tree
63: 
64: ```sh
65: cd treesheets
66: ```
67: 
68: 3. Steps for building and installation/packaging for binary distribution
69: 
70: | Step | Command | Windows | macOS | Linux |
71: | ---- | ------- | ------- | ----- | ----- |
72: | 3.1 Configure the build system | `cmake -S . -B _build -DCMAKE_BUILD_TYPE=Release` | needs Visual Studio C++ compiler for succesful compilation | | |
73: | 3.2 Build and package for binary distribution | `cmake --build _build --target package -j` | creates a ZIP archive for portable usage and a Nullsoft installer | creates a disk image for Drag and Drop installation | creates a binary Debian package |
74: | or |
75: | 3.2 Build only | `cmake --build _build -j` | Append `--config Release` | | |
76: | 3.3 Install | `cmake --install _build` | | Append `--prefix &lt;directory&gt;` to specify another installation root for the bundle | usually requires root privileges, e.g. run this command with `sudo` |
77: 
78: If you do not have `wxWidgets` installed, you may want to set `wxBUILD_INSTALL` and `wxBUILD_SHARED` to off in the build configuration. This ensures a TreeSheets build with wxWidgets libraries statically linked in.
79: 
80: Contributing:
81: -------------
82: I welcome contributions, especially in the form of neatly prepared pull requests. The main thing to keep in mind when
83: contributing is to keep as close as you can to both the format and the spirit of the existing code, even if it goes
84: against the grain of how you program normally. That means not only using the same formatting and naming conventions
85: (which should be easy), but the same non-redundant style of code (no under-engineering, e.g. copy pasting,
86: and no over engineering, e.g. needless abstractions).
87: 
88: Also be economic in terms of features: treesheets tries to accomplish a lot with few features, additional user
89: interface elements (even menu items) have a cost, and features that are only useful for very few people should
90: probably not be in the master branch. Needless to say, performance is important too. When in doubt, ask me :)
91: 
92: Try to keep your pull requests small (don&apos;t bundle unrelated changes) and make sure you&apos;ve done extensive testing
93: before you submit, preferrably on multiple platforms.</file><file path="TODO.txt">  1: [ check google moderator for new feature requests ]
  2: 
  3: - make script functions like ts_goto_child etc give an error if wrong index given rather than fail silently.
  4: 
  5: - when pasting/typing in new cell, don&apos;t use average size or size above, prefer size to right or
  6:   below.
  7: 
  8: - A way to set vertical spacing on fonts
  9: 
 10: - an auto-import/merge of an external file (e.g. a text file)
 11:   The contents of a grid would automatically be replaced by whatever is in that text file,
 12:   and maybe auto-exported when modified?
 13:   This allows TreeSheets to be a &quot;dashboard&quot; for external files, generated/edited by external
 14:   programs.
 15: 
 16: - A preview (particularly for images) of external (http &amp; file) links, either on hover over, or
 17:   even in-line. Makes for a nice alternative to inline images if there&apos;s a lot of them.
 18: 
 19: - bug: if you paste a size 0 cell into, say, a size -5 new parent, the cell that is being pasted
 20:   is set to -5 but all its children stay at 0, making for weird rendering.
 21: 
 22: - bug: if you press &quot;run&quot;, it can affect text size, and doesn&apos;t undo.
 23:   - maybe should remove &quot;run&quot; from the toolbar.
 24: 
 25: - OSX: figure out how to do retina text rendering.
 26:   https://forums.wxwidgets.org/viewtopic.php?f=23&amp;t=42806&amp;p=173880#p173880
 27: 
 28: - bug: reordering the tabs can disable editing (no selection)
 29:   - similarly, closing a sheet can make others uneditable.
 30: 
 31: - bug: insert text in cell, then INS, then Ctrl-Z: undoes also text
 32: 
 33: - bug: F6 does not find all occurrences (see Evelien&apos;s example).
 34: 
 35: - Have a version of F6 that goes backwards?
 36: 
 37: - fix lack of change detection on OS X / Linux, since more people use it with DropBox now.
 38:   - Check if wxWidgets file system monitoring works now, or emulate by polling.
 39: 
 40: - allow dropdowns to set their current value also on single click.
 41: 
 42: - allow key binding thru CTRL+menu item click? There&apos;s no way to test for ctrl in the event.
 43: 
 44: - wordcount feature, for all, and also shown for current cell
 45: 
 46: - make LEFT on the top dotted line go to parent (and maybe UP and leftmost dotted line).
 47: 
 48: - should save custom color to the cfg
 49: 
 50: - OSX: [github, Yang Xiaowei]: IME input doesn&apos;t work
 51:   No events arrive at either OnChar or OnKeyDown with e.g. Japanese IME selected, and no idea why
 52: 
 53: - Test multi-monitor off-screen detection on Windows &amp; mac.
 54: 
 55: - Windows: [Derell Licht]: unnecessary debug messages, especially in non-admin mode.
 56: 
 57: - &quot;Wrap in Parent&quot; doesn&apos;t respect the border color much like INS used to not do.
 58: 
 59: - Alt+scrollwheel doesn&apos;t seem to get recorded as undoable
 60: 
 61: - CTRL+g same as INS on other platforms
 62: 
 63: - promote/demote keys? Ctrl-Shift left and right?
 64: 
 65: - if it fails to load its icon files, it should check in the current directory - would simplify command line usage.
 66: 
 67: - non-windows platforms: wxIsalnum not returning true for certain unicode chars? xxxxxx xxxxxxxx xxxxxx Fretro xxxxx
 68: - some people have locale settings that makes it break words in the middle.
 69:   maybe do word splits based on ispunct etc instead?
 70: 
 71: - a fold/unfold all op.
 72: 
 73: - easy way to split a cell at the current cursor position, e.g. shift + enter?
 74: 
 75: - should be easy to add a simplistic drawing tool inside TreeSheets, since we already support bitmaps in cells
 76: 
 77: - it be very good to make the XML import/export closer to the native format, plenty of people would want to interoperate with TS that way
 78: 
 79: - we now skip PNGs that fail to load, but would be even better if they didn&apos;t fail at all.
 80:   - could switch to using sbimage for PNG loading, probably more robust.
 81: 
 82: - spellchecker
 83: 
 84: - print options: scale/position control, and some form of pagination
 85: 
 86: - add a way to copy only the image from a cell
 87: 
 88: - when importing from text, make sure tab is also seen as indentation
 89: 
 90: - make g_cell_margin configurable?
 91: 
 92: - if we support OPML read/write, then we can edit on iOS using e.g. http://carbonfin.com/
 93: 
 94: - CI with Travis
 95: 
 96: - LINUX: undo log fix in local git
 97: 
 98: - LINUX: (64bit) typing faster loses characters?
 99: 
100: - LINUX: Ctrl+I advances to next tab instead of italics
101: 
102: - LINUX: window resizing sometimes leads to a red blinking border and the program becoming unresponsive???
103:   -&gt; also a problem since 2.9.4 according to http://trac.wxwidgets.org/ticket/14871
104: 
105: - LINUX? recent files list not updated after Save As?
106: 
107: - the bitmaps used for rounded lines show up using black for the alpha on some printers.
108:   draw them using actual lines when in printing mode.
109: 
110: - the fact that you can&apos;t just copy a X*Y selection and paste that into a similar selection is a bit weird, e.g. if you wanted to duplicate a spreadsheet row.
111: 
112: - shift+down/up while selecting text should also extend selection.
113: 
114: - ctrl+shift+tab for changing tabs backwards
115: 
116: - modifier+enter for going left rather than down upon exiting a cell? Hmm TAB does that, but doesn&apos;t go to the line in-between.
117: 
118: - a way to navigate to previous selections (like alt+arrow in browsers)
119: 
120: - when zooming out, for any parent(s) of the selected item that also fit on screen, make sure they are shown on screen
121: 
122: - When a subgrid has multiple columns &quot;Flatten&quot; should iterate over rows (and copy rowns in their entirety) rather than iterating over each cell.
123: 
124: - file system watch should really just poll on currently open doc filestamps, which would probably be more efficient than the currently broken implementation and work on all platforms.
125: 
126: - LINUX: apparently on some systems only every second keystroke arrives at the treesheets view? how to reproduce this?
127: - LINUX: check 12.04 for libgtk error
128: 
129: - VIDEO! on the site, showing how the basics work
130: 
131: - if you open a .cts file from explorer it gives a weird error about not being able to make a connection (on Iara&apos;s computer fresh install)
132: 
133: - export images in html
134:   see also html_rendering_bugs.png
135: 
136: - if we continue or change the internal programming language, one important thing would be to give it more database functionality, i.e. do something like a SQL query on a treesheet to get a sub-view.
137: 
138: - JSON export
139: 
140: - should retain image when folding.
141: 
142: - improve drag and drop with CTRL to use current selection
143: 
144: - text alignment per cell?
145: 
146: - what&apos;s wrong with font rendering when running from within visual studio?
147: 
148: - better fold icon, clicking on it should unfold?
149:   - make the folding icon more basic like notepad++
150:   - When I fold or unfold the cell, the embedded image disappears or is replaced with a &apos;plus&apos; symbol. I&apos;d like to the image remained in the cell.
151: 
152: - insert a date stamp / time stamp
153: 
154: - stephan: way to mark a grid as numbered, and have sub grids have sub-numbering etc. (2.3)
155: 
156: - bullet pointed list / numbered list instead of grid drawing?
157: 
158: - auto-save whenever window de-focused
159: 
160: - people would really like excel style formulas
161: 
162: - easy way to have external images, such that file/loading saveing doesn&apos;t take forever. preferably loaded on demand.
163: 
164: - option for auto export
165: 
166: - export should auto suggest a filename
167: 
168: - if your top level grid has just a single cell in it, changing formatting of that grid (i.e. layout mode) is unintuitive, as you first have to do ctrl+A...
169:   either make that more obvious in the docs, or provide a better operation for that
170:   This is generally a problem as some operations operate on a grid by means of its parent cell, and others by having the whole grid selected.
171:   May well be too hard to change this now.
172: 
173: - should &quot;auto reload documents&quot; be default on now that a lot more people use DropBox etc?
174: 
175: - keep track if an image was originally a JPG, and then save it as JPG?
176: 
177: - date &amp; time functionality:
178:   - allow a range of consecutive cells be filled with dates from a picker
179:   - allow a cell to be set to a time, with an alarm attached if needed
180:     only works if it can find a date cell nearby, which is found by:
181:     - cells to the left
182:     - cells above
183:     - same for the parent
184: 
185: - load all files relative to exe path instead of cwd?
186: 
187: - the new sheet dialog confuses people into thinking that the initial size matters, e.g. http://treesheets.findmysoft.com/
188:   however, starting with a 1x1 would be confusing also
189: 
190: - calculation language sample use cases:
191:   - tag cells with a progress complete, and then have overal average progress complete figures in a hierarchical fashion
192: 
193: - treesheets suitable for code editing!
194:   - export + run + showing console output + jump to line
195:   - syntax highlighting.. might be fun even for non-programming languages
196: 
197: - could have a feature to upload to google docs
198:   http://code.google.com/apis/documents/docs/3.0/developers_guide_protocol.html#UploadingDocs
199:   http://code.google.com/p/gdata-cpp-util/
200:   wxHTTP
201: 
202: - the future for synced treesheets is to backup to an existing sharing service like google docs or simplenote
203:   you could simply:
204:   * convert current TS to an indented text file
205:   * upload to google docs
206:   * mark upload time in TS doc
207:   * when downloading:
208:     * any cells with newer dates than the last upload overwrite the google doc
209:     * any older cells may be overwritten by anything that is different in the google doc
210:     * keeps the formatting of the TS doc
211:   * should work even when the doc is shared!
212:   * can do this over google docs api, or even easier, by putting a separate file in gdrive
213:     except google docs doesn&apos;t let you edit text files online, and it doesn&apos;t sync its own files (just url)
214:     and the only way to access google docs thru c++ seems to be thru a huge library (includes libcurl and libxml)
215:     http://code.google.com/p/gdata-cpp-util/
216:     unless I parsed it myself using the wxwidgets html req etc. but there appear to be no docs on how to do it yourself?
217:     even if this works, the docs talk about uploading new docs.. what about overwriting existing *shared* docs?
218:     actually theres ways to overwrite, using a PUT request..
219:     http://www.codeproject.com/Articles/319435/Michael-Haephrati-A-Google-Docs-based-Backup-Appli
220:   * simplenote requires one http request per &quot;note&quot;, so you&apos;d have to put your entire todo in one note
221:     really need a sharing service that has text documents you can edit on the web / your phone
222:   * actually, there&apos;s text editors for dropbox. so we can do the above idea for dropbox.
223:     * would have to keep track of the last file time the file was imported or saved over
224:     * gets tricky with the real file, since if the text file gets modified, now all treesheets instances have
225:       a modified file they want to save
226:       and auto saving after an import could get you into a loop
227:       hmmm... with the text syncing the whole file syncing should really be turned off, since it complicates matters
228:       and text syncing is safer, because it merges changes, so can be done even if one user has unsaved changes (!)
229:       the merging algorithm needs to be somewhat smart, besides using dates, it needs to detect inserted and moved items
230:       hmm, should start with changing the existing changes detected algo such that it does a merge instead of asks the user
231:       this should make that process much more reliable.
232:       must also set an undo ONLY if there are any changes during a merge
233:       file then gets autosaved
234:       problem with dropbox is the .cts and .txt may be updated in an unreliable order.. ideally want to do the .cts first
235:   * a simpler idea for now: just allow a .txt file to be opened directly, and when saved also as .txt
236:     just shame about the lack of formatting, though who knows we can introduce more of that, like markdown
237: 
238: - 2 pane system: a left pane with a windows explorer style tree, and a right one that displays the regular TreeSheets workspace, zoomed in to whatever is selected on the left.
239:   That is simpler from a UI perspective, and familiar to many users. It would also allow a neat extra: for the left tree to show all open documents in tree form, not just the current one,
240:   for even quicker switching. The TreeSheets document would remember what nodes on the left are expanded or not.
241: 
242: 
243: 
244: - make a free-form opengl based representation?
245: - plugin programming: lua/squirrel/cubescript/lobster..
246:     - the current visual formulas
247:     - excel style formulas
248:     - formulas where the cell text is the formula, and the subgrid the result of evaluation
249:     - a macro system
250:     - a scripting language plugin (e.g. Lua)
251:     - generic plugins: export cell as XML, run external tool, load back in the result
252: - [james,Iara] spell checker
253: - figure out some kind of &quot;template&quot; feature for common structures, so people who don&apos;t know how to design their own treesheet can use it?
254:   - the 10x10 grid can be a confusing start for new users, because they don&apos;t realize they can shrink/grow, should do templates instead
255: - encryption? (truecrypt)
256: - [superboyac] custom keyboard assignments
257: - outliner/todo/powerpoint style hierarchy
258:   - [superboyac] easy moving up and down in hierarchy of items (like pp or outliners), not sure if these make sense:
259:     * indent means merge into the grid of sibling above
260:     * outdent means becoming a cell after current parent, and taking all following siblings with you as children
261:   - a way to linearly go to the next cell instead of hierarchically?
262:     * currently, pressing up or down for furthest selection in grid simply doesn&apos;t do anything, could make that mean go to parent... but ESC already does this
263: - BUG: the fix for seeing selection boxes at the wrong location after a forced resize now doesn&apos;t allow selections at all
264: - [james] is there a better way to choose the relative size when zoomed in such that resizing a sub grid does not have weird consequences?
265: - an additional way to exit fullscreen mode for people that forget F11. Maybe esc should deselect at top level, and then be able to esc fs?
266: - a way to hop from one view to the next for presentation mode?
267: - &quot;Save Selection As&quot; or &quot;Save View As&quot; - not frequently needed, and easy to do with copy/paste already
268: - ALT+mousewheel causes the menu to be selected, disabling further mousewheel actions
269: - [james] import for text delineated by double lf for paragraphs
270: - &quot;filter on tag&quot; -&gt; can just type tag into search field and use filter on search, more flexible
271: - [karl] keyboard shortcut key for minimize to and maximize from tray
272: - [karl] portable version (for Windows)
273: - [karl] interface translation via external (text) file
274: - [d.lynch] the auto-refocussing in horizontal mode (or maybe any) should only care for the Text, not the sub grid
275:   no: seems to already do the correct thing : get as much as the cell showing, focussing on the top left
276:   he wanted to still see the parent if possible, but that is not something that can be done in general
277: - put grid color &amp; width in XML/HTML export?
278: - tags, search, and code need to have configurable colors (as well as default colors for border/text/bg? gridlines?)
279:   Must be on a per sheet basis, because otherwise colors will clash with cell coloring from other people
280: - paste without style?
281: - replace treesheets toolbar optionally by custom panel on mac?
282: - directory browser inside treesheets?
283: - can add GC of images now easily
284: - &quot;mental stack&quot; feature for treesheets: some way to really quickly jot down what you need to do?
285: - ideas for features or presentation: http://www.omnigroup.com/applications/omnioutliner/
286: - convert examples from http://www.biggerplate.com/
287: - some way to allow to print on multiple pages. Maybe allow each cell of a grid to be on its own page? Figuring out how to split up a large treesheet automatically is not easy.
288: - do search with something other than red text, same with programming language -&gt; maybe configurable? &quot;set style of current cell as&quot;: &quot;search result&quot;, &quot;operator&quot;
289: - mac: set a minimum for text size / note in docs that ctrl==cmd / mac specific shortcuts for new grid (Cmd-Option-I), merge (Cmd+Option+R)
290:   / enter on cell says not implemented / CMD+scroll may clash with zoom
291:   if we&apos;d convert to doc/view, this may help the mac version, but that would mean losing tabs
292: - adam: add text size, bold and other features to the xml/html export
293: - wxIsAlnum returns true for chinese characters... so they can&apos;t get line-split
294: - add more formats supported by file drag &amp; drop (treesheets merge, text/xml etc).
295: - figure out different way to do
296:   * hover drawing
297:   * unicode events
298: - wxOverlay based rendering (does it support blending??)
299: - alf: copy to all selected cells
300: - fix icon in installer?
301: - vic: bug: I have the mouse setting Smart Move set on (&quot;causes the cursor to jump to the highlighted button of a new dialog box&quot;).  With all my other software, if there&apos;s a default button set, the cursor jumps to it.  But with TreeSheets, it jumps to Discard changes.
302: - selection extend with the mouse on current selection corners?
303: - leib: RTF export
304: - borders still not working properly when toolbar and statusbar turned off?
305: - Can we do better than the 1 size less printing hack?
306: - tim: unicode example is slow... must add partial refresh
307: - more icons in the toolbar | icons in the menu
308: - work on VPL - errors inside cells - a &quot;comment&quot; cell that gets skipped entirely
309: - ISSUE: arial unicode ms has rasterization bugs?
310: - BUG: rotates characters needlessly in unicode fonts?
311: - optimize typing speed when no re-layout is required
312: - shrink to selection using Paste()/CloneSel() - Grid inline/merge in parent?
313: - allow text size change independent of contained grid
314: - make ios/android versions?
315: - make undo bounded
316: - FIXMEs
317: - paste file
318: - cycle selection ctrl+alt+arrow?
319: - export using wxPdfDocument
320: - strategical zoom vs context rendering - overview vs treesheets - directory browser based on treesheets?
321: 
322: HARD TO DO / NOT WORTH THE EFFORT:
323: - remove tabs if there&apos;s only 1 -&gt; appears difficult to do, swap out notebook for a single scrollerwindow
324: 
325: REQUIRES SPECIAL TEST:
326: - scrollbar issue in ubuntu
327: - aliased text problem only occurs in release mode?
328: - linux bug: Error: can&apos;t open file &apos;./examples/tutorial.tmp&apos; (error 2: No such file or directory)
329: - outputs in debug: ..\..\src\msw\window.cpp(665): &apos;SetFocus&apos; failed with error 0x00000057 (the parameter is incorrect.)
330: - test: left/right mousewheel doesn&apos;t work
331: - (not reproducable?) toolbar becomes white sometimes?
332: 
333: UNREPRODUCABLE:
334: - seems to do corrupt toolbar rendering on windows 7 -&gt; maybe related to my use of dgipp / mactype?
335: - BUG: sometimes it can dimension a column much narrower than the text, resulting in overdraw
336:   it seemed to be related to a column width identical to a single URL (20), and text in a cell beneath
337:   * http://bsonspec.org/
338:   * none: messages constructed in code
339: - BUG: UNREPRODUCABLE: wide column layout? -&gt; there really is a gigantic string there, no idea how it got created
340: - changing font from farago to arial unicode screwed up rendering
341: - F8 (Hierarchy Swap). This crashes on the swap of the top cell in  hierarchy or the swapped cell is dissapeared.
342: - clancy: files not loading on other computer?? -&gt; likely a transfer problem
343: 
344: UNTESTABLE:
345: - BUG: untestable: crash with file updates when multiple file system watch events cause multiple popups
346: 
347: UNFIXABLE:
348: - improve scaled rendering: increase VIEWPORT_EXTENT in dc.cpp to get more accuracy? -&gt; not fixed in 2.9.1
349:   -&gt; tried changing this value to higher numbers with no difference
350: 
351: FIXED??
352: - wxStaticText hack not necessary anymore
353:     - the toolbar text rendering hack doesn&apos;t work if you shrink the window to make less of them visible.
354: 
355: ===============================
356: 
357: FAQ: older versions of logitech mouseware may interfere with treesheets operation, make sure to have the latest installed
358: 
359: ===============================</file><file path="ZLIB_LICENSE.txt"> 1: Copyright (c) 2008 Wouter van Oortmerssen
 2: 
 3: This software is provided &apos;as-is&apos;, without any express or implied
 4: warranty. In no event will the authors be held liable for any damages
 5: arising from the use of this software.
 6: 
 7: Permission is granted to anyone to use this software for any purpose,
 8: including commercial applications, and to alter it and redistribute it
 9: freely, subject to the following restrictions:
10: 
11:    1. The origin of this software must not be misrepresented; you must not
12:    claim that you wrote the original software. If you use this software
13:    in a product, an acknowledgment in the product documentation would be
14:    appreciated but is not required.
15: 
16:    2. Altered source versions must be plainly marked as such, and must not be
17:    misrepresented as being the original software.
18: 
19:    3. This notice may not be removed or altered from any source
20:    distribution.</file></files></repomix>